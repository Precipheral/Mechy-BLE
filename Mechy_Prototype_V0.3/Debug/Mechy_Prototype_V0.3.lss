
Mechy_Prototype_V0.3.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000007b0  00800100  0000275e  000027f2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000275e  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000001bb  008008b0  008008b0  00002fa2  2**0
                  ALLOC
  3 .noinit       00000002  00800a6b  00800a6b  00002fa2  2**0
                  ALLOC
  4 .comment      00000030  00000000  00000000  00002fa2  2**0
                  CONTENTS, READONLY
  5 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00002fd4  2**2
                  CONTENTS, READONLY
  6 .debug_aranges 000007a0  00000000  00000000  00003018  2**3
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   0000f7c9  00000000  00000000  000037b8  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00002f24  00000000  00000000  00012f81  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   0000c8bb  00000000  00000000  00015ea5  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000016b0  00000000  00000000  00022760  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0001fda1  00000000  00000000  00023e10  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00008597  00000000  00000000  00043bb1  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00001170  00000000  00000000  0004c148  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_macro  00009386  00000000  00000000  0004d2b8  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	e1 c2       	rjmp	.+1474   	; 0x5c4 <__ctors_end>
       2:	00 00       	nop
       4:	1b c3       	rjmp	.+1590   	; 0x63c <__bad_interrupt>
       6:	00 00       	nop
       8:	19 c3       	rjmp	.+1586   	; 0x63c <__bad_interrupt>
       a:	00 00       	nop
       c:	17 c3       	rjmp	.+1582   	; 0x63c <__bad_interrupt>
       e:	00 00       	nop
      10:	15 c3       	rjmp	.+1578   	; 0x63c <__bad_interrupt>
      12:	00 00       	nop
      14:	13 c3       	rjmp	.+1574   	; 0x63c <__bad_interrupt>
      16:	00 00       	nop
      18:	11 c3       	rjmp	.+1570   	; 0x63c <__bad_interrupt>
      1a:	00 00       	nop
      1c:	0f c3       	rjmp	.+1566   	; 0x63c <__bad_interrupt>
      1e:	00 00       	nop
      20:	0d c3       	rjmp	.+1562   	; 0x63c <__bad_interrupt>
      22:	00 00       	nop
      24:	0b c3       	rjmp	.+1558   	; 0x63c <__bad_interrupt>
      26:	00 00       	nop
      28:	0c 94 2d 11 	jmp	0x225a	; 0x225a <__vector_10>
      2c:	07 c3       	rjmp	.+1550   	; 0x63c <__bad_interrupt>
      2e:	00 00       	nop
      30:	05 c3       	rjmp	.+1546   	; 0x63c <__bad_interrupt>
      32:	00 00       	nop
      34:	03 c3       	rjmp	.+1542   	; 0x63c <__bad_interrupt>
      36:	00 00       	nop
      38:	01 c3       	rjmp	.+1538   	; 0x63c <__bad_interrupt>
      3a:	00 00       	nop
      3c:	ff c2       	rjmp	.+1534   	; 0x63c <__bad_interrupt>
      3e:	00 00       	nop
      40:	fd c2       	rjmp	.+1530   	; 0x63c <__bad_interrupt>
      42:	00 00       	nop
      44:	fb c2       	rjmp	.+1526   	; 0x63c <__bad_interrupt>
      46:	00 00       	nop
      48:	f9 c2       	rjmp	.+1522   	; 0x63c <__bad_interrupt>
      4a:	00 00       	nop
      4c:	f7 c2       	rjmp	.+1518   	; 0x63c <__bad_interrupt>
      4e:	00 00       	nop
      50:	f5 c2       	rjmp	.+1514   	; 0x63c <__bad_interrupt>
      52:	00 00       	nop
      54:	f3 c2       	rjmp	.+1510   	; 0x63c <__bad_interrupt>
      56:	00 00       	nop
      58:	f1 c2       	rjmp	.+1506   	; 0x63c <__bad_interrupt>
      5a:	00 00       	nop
      5c:	ef c2       	rjmp	.+1502   	; 0x63c <__bad_interrupt>
      5e:	00 00       	nop
      60:	ed c2       	rjmp	.+1498   	; 0x63c <__bad_interrupt>
      62:	00 00       	nop
      64:	eb c2       	rjmp	.+1494   	; 0x63c <__bad_interrupt>
      66:	00 00       	nop
      68:	e9 c2       	rjmp	.+1490   	; 0x63c <__bad_interrupt>
      6a:	00 00       	nop
      6c:	e7 c2       	rjmp	.+1486   	; 0x63c <__bad_interrupt>
      6e:	00 00       	nop
      70:	e5 c2       	rjmp	.+1482   	; 0x63c <__bad_interrupt>
      72:	00 00       	nop
      74:	e3 c2       	rjmp	.+1478   	; 0x63c <__bad_interrupt>
      76:	00 00       	nop
      78:	e1 c2       	rjmp	.+1474   	; 0x63c <__bad_interrupt>
      7a:	00 00       	nop
      7c:	df c2       	rjmp	.+1470   	; 0x63c <__bad_interrupt>
      7e:	00 00       	nop
      80:	dd c2       	rjmp	.+1466   	; 0x63c <__bad_interrupt>
      82:	00 00       	nop
      84:	db c2       	rjmp	.+1462   	; 0x63c <__bad_interrupt>
      86:	00 00       	nop
      88:	d9 c2       	rjmp	.+1458   	; 0x63c <__bad_interrupt>
      8a:	00 00       	nop
      8c:	d7 c2       	rjmp	.+1454   	; 0x63c <__bad_interrupt>
      8e:	00 00       	nop
      90:	d5 c2       	rjmp	.+1450   	; 0x63c <__bad_interrupt>
      92:	00 00       	nop
      94:	d3 c2       	rjmp	.+1446   	; 0x63c <__bad_interrupt>
      96:	00 00       	nop
      98:	d1 c2       	rjmp	.+1442   	; 0x63c <__bad_interrupt>
      9a:	00 00       	nop
      9c:	cf c2       	rjmp	.+1438   	; 0x63c <__bad_interrupt>
      9e:	00 00       	nop
      a0:	cd c2       	rjmp	.+1434   	; 0x63c <__bad_interrupt>
      a2:	00 00       	nop
      a4:	cb c2       	rjmp	.+1430   	; 0x63c <__bad_interrupt>
      a6:	00 00       	nop
      a8:	c9 c2       	rjmp	.+1426   	; 0x63c <__bad_interrupt>
	...

000000ac <ProductString>:
      ac:	2a 03 4d 00 65 00 63 00 68 00 79 00 20 00 50 00     *.M.e.c.h.y. .P.
      bc:	72 00 6f 00 74 00 6f 00 74 00 79 00 70 00 65 00     r.o.t.o.t.y.p.e.
      cc:	20 00 56 00 30 00 2e 00 33 00 00 00                  .V.0...3...

000000d8 <ManufacturerString>:
      d8:	18 03 50 00 72 00 65 00 63 00 69 00 70 00 68 00     ..P.r.e.c.i.p.h.
      e8:	65 00 72 00 61 00 6c 00 00 00                       e.r.a.l...

000000f2 <LanguageString>:
      f2:	04 03 09 04                                         ....

000000f6 <ConfigurationDescriptor>:
      f6:	09 02 22 00 01 01 00 c0 32 09 04 00 00 01 03 00     ..".....2.......
     106:	00 00 09 21 11 01 00 01 22 59 00 07 05 81 03 10     ...!...."Y......
     116:	00 05                                               ..

00000118 <DeviceDescriptor>:
     118:	12 01 10 01 00 00 00 08 a0 20 96 42 01 00 01 02     ......... .B....
     128:	00 01                                               ..

0000012a <JoystickReport>:
     12a:	05 01 09 05 a1 01 09 01 a1 00 0a 30 00 0a 31 00     ...........0..1.
     13a:	0a 33 00 0a 34 00 16 00 00 26 ff 03 95 04 75 10     .3..4....&....u.
     14a:	81 02 c0 05 01 a1 01 09 39 15 00 25 07 35 00 45     ........9..%.5.E
     15a:	3b 65 14 55 00 95 01 75 04 81 02 75 01 95 04 81     ;e.U...u...u....
     16a:	01 c0 05 09 19 01 29 0a 15 00 25 01 75 01 95 0a     ......)...%.u...
     17a:	81 02 75 01 95 06 81 01 c0                          ..u......

00000183 <setup_msgs>:
     183:	00 07 06 00 00 03 02 42 07 00 00 00 00 00 00 00     .......B........
	...
     1a3:	00 00 1f 06 10 00 39 68 00 00 02 00 09 00 0c 01     ......9h........
     1b3:	01 00 00 06 00 01 81 12 18 00 00 00 00 00 00 00     ................
     1c3:	00 00 00 1f 06 10 1c 00 00 00 00 00 00 00 00 00     ................
	...
     1db:	00 40 12 00 00 00 10 03 90 00 64 00 1f 06 10 38     .@........d....8
     1eb:	02 ff 02 58 05 05 00 00 00 00 00 00 00 00 00 00     ...X............
     1fb:	00 00 00 00 00 00 01 00 00 00 00 00 00 05 06 10     ................
     20b:	54 01 01 00 00 00 00 00 00 00 00 00 00 00 00 00     T...............
	...
     227:	00 00 1f 06 20 00 04 04 02 02 00 01 28 00 01 00     .... .......(...
     237:	18 04 04 05 05 00 02 28 03 01 0e 03 00 00 2a 04     .......(......*.
     247:	34 10 00 1f 06 20 1c 10 00 03 2a 00 01 4d 65 63     4.... ....*..Mec
     257:	68 79 20 43 6f 6e 74 72 6f 6c 6c 65 72 04 04 05     hy Controller...
     267:	05 00 04 00 1f 06 20 38 28 03 01 02 05 00 01 2a     ...... 8(......*
     277:	06 04 03 02 00 05 2a 01 01 c3 03 04 04 05 05 00     ......*.........
     287:	06 28 03 01 00 1f 06 20 54 02 07 00 04 2a 06 04     .(..... T....*..
     297:	09 08 00 07 2a 04 01 06 00 18 00 06 00 64 00 04     ....*........d..
     2a7:	04 02 02 00 08 00 1f 06 20 70 28 00 01 01 18 04     ........ p(.....
     2b7:	04 02 02 00 09 28 00 01 0f 18 04 04 05 05 00 0a     .....(..........
     2c7:	28 03 01 12 0b 00 00 1f 06 20 8c 19 2a 16 0c 02     (........ ..*...
     2d7:	01 00 0b 2a 19 01 32 46 34 03 02 00 0c 29 02 01     ...*..2F4....)..
     2e7:	00 00 04 04 05 05 00 00 1f 06 20 a8 0d 28 03 01     .......... ..(..
     2f7:	02 0e 00 1a 2a 06 0c 02 01 00 0e 2a 1a 01 2f 04     ....*......*../.
     307:	04 02 02 00 0f 28 00 01 00 1f 06 20 c4 12 18 04     .....(..... ....
     317:	04 05 05 00 10 28 03 01 02 11 00 4a 2a 06 0c 05     .....(.....J*...
     327:	04 00 11 2a 4a 01 11 01 00 00 1f 06 20 e0 01 04     ...*J....... ...
     337:	04 05 05 00 12 28 03 01 04 13 00 4c 2a 46 30 02     .....(.....L*F0.
     347:	01 00 13 2a 4c 01 00 04 04 05 00 1f 06 20 fc 05     ...*L........ ..
     357:	00 14 28 03 01 02 15 00 4b 2a 04 0c 3d 3d 00 15     ..(.....K*..==..
     367:	2a 4b 01 05 01 09 04 a1 01 85 01 00 1f 06 21 18     *K............!.
     377:	a1 02 09 32 09 31 09 30 15 00 26 ff 00 35 00 46     ...2.1.0..&..5.F
     387:	ff 00 75 08 95 03 81 02 c0 85 02 a1 00 1f 06 21     ..u............!
     397:	34 02 05 09 29 02 19 01 95 02 75 01 25 01 15 00     4...).....u.%...
     3a7:	81 02 95 01 75 06 81 01 c0 c0 04 04 05 00 1f 06     ....u...........
     3b7:	21 50 05 00 16 28 03 01 12 17 00 4d 2a 14 0c 03     !P...(.....M*...
     3c7:	00 00 17 2a 4d 01 00 00 00 46 34 03 02 00 00 1f     ...*M....F4.....
     3d7:	06 21 6c 18 29 02 01 00 00 06 0c 03 02 00 19 29     .!l.)..........)
     3e7:	08 01 01 01 04 04 05 05 00 1a 28 03 01 12 1b 00     ..........(.....
     3f7:	1f 06 21 88 00 4d 2a 14 0c 01 00 00 1b 2a 4d 01     ..!..M*......*M.
     407:	00 46 34 03 02 00 1c 29 02 01 00 00 06 0c 03 02     .F4....)........
     417:	00 1f 06 21 a4 00 1d 29 08 01 02 01 04 04 02 02     ...!...)........
     427:	00 1e 28 00 01 13 18 04 04 05 05 00 1f 28 03 01     ..(..........(..
     437:	04 00 1f 06 21 c0 20 00 4f 2a 46 30 05 04 00 20     ....!. .O*F0... 
     447:	2a 4f 01 00 00 00 00 04 04 05 05 00 21 28 03 01     *O..........!(..
     457:	10 22 00 1f 06 21 dc 00 31 2a 14 00 01 00 00 22     ."...!..1*....."
     467:	2a 31 01 00 46 34 03 02 00 23 29 02 01 00 00 04     *1..F4...#).....
     477:	04 02 02 00 1f 06 21 f8 00 24 28 00 01 0a 18 04     ......!..$(.....
     487:	04 05 05 00 25 28 03 01 02 26 00 50 2a 06 0c 08     ....%(...&.P*...
     497:	07 00 26 2a 00 1f 06 22 14 50 01 02 15 19 dd dd     ..&*...".P......
     4a7:	01 00 04 04 05 05 00 27 28 03 01 02 28 00 27 2a     .......'(...(.'*
     4b7:	04 0c 09 01 00 00 11 06 22 30 28 2a 27 01 0a 00     ........"0(*'...
	...
     4db:	00 00 00 1f 06 40 00 2a 00 01 00 80 04 00 03 00     .....@.*........
     4eb:	00 2a 19 01 00 82 04 00 0b 00 0c 2a 1a 01 00 80     .*.........*....
     4fb:	04 00 0e 00 1f 06 40 1c 00 00 2a 4c 01 00 08 04     ......@...*L....
     50b:	00 13 00 00 2a 4d 01 00 82 04 00 17 00 18 2a 4d     ....*M........*M
     51b:	01 00 82 04 00 1f 06 40 38 00 1b 00 1c 2a 4f 01     .......@8....*O.
     52b:	00 08 04 00 20 00 00 2a 31 01 00 02 04 00 22 00     .... ..*1.....".
     53b:	23 2a 27 01 00 00 09 06 40 54 80 04 00 28 00 00     #*'.....@T...(..
	...
     55f:	00 00 00 1e 06 60 00 00 00 00 00 00 00 00 00 00     .....`..........
	...
     583:	19 06 70 00 19 02 c3 03 00 00 00 00 00 00 00 00     ..p.............
	...
     5a3:	00 06 06 f0 00 03 bd 51 00 00 00 00 00 00 00 00     .......Q........
	...

000005c4 <__ctors_end>:
     5c4:	11 24       	eor	r1, r1
     5c6:	1f be       	out	0x3f, r1	; 63
     5c8:	cf ef       	ldi	r28, 0xFF	; 255
     5ca:	da e0       	ldi	r29, 0x0A	; 10
     5cc:	de bf       	out	0x3e, r29	; 62
     5ce:	cd bf       	out	0x3d, r28	; 61

000005d0 <bootloader_jump_check>:
  return crc;
}

void bootloader_jump_check (void)
{
  uint8_t wdt_flag = MCUSR & (1 << WDRF);
     5d0:	94 b7       	in	r25, 0x34	; 52

  MCUSR &= ~(1 << WDRF);
     5d2:	84 b7       	in	r24, 0x34	; 52
     5d4:	87 7f       	andi	r24, 0xF7	; 247
     5d6:	84 bf       	out	0x34, r24	; 52
		);
	}
	else
	{
        uint8_t register temp_reg;
		__asm__ __volatile__ (
     5d8:	0f b6       	in	r0, 0x3f	; 63
     5da:	f8 94       	cli
     5dc:	a8 95       	wdr
     5de:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__TEXT_REGION_LENGTH__+0x7e0060>
     5e2:	88 61       	ori	r24, 0x18	; 24
     5e4:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__TEXT_REGION_LENGTH__+0x7e0060>
     5e8:	10 92 60 00 	sts	0x0060, r1	; 0x800060 <__TEXT_REGION_LENGTH__+0x7e0060>
     5ec:	0f be       	out	0x3f, r0	; 63
  wdt_disable();

  if (wdt_flag && (boot_key == BOOTLOADER_KEY)) {
     5ee:	93 ff       	sbrs	r25, 3
     5f0:	0e c0       	rjmp	.+28     	; 0x60e <__do_copy_data>
     5f2:	80 91 6b 0a 	lds	r24, 0x0A6B	; 0x800a6b <__bss_end>
     5f6:	90 91 6c 0a 	lds	r25, 0x0A6C	; 0x800a6c <__bss_end+0x1>
     5fa:	82 34       	cpi	r24, 0x42	; 66
     5fc:	9c 4d       	sbci	r25, 0xDC	; 220
     5fe:	39 f4       	brne	.+14     	; 0x60e <__do_copy_data>
    boot_key = 0;
     600:	10 92 6c 0a 	sts	0x0A6C, r1	; 0x800a6c <__bss_end+0x1>
     604:	10 92 6b 0a 	sts	0x0A6B, r1	; 0x800a6b <__bss_end>

    ((void (*)(void)) BOOTLOADER_START_ADDR) ();
     608:	e0 e0       	ldi	r30, 0x00	; 0
     60a:	f8 e3       	ldi	r31, 0x38	; 56
     60c:	09 95       	icall

0000060e <__do_copy_data>:
     60e:	18 e0       	ldi	r17, 0x08	; 8
     610:	a0 e0       	ldi	r26, 0x00	; 0
     612:	b1 e0       	ldi	r27, 0x01	; 1
     614:	ee e5       	ldi	r30, 0x5E	; 94
     616:	f7 e2       	ldi	r31, 0x27	; 39
     618:	02 c0       	rjmp	.+4      	; 0x61e <__do_copy_data+0x10>
     61a:	05 90       	lpm	r0, Z+
     61c:	0d 92       	st	X+, r0
     61e:	a0 3b       	cpi	r26, 0xB0	; 176
     620:	b1 07       	cpc	r27, r17
     622:	d9 f7       	brne	.-10     	; 0x61a <__do_copy_data+0xc>

00000624 <__do_clear_bss>:
     624:	2a e0       	ldi	r18, 0x0A	; 10
     626:	a0 eb       	ldi	r26, 0xB0	; 176
     628:	b8 e0       	ldi	r27, 0x08	; 8
     62a:	01 c0       	rjmp	.+2      	; 0x62e <.do_clear_bss_start>

0000062c <.do_clear_bss_loop>:
     62c:	1d 92       	st	X+, r1

0000062e <.do_clear_bss_start>:
     62e:	ab 36       	cpi	r26, 0x6B	; 107
     630:	b2 07       	cpc	r27, r18
     632:	e1 f7       	brne	.-8      	; 0x62c <.do_clear_bss_loop>
     634:	0e 94 79 0e 	call	0x1cf2	; 0x1cf2 <main>
     638:	0c 94 ad 13 	jmp	0x275a	; 0x275a <_exit>

0000063c <__bad_interrupt>:
     63c:	e1 cc       	rjmp	.-1598   	; 0x0 <__vectors>

0000063e <CALLBACK_USB_GetDescriptor>:
     63e:	29 2f       	mov	r18, r25
     640:	33 27       	eor	r19, r19
     642:	23 30       	cpi	r18, 0x03	; 3
     644:	31 05       	cpc	r19, r1
     646:	c9 f0       	breq	.+50     	; 0x67a <CALLBACK_USB_GetDescriptor+0x3c>
     648:	38 f4       	brcc	.+14     	; 0x658 <CALLBACK_USB_GetDescriptor+0x1a>
     64a:	21 30       	cpi	r18, 0x01	; 1
     64c:	31 05       	cpc	r19, r1
     64e:	59 f0       	breq	.+22     	; 0x666 <CALLBACK_USB_GetDescriptor+0x28>
     650:	22 30       	cpi	r18, 0x02	; 2
     652:	31 05       	cpc	r19, r1
     654:	69 f0       	breq	.+26     	; 0x670 <CALLBACK_USB_GetDescriptor+0x32>
     656:	35 c0       	rjmp	.+106    	; 0x6c2 <CALLBACK_USB_GetDescriptor+0x84>
     658:	21 32       	cpi	r18, 0x21	; 33
     65a:	31 05       	cpc	r19, r1
     65c:	41 f1       	breq	.+80     	; 0x6ae <CALLBACK_USB_GetDescriptor+0x70>
     65e:	22 32       	cpi	r18, 0x22	; 34
     660:	31 05       	cpc	r19, r1
     662:	51 f1       	breq	.+84     	; 0x6b8 <CALLBACK_USB_GetDescriptor+0x7a>
     664:	2e c0       	rjmp	.+92     	; 0x6c2 <CALLBACK_USB_GetDescriptor+0x84>
     666:	82 e1       	ldi	r24, 0x12	; 18
     668:	90 e0       	ldi	r25, 0x00	; 0
     66a:	28 e1       	ldi	r18, 0x18	; 24
     66c:	31 e0       	ldi	r19, 0x01	; 1
     66e:	32 c0       	rjmp	.+100    	; 0x6d4 <CALLBACK_USB_GetDescriptor+0x96>
     670:	82 e2       	ldi	r24, 0x22	; 34
     672:	90 e0       	ldi	r25, 0x00	; 0
     674:	26 ef       	ldi	r18, 0xF6	; 246
     676:	30 e0       	ldi	r19, 0x00	; 0
     678:	2d c0       	rjmp	.+90     	; 0x6d4 <CALLBACK_USB_GetDescriptor+0x96>
     67a:	99 27       	eor	r25, r25
     67c:	81 30       	cpi	r24, 0x01	; 1
     67e:	91 05       	cpc	r25, r1
     680:	51 f0       	breq	.+20     	; 0x696 <CALLBACK_USB_GetDescriptor+0x58>
     682:	18 f0       	brcs	.+6      	; 0x68a <CALLBACK_USB_GetDescriptor+0x4c>
     684:	02 97       	sbiw	r24, 0x02	; 2
     686:	69 f0       	breq	.+26     	; 0x6a2 <CALLBACK_USB_GetDescriptor+0x64>
     688:	21 c0       	rjmp	.+66     	; 0x6cc <CALLBACK_USB_GetDescriptor+0x8e>
     68a:	e2 ef       	ldi	r30, 0xF2	; 242
     68c:	f0 e0       	ldi	r31, 0x00	; 0
     68e:	84 91       	lpm	r24, Z
     690:	90 e0       	ldi	r25, 0x00	; 0
     692:	9f 01       	movw	r18, r30
     694:	1f c0       	rjmp	.+62     	; 0x6d4 <CALLBACK_USB_GetDescriptor+0x96>
     696:	e8 ed       	ldi	r30, 0xD8	; 216
     698:	f0 e0       	ldi	r31, 0x00	; 0
     69a:	84 91       	lpm	r24, Z
     69c:	90 e0       	ldi	r25, 0x00	; 0
     69e:	9f 01       	movw	r18, r30
     6a0:	19 c0       	rjmp	.+50     	; 0x6d4 <CALLBACK_USB_GetDescriptor+0x96>
     6a2:	ec ea       	ldi	r30, 0xAC	; 172
     6a4:	f0 e0       	ldi	r31, 0x00	; 0
     6a6:	84 91       	lpm	r24, Z
     6a8:	90 e0       	ldi	r25, 0x00	; 0
     6aa:	9f 01       	movw	r18, r30
     6ac:	13 c0       	rjmp	.+38     	; 0x6d4 <CALLBACK_USB_GetDescriptor+0x96>
     6ae:	89 e0       	ldi	r24, 0x09	; 9
     6b0:	90 e0       	ldi	r25, 0x00	; 0
     6b2:	28 e0       	ldi	r18, 0x08	; 8
     6b4:	31 e0       	ldi	r19, 0x01	; 1
     6b6:	0e c0       	rjmp	.+28     	; 0x6d4 <CALLBACK_USB_GetDescriptor+0x96>
     6b8:	89 e5       	ldi	r24, 0x59	; 89
     6ba:	90 e0       	ldi	r25, 0x00	; 0
     6bc:	2a e2       	ldi	r18, 0x2A	; 42
     6be:	31 e0       	ldi	r19, 0x01	; 1
     6c0:	09 c0       	rjmp	.+18     	; 0x6d4 <CALLBACK_USB_GetDescriptor+0x96>
     6c2:	80 e0       	ldi	r24, 0x00	; 0
     6c4:	90 e0       	ldi	r25, 0x00	; 0
     6c6:	20 e0       	ldi	r18, 0x00	; 0
     6c8:	30 e0       	ldi	r19, 0x00	; 0
     6ca:	04 c0       	rjmp	.+8      	; 0x6d4 <CALLBACK_USB_GetDescriptor+0x96>
     6cc:	80 e0       	ldi	r24, 0x00	; 0
     6ce:	90 e0       	ldi	r25, 0x00	; 0
     6d0:	20 e0       	ldi	r18, 0x00	; 0
     6d2:	30 e0       	ldi	r19, 0x00	; 0
     6d4:	fa 01       	movw	r30, r20
     6d6:	31 83       	std	Z+1, r19	; 0x01
     6d8:	20 83       	st	Z, r18
     6da:	08 95       	ret

000006dc <Serial_SendString>:
     6dc:	cf 93       	push	r28
     6de:	df 93       	push	r29
     6e0:	fc 01       	movw	r30, r24
     6e2:	20 81       	ld	r18, Z
     6e4:	22 23       	and	r18, r18
     6e6:	69 f0       	breq	.+26     	; 0x702 <Serial_SendString+0x26>
     6e8:	dc 01       	movw	r26, r24
     6ea:	11 96       	adiw	r26, 0x01	; 1
     6ec:	e8 ec       	ldi	r30, 0xC8	; 200
     6ee:	f0 e0       	ldi	r31, 0x00	; 0
     6f0:	ce ec       	ldi	r28, 0xCE	; 206
     6f2:	d0 e0       	ldi	r29, 0x00	; 0
     6f4:	90 81       	ld	r25, Z
     6f6:	95 ff       	sbrs	r25, 5
     6f8:	fd cf       	rjmp	.-6      	; 0x6f4 <Serial_SendString+0x18>
     6fa:	28 83       	st	Y, r18
     6fc:	2d 91       	ld	r18, X+
     6fe:	21 11       	cpse	r18, r1
     700:	f9 cf       	rjmp	.-14     	; 0x6f4 <Serial_SendString+0x18>
     702:	df 91       	pop	r29
     704:	cf 91       	pop	r28
     706:	08 95       	ret

00000708 <__ble_assert>:

static bool timing_change_done = false; //Move to BLE.h?

/* Define how assert should function in the BLE library */
void __ble_assert(const char *file, uint16_t line)
{
     708:	8c 01       	movw	r16, r24
     70a:	eb 01       	movw	r28, r22
  Serial_SendString("ERROR \r\n");
     70c:	87 e2       	ldi	r24, 0x27	; 39
     70e:	91 e0       	ldi	r25, 0x01	; 1
  Serial_SendString(file);
     710:	e5 df       	rcall	.-54     	; 0x6dc <Serial_SendString>
  Serial_SendString(": ");
     712:	c8 01       	movw	r24, r16
     714:	e3 df       	rcall	.-58     	; 0x6dc <Serial_SendString>
  Serial_SendString((char*)line); //AHJ
     716:	8d e8       	ldi	r24, 0x8D	; 141
     718:	98 e0       	ldi	r25, 0x08	; 8
  Serial_SendString("\n");
     71a:	e0 df       	rcall	.-64     	; 0x6dc <Serial_SendString>
     71c:	ce 01       	movw	r24, r28
     71e:	de df       	rcall	.-68     	; 0x6dc <Serial_SendString>
     720:	88 e0       	ldi	r24, 0x08	; 8
     722:	95 e0       	ldi	r25, 0x05	; 5
     724:	db df       	rcall	.-74     	; 0x6dc <Serial_SendString>
     726:	ff cf       	rjmp	.-2      	; 0x726 <__ble_assert+0x1e>

00000728 <bond_data_restore>:
/*
Read the Dynamic data from the EEPROM and send then as ACI Write Dynamic Data to the nRF8001
This will restore the nRF8001 to the situation when the Dynamic Data was Read out
*/
aci_status_code_t bond_data_restore(aci_state_t *aci_stat, uint8_t eeprom_status, bool *bonded_first_time_state)
{
     728:	af 92       	push	r10
     72a:	bf 92       	push	r11
     72c:	cf 92       	push	r12
     72e:	df 92       	push	r13
     730:	ef 92       	push	r14
     732:	ff 92       	push	r15
     734:	0f 93       	push	r16
     736:	1f 93       	push	r17
     738:	cf 93       	push	r28
     73a:	df 93       	push	r29
     73c:	8c 01       	movw	r16, r24
     73e:	6a 01       	movw	r12, r20
  uint8_t write_dyn_num_msgs = 0;
  uint8_t len = 0;


  // Get the number of messages to write for the eeprom_status
  write_dyn_num_msgs = eeprom_status & 0x7F;
     740:	d6 2f       	mov	r29, r22
     742:	df 77       	andi	r29, 0x7F	; 127
This will restore the nRF8001 to the situation when the Dynamic Data was Read out
*/
aci_status_code_t bond_data_restore(aci_state_t *aci_stat, uint8_t eeprom_status, bool *bonded_first_time_state)
{
  aci_evt_t *aci_evt;
  uint8_t eeprom_offset_read = 1;
     744:	bb 24       	eor	r11, r11
     746:	b3 94       	inc	r11
  //Read from the EEPROM
  while(1)
  {
    len = eeprom_read_byte((uint8_t*)(uint16_t) eeprom_offset_read);
    eeprom_offset_read++;
    aci_cmd.buffer[0] = len;
     748:	0f 2e       	mov	r0, r31
     74a:	f2 eb       	ldi	r31, 0xB2	; 178
     74c:	ef 2e       	mov	r14, r31
     74e:	f8 e0       	ldi	r31, 0x08	; 8
     750:	ff 2e       	mov	r15, r31
     752:	f0 2d       	mov	r31, r0
  write_dyn_num_msgs = eeprom_status & 0x7F;

  //Read from the EEPROM
  while(1)
  {
    len = eeprom_read_byte((uint8_t*)(uint16_t) eeprom_offset_read);
     754:	8b 2d       	mov	r24, r11
     756:	90 e0       	ldi	r25, 0x00	; 0
     758:	0e 94 93 13 	call	0x2726	; 0x2726 <eeprom_read_byte>
     75c:	a8 2e       	mov	r10, r24
    eeprom_offset_read++;
     75e:	b3 94       	inc	r11
    aci_cmd.buffer[0] = len;
     760:	f7 01       	movw	r30, r14
     762:	81 83       	std	Z+1, r24	; 0x01

    for (uint8_t i=1; i<=len; i++)
     764:	88 23       	and	r24, r24
     766:	71 f0       	breq	.+28     	; 0x784 <bond_data_restore+0x5c>
     768:	c1 e0       	ldi	r28, 0x01	; 1
    {
        aci_cmd.buffer[i] = eeprom_read_byte((uint8_t*)(uint16_t) eeprom_offset_read);
     76a:	8b 2d       	mov	r24, r11
     76c:	90 e0       	ldi	r25, 0x00	; 0
     76e:	0e 94 93 13 	call	0x2726	; 0x2726 <eeprom_read_byte>
     772:	ec 2f       	mov	r30, r28
     774:	f0 e0       	ldi	r31, 0x00	; 0
     776:	ee 54       	subi	r30, 0x4E	; 78
     778:	f7 4f       	sbci	r31, 0xF7	; 247
     77a:	81 83       	std	Z+1, r24	; 0x01
        eeprom_offset_read++;
     77c:	b3 94       	inc	r11
  {
    len = eeprom_read_byte((uint8_t*)(uint16_t) eeprom_offset_read);
    eeprom_offset_read++;
    aci_cmd.buffer[0] = len;

    for (uint8_t i=1; i<=len; i++)
     77e:	cf 5f       	subi	r28, 0xFF	; 255
     780:	ac 16       	cp	r10, r28
     782:	98 f7       	brcc	.-26     	; 0x76a <bond_data_restore+0x42>
    {
        aci_cmd.buffer[i] = eeprom_read_byte((uint8_t*)(uint16_t) eeprom_offset_read);
        eeprom_offset_read++;
    }
    //Send the ACI Write Dynamic Data
    if (!hal_aci_tl_send(&aci_cmd))
     784:	c7 01       	movw	r24, r14
     786:	d9 d6       	rcall	.+3506   	; 0x153a <hal_aci_tl_send>
     788:	81 11       	cpse	r24, r1
     78a:	05 c0       	rjmp	.+10     	; 0x796 <bond_data_restore+0x6e>
    {
      Serial_SendString("bond_data_restore: Cmd Q Full\r\n");
     78c:	80 e3       	ldi	r24, 0x30	; 48
     78e:	91 e0       	ldi	r25, 0x01	; 1
     790:	a5 df       	rcall	.-182    	; 0x6dc <Serial_SendString>
      return ACI_STATUS_ERROR_INTERNAL;
     792:	81 e8       	ldi	r24, 0x81	; 129
     794:	24 c0       	rjmp	.+72     	; 0x7de <bond_data_restore+0xb6>
    }

    //Spin in the while loop waiting for an event
    while (1)
    {
      if (lib_aci_event_get(aci_stat, &aci_data))
     796:	63 ed       	ldi	r22, 0xD3	; 211
     798:	78 e0       	ldi	r23, 0x08	; 8
     79a:	c8 01       	movw	r24, r16
     79c:	0e 94 d1 0b 	call	0x17a2	; 0x17a2 <lib_aci_event_get>
     7a0:	88 23       	and	r24, r24
     7a2:	c9 f3       	breq	.-14     	; 0x796 <bond_data_restore+0x6e>
      {
        aci_evt = &aci_data.evt;

        if (ACI_EVT_CMD_RSP != aci_evt->evt_opcode)
     7a4:	80 91 d5 08 	lds	r24, 0x08D5	; 0x8008d5 <aci_data+0x2>
     7a8:	84 38       	cpi	r24, 0x84	; 132
        {
          //Got something other than a command response evt -> Error
          Serial_SendString("bond_data_restore: Expected cmd rsp evt. Got: 0x\r\n");
     7aa:	49 f0       	breq	.+18     	; 0x7be <bond_data_restore+0x96>
     7ac:	80 e5       	ldi	r24, 0x50	; 80
          Serial_SendString((char*) aci_evt->evt_opcode);   //How to send values?? AHJ
     7ae:	91 e0       	ldi	r25, 0x01	; 1
     7b0:	95 df       	rcall	.-214    	; 0x6dc <Serial_SendString>
     7b2:	80 91 d5 08 	lds	r24, 0x08D5	; 0x8008d5 <aci_data+0x2>
          return ACI_STATUS_ERROR_INTERNAL;
     7b6:	90 e0       	ldi	r25, 0x00	; 0
     7b8:	91 df       	rcall	.-222    	; 0x6dc <Serial_SendString>
        }
        else
        {
          write_dyn_num_msgs--;
     7ba:	81 e8       	ldi	r24, 0x81	; 129

          //ACI Evt Command Response
          if (ACI_STATUS_TRANSACTION_COMPLETE == aci_evt->params.cmd_rsp.cmd_status)
     7bc:	10 c0       	rjmp	.+32     	; 0x7de <bond_data_restore+0xb6>
     7be:	d1 50       	subi	r29, 0x01	; 1
     7c0:	80 91 d7 08 	lds	r24, 0x08D7	; 0x8008d7 <aci_data+0x4>
          {
            //Set the state variables correctly
            *bonded_first_time_state = false;
     7c4:	82 30       	cpi	r24, 0x02	; 2
     7c6:	29 f4       	brne	.+10     	; 0x7d2 <bond_data_restore+0xaa>
            aci_stat->bonded = ACI_BOND_STATUS_SUCCESS;
     7c8:	f6 01       	movw	r30, r12
     7ca:	10 82       	st	Z, r1

            return ACI_STATUS_TRANSACTION_COMPLETE;
     7cc:	f8 01       	movw	r30, r16
          }
          if (0 >= write_dyn_num_msgs)
     7ce:	12 8a       	std	Z+18, r1	; 0x12
     7d0:	06 c0       	rjmp	.+12     	; 0x7de <bond_data_restore+0xb6>
          {
            //should have returned earlier
            return ACI_STATUS_ERROR_INTERNAL;
          }
          if (ACI_STATUS_TRANSACTION_CONTINUE == aci_evt->params.cmd_rsp.cmd_status)
     7d2:	dd 23       	and	r29, r29
     7d4:	19 f0       	breq	.+6      	; 0x7dc <bond_data_restore+0xb4>
     7d6:	81 30       	cpi	r24, 0x01	; 1
            return ACI_STATUS_TRANSACTION_COMPLETE;
          }
          if (0 >= write_dyn_num_msgs)
          {
            //should have returned earlier
            return ACI_STATUS_ERROR_INTERNAL;
     7d8:	f1 f6       	brne	.-68     	; 0x796 <bond_data_restore+0x6e>
        }
      }
    }

  }
}
     7da:	bc cf       	rjmp	.-136    	; 0x754 <bond_data_restore+0x2c>
     7dc:	81 e8       	ldi	r24, 0x81	; 129
     7de:	df 91       	pop	r29
     7e0:	cf 91       	pop	r28
     7e2:	1f 91       	pop	r17
     7e4:	0f 91       	pop	r16
     7e6:	ff 90       	pop	r15
     7e8:	ef 90       	pop	r14
     7ea:	df 90       	pop	r13
     7ec:	cf 90       	pop	r12
     7ee:	bf 90       	pop	r11
     7f0:	af 90       	pop	r10
     7f2:	08 95       	ret

000007f4 <bond_data_store>:
/*
This function is specific to the atmega328
@params ACI Command Response Evt received from the Read Dynamic Data
*/
void bond_data_store(aci_evt_t *evt)
{
     7f4:	1f 93       	push	r17
     7f6:	cf 93       	push	r28
     7f8:	df 93       	push	r29
     7fa:	ec 01       	movw	r28, r24
  //Serial_SendString("Storing Bond Data\r\n");
  static uint16_t eeprom_write_offset = 0x01;  //uint16_t was int

  //Write it to non-volatile storage
  eeprom_update_byte((uint8_t*)(uint16_t)eeprom_write_offset, (evt->len)-2 );
     7fc:	68 81       	ld	r22, Y
     7fe:	62 50       	subi	r22, 0x02	; 2
     800:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
     804:	90 91 01 01 	lds	r25, 0x0101	; 0x800101 <__data_start+0x1>
     808:	0e 94 9b 13 	call	0x2736	; 0x2736 <eeprom_update_byte>
  eeprom_write_offset++;
     80c:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
     810:	90 91 01 01 	lds	r25, 0x0101	; 0x800101 <__data_start+0x1>
     814:	01 96       	adiw	r24, 0x01	; 1
     816:	90 93 01 01 	sts	0x0101, r25	; 0x800101 <__data_start+0x1>
     81a:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>

  eeprom_update_byte((uint8_t*)(uint16_t)eeprom_write_offset, ACI_CMD_WRITE_DYNAMIC_DATA);
     81e:	68 e0       	ldi	r22, 0x08	; 8
     820:	0e 94 9b 13 	call	0x2736	; 0x2736 <eeprom_update_byte>
  eeprom_write_offset++;
     824:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
     828:	90 91 01 01 	lds	r25, 0x0101	; 0x800101 <__data_start+0x1>
     82c:	01 96       	adiw	r24, 0x01	; 1
     82e:	90 93 01 01 	sts	0x0101, r25	; 0x800101 <__data_start+0x1>
     832:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>

  for (uint8_t i=0; i< ((evt->len)-3); i++)
     836:	88 81       	ld	r24, Y
     838:	90 e0       	ldi	r25, 0x00	; 0
     83a:	03 97       	sbiw	r24, 0x03	; 3
     83c:	18 16       	cp	r1, r24
     83e:	19 06       	cpc	r1, r25
     840:	fc f4       	brge	.+62     	; 0x880 <bond_data_store+0x8c>
     842:	20 e0       	ldi	r18, 0x00	; 0
     844:	30 e0       	ldi	r19, 0x00	; 0
     846:	10 e0       	ldi	r17, 0x00	; 0
  {
    eeprom_update_byte((uint8_t*)(uint16_t)eeprom_write_offset, evt->params.cmd_rsp.params.padding[i]);
     848:	fe 01       	movw	r30, r28
     84a:	e2 0f       	add	r30, r18
     84c:	f3 1f       	adc	r31, r19
     84e:	64 81       	ldd	r22, Z+4	; 0x04
     850:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
     854:	90 91 01 01 	lds	r25, 0x0101	; 0x800101 <__data_start+0x1>
     858:	0e 94 9b 13 	call	0x2736	; 0x2736 <eeprom_update_byte>
    eeprom_write_offset++;
     85c:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
     860:	90 91 01 01 	lds	r25, 0x0101	; 0x800101 <__data_start+0x1>
     864:	01 96       	adiw	r24, 0x01	; 1
     866:	90 93 01 01 	sts	0x0101, r25	; 0x800101 <__data_start+0x1>
     86a:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
  eeprom_write_offset++;

  eeprom_update_byte((uint8_t*)(uint16_t)eeprom_write_offset, ACI_CMD_WRITE_DYNAMIC_DATA);
  eeprom_write_offset++;

  for (uint8_t i=0; i< ((evt->len)-3); i++)
     86e:	1f 5f       	subi	r17, 0xFF	; 255
     870:	21 2f       	mov	r18, r17
     872:	30 e0       	ldi	r19, 0x00	; 0
     874:	88 81       	ld	r24, Y
     876:	90 e0       	ldi	r25, 0x00	; 0
     878:	03 97       	sbiw	r24, 0x03	; 3
     87a:	28 17       	cp	r18, r24
     87c:	39 07       	cpc	r19, r25
     87e:	24 f3       	brlt	.-56     	; 0x848 <bond_data_store+0x54>
  {
    eeprom_update_byte((uint8_t*)(uint16_t)eeprom_write_offset, evt->params.cmd_rsp.params.padding[i]);
    eeprom_write_offset++;
  }
}
     880:	df 91       	pop	r29
     882:	cf 91       	pop	r28
     884:	1f 91       	pop	r17
     886:	08 95       	ret

00000888 <bond_data_read_store>:

bool bond_data_read_store(aci_state_t *aci_stat)
{
     888:	1f 93       	push	r17
     88a:	cf 93       	push	r28
     88c:	df 93       	push	r29
     88e:	ec 01       	movw	r28, r24
  bool status = false;
  aci_evt_t * aci_evt = NULL;
  uint8_t read_dyn_num_msgs = 0;

  //Start reading the dynamic data
  lib_aci_read_dynamic_data();
     890:	0e 94 d0 0c 	call	0x19a0	; 0x19a0 <lib_aci_read_dynamic_data>
  read_dyn_num_msgs++;
     894:	11 e0       	ldi	r17, 0x01	; 1

  while (1)
  {
    if (true == lib_aci_event_get(aci_stat, &aci_data))
     896:	63 ed       	ldi	r22, 0xD3	; 211
     898:	78 e0       	ldi	r23, 0x08	; 8
     89a:	ce 01       	movw	r24, r28
     89c:	82 d7       	rcall	.+3844   	; 0x17a2 <lib_aci_event_get>
     89e:	88 23       	and	r24, r24
     8a0:	d1 f3       	breq	.-12     	; 0x896 <bond_data_read_store+0xe>
    {
      aci_evt = &aci_data.evt;

      if (ACI_EVT_CMD_RSP != aci_evt->evt_opcode )
     8a2:	80 91 d5 08 	lds	r24, 0x08D5	; 0x8008d5 <aci_data+0x2>
     8a6:	84 38       	cpi	r24, 0x84	; 132
     8a8:	f9 f4       	brne	.+62     	; 0x8e8 <bond_data_read_store+0x60>
        //Got something other than a command response evt -> Error
        status = false;
        break;
      }

      if (ACI_STATUS_TRANSACTION_COMPLETE == aci_evt->params.cmd_rsp.cmd_status)
     8aa:	80 91 d7 08 	lds	r24, 0x08D7	; 0x8008d7 <aci_data+0x4>
     8ae:	82 30       	cpi	r24, 0x02	; 2
     8b0:	59 f4       	brne	.+22     	; 0x8c8 <bond_data_read_store+0x40>
      {
        //Store the contents of the command response event in the EEPROM
        //(len, cmd, seq-no, data) : cmd ->Write Dynamic Data so it can be used directly
        bond_data_store(aci_evt);
     8b2:	84 ed       	ldi	r24, 0xD4	; 212
     8b4:	98 e0       	ldi	r25, 0x08	; 8
     8b6:	9e df       	rcall	.-196    	; 0x7f4 <bond_data_store>

        //Set the flag in the EEPROM that the contents of the EEPROM is valid
        eeprom_update_byte(0, 0x80|read_dyn_num_msgs );
     8b8:	61 2f       	mov	r22, r17
     8ba:	60 68       	ori	r22, 0x80	; 128
     8bc:	80 e0       	ldi	r24, 0x00	; 0
     8be:	90 e0       	ldi	r25, 0x00	; 0
     8c0:	0e 94 9b 13 	call	0x2736	; 0x2736 <eeprom_update_byte>
        //Finished with reading the dynamic data
        status = true;
     8c4:	81 e0       	ldi	r24, 0x01	; 1

        break;
     8c6:	11 c0       	rjmp	.+34     	; 0x8ea <bond_data_read_store+0x62>
      }

      if (!(ACI_STATUS_TRANSACTION_CONTINUE == aci_evt->params.cmd_rsp.cmd_status))
     8c8:	81 30       	cpi	r24, 0x01	; 1
     8ca:	39 f0       	breq	.+14     	; 0x8da <bond_data_read_store+0x52>
      {
        //We failed the read dymanic data
        //Set the flag in the EEPROM that the contents of the EEPROM is invalid
        eeprom_update_byte(0, 0x00);
     8cc:	60 e0       	ldi	r22, 0x00	; 0
     8ce:	80 e0       	ldi	r24, 0x00	; 0
     8d0:	90 e0       	ldi	r25, 0x00	; 0
     8d2:	0e 94 9b 13 	call	0x2736	; 0x2736 <eeprom_update_byte>

        status = false;
     8d6:	80 e0       	ldi	r24, 0x00	; 0
        break;
     8d8:	08 c0       	rjmp	.+16     	; 0x8ea <bond_data_read_store+0x62>
      }
      else
      {
        //Store the contents of the command response event in the EEPROM
        // (len, cmd, seq-no, data) : cmd ->Write Dynamic Data so it can be used directly when re-storing the dynamic data
        bond_data_store(aci_evt);
     8da:	84 ed       	ldi	r24, 0xD4	; 212
     8dc:	98 e0       	ldi	r25, 0x08	; 8
     8de:	8a df       	rcall	.-236    	; 0x7f4 <bond_data_store>

        //Read the next dynamic data message
        lib_aci_read_dynamic_data();
     8e0:	0e 94 d0 0c 	call	0x19a0	; 0x19a0 <lib_aci_read_dynamic_data>
        read_dyn_num_msgs++;
     8e4:	1f 5f       	subi	r17, 0xFF	; 255
     8e6:	d7 cf       	rjmp	.-82     	; 0x896 <bond_data_read_store+0xe>
      aci_evt = &aci_data.evt;

      if (ACI_EVT_CMD_RSP != aci_evt->evt_opcode )
      {
        //Got something other than a command response evt -> Error
        status = false;
     8e8:	80 e0       	ldi	r24, 0x00	; 0
      }

    }
  }
  return status;
}
     8ea:	df 91       	pop	r29
     8ec:	cf 91       	pop	r28
     8ee:	1f 91       	pop	r17
     8f0:	08 95       	ret

000008f2 <aci_loop>:

//Process all ACI events here
void aci_loop()
{
     8f2:	ef 92       	push	r14
     8f4:	ff 92       	push	r15
     8f6:	0f 93       	push	r16
     8f8:	1f 93       	push	r17
     8fa:	cf 93       	push	r28
     8fc:	df 93       	push	r29
  static bool setup_required = false;

  // We enter the if statement only when there is a ACI event available to be processed
  if (lib_aci_event_get(&aci_state, &aci_data)) //bookmark1
     8fe:	63 ed       	ldi	r22, 0xD3	; 211
     900:	78 e0       	ldi	r23, 0x08	; 8
     902:	85 ef       	ldi	r24, 0xF5	; 245
     904:	98 e0       	ldi	r25, 0x08	; 8
     906:	4d d7       	rcall	.+3738   	; 0x17a2 <lib_aci_event_get>
     908:	88 23       	and	r24, r24
     90a:	09 f4       	brne	.+2      	; 0x90e <aci_loop+0x1c>
     90c:	0a c2       	rjmp	.+1044   	; 0xd22 <__stack+0x223>
  {
    
	aci_evt_t * aci_evt;
    aci_evt = &aci_data.evt;

    switch(aci_evt->evt_opcode)
     90e:	80 91 d5 08 	lds	r24, 0x08D5	; 0x8008d5 <aci_data+0x2>
     912:	87 38       	cpi	r24, 0x87	; 135
     914:	09 f4       	brne	.+2      	; 0x918 <aci_loop+0x26>
     916:	2b c1       	rjmp	.+598    	; 0xb6e <__stack+0x6f>
     918:	90 f4       	brcc	.+36     	; 0x93e <aci_loop+0x4c>
     91a:	83 38       	cpi	r24, 0x83	; 131
     91c:	09 f4       	brne	.+2      	; 0x920 <aci_loop+0x2e>
     91e:	91 c1       	rjmp	.+802    	; 0xc42 <__stack+0x143>
     920:	40 f4       	brcc	.+16     	; 0x932 <aci_loop+0x40>
     922:	81 38       	cpi	r24, 0x81	; 129
     924:	11 f1       	breq	.+68     	; 0x96a <aci_loop+0x78>
     926:	08 f0       	brcs	.+2      	; 0x92a <aci_loop+0x38>
     928:	ec c1       	rjmp	.+984    	; 0xd02 <__stack+0x203>
     92a:	88 23       	and	r24, r24
     92c:	09 f4       	brne	.+2      	; 0x930 <aci_loop+0x3e>
     92e:	e5 c1       	rjmp	.+970    	; 0xcfa <__stack+0x1fb>
     930:	fb c1       	rjmp	.+1014   	; 0xd28 <__stack+0x229>
     932:	85 38       	cpi	r24, 0x85	; 133
     934:	09 f4       	brne	.+2      	; 0x938 <aci_loop+0x46>
     936:	b3 c0       	rjmp	.+358    	; 0xa9e <aci_loop+0x1ac>
     938:	08 f4       	brcc	.+2      	; 0x93c <aci_loop+0x4a>
     93a:	8c c0       	rjmp	.+280    	; 0xa54 <aci_loop+0x162>
     93c:	20 c1       	rjmp	.+576    	; 0xb7e <__stack+0x7f>
     93e:	8b 38       	cpi	r24, 0x8B	; 139
     940:	09 f4       	brne	.+2      	; 0x944 <aci_loop+0x52>
     942:	e3 c1       	rjmp	.+966    	; 0xd0a <__stack+0x20b>
     944:	30 f4       	brcc	.+12     	; 0x952 <aci_loop+0x60>
     946:	89 38       	cpi	r24, 0x89	; 137
     948:	09 f4       	brne	.+2      	; 0x94c <aci_loop+0x5a>
     94a:	c5 c0       	rjmp	.+394    	; 0xad6 <aci_loop+0x1e4>
     94c:	08 f4       	brcc	.+2      	; 0x950 <aci_loop+0x5e>
     94e:	b0 c0       	rjmp	.+352    	; 0xab0 <aci_loop+0x1be>
     950:	ee c0       	rjmp	.+476    	; 0xb2e <__stack+0x2f>
     952:	8d 38       	cpi	r24, 0x8D	; 141
     954:	09 f4       	brne	.+2      	; 0x958 <aci_loop+0x66>
     956:	f3 c0       	rjmp	.+486    	; 0xb3e <__stack+0x3f>
     958:	08 f4       	brcc	.+2      	; 0x95c <aci_loop+0x6a>
     95a:	44 c1       	rjmp	.+648    	; 0xbe4 <__stack+0xe5>
     95c:	8e 38       	cpi	r24, 0x8E	; 142
     95e:	09 f4       	brne	.+2      	; 0x962 <aci_loop+0x70>
     960:	d8 c1       	rjmp	.+944    	; 0xd12 <__stack+0x213>
     962:	8f 38       	cpi	r24, 0x8F	; 143
     964:	09 f4       	brne	.+2      	; 0x968 <aci_loop+0x76>
     966:	d9 c1       	rjmp	.+946    	; 0xd1a <__stack+0x21b>
     968:	df c1       	rjmp	.+958    	; 0xd28 <__stack+0x229>
    {	  
	  case ACI_EVT_DEVICE_STARTED:
      {
        aci_state.data_credit_total = aci_evt->params.device_started.credit_available;
     96a:	e3 ed       	ldi	r30, 0xD3	; 211
     96c:	f8 e0       	ldi	r31, 0x08	; 8
     96e:	85 81       	ldd	r24, Z+5	; 0x05
     970:	80 93 08 09 	sts	0x0908, r24	; 0x800908 <aci_state+0x13>
        switch(aci_evt->params.device_started.device_mode)
     974:	83 81       	ldd	r24, Z+3	; 0x03
     976:	82 30       	cpi	r24, 0x02	; 2
     978:	b9 f0       	breq	.+46     	; 0x9a8 <aci_loop+0xb6>
     97a:	28 f4       	brcc	.+10     	; 0x986 <aci_loop+0x94>
     97c:	88 23       	and	r24, r24
     97e:	41 f0       	breq	.+16     	; 0x990 <aci_loop+0x9e>
     980:	81 30       	cpi	r24, 0x01	; 1
     982:	51 f0       	breq	.+20     	; 0x998 <aci_loop+0xa6>
     984:	d1 c1       	rjmp	.+930    	; 0xd28 <__stack+0x229>
     986:	83 30       	cpi	r24, 0x03	; 3
     988:	c9 f0       	breq	.+50     	; 0x9bc <aci_loop+0xca>
     98a:	84 30       	cpi	r24, 0x04	; 4
     98c:	49 f0       	breq	.+18     	; 0x9a0 <aci_loop+0xae>
     98e:	cc c1       	rjmp	.+920    	; 0xd28 <__stack+0x229>
        {
		  case ACI_DEVICE_INVALID:
			//Added AHJ not handled before
            Serial_SendString("ACI Event Device Invalid!\r\n");
     990:	83 e8       	ldi	r24, 0x83	; 131
     992:	91 e0       	ldi	r25, 0x01	; 1
     994:	a3 de       	rcall	.-698    	; 0x6dc <Serial_SendString>
            break;
		 		 
		  case ACI_DEVICE_TEST:
		 		//Added AHJ not handled before
		 		Serial_SendString("ACI Device Test!\r\n");
     996:	c8 c1       	rjmp	.+912    	; 0xd28 <__stack+0x229>
     998:	8f e9       	ldi	r24, 0x9F	; 159
		 		break;	

		  case ACI_DEVICE_SLEEP:
				//Added AHJ not handled before
				Serial_SendString("ACI Device Sleep!\r\n");
     99a:	91 e0       	ldi	r25, 0x01	; 1
     99c:	9f de       	rcall	.-706    	; 0x6dc <Serial_SendString>
     99e:	c4 c1       	rjmp	.+904    	; 0xd28 <__stack+0x229>
     9a0:	82 eb       	ldi	r24, 0xB2	; 178
				break;
     9a2:	91 e0       	ldi	r25, 0x01	; 1
		  				   
          case ACI_DEVICE_SETUP:
            /**
            When the device is in the setup mode
            */
            aci_state.device_state = ACI_DEVICE_SETUP;
     9a4:	9b de       	rcall	.-714    	; 0x6dc <Serial_SendString>
     9a6:	c0 c1       	rjmp	.+896    	; 0xd28 <__stack+0x229>
            Serial_SendString("Evt Device Started: Setup\r\n");
     9a8:	82 e0       	ldi	r24, 0x02	; 2
     9aa:	80 93 09 09 	sts	0x0909, r24	; 0x800909 <aci_state+0x14>
     9ae:	86 ec       	ldi	r24, 0xC6	; 198
            setup_required = true;
     9b0:	91 e0       	ldi	r25, 0x01	; 1
     9b2:	94 de       	rcall	.-728    	; 0x6dc <Serial_SendString>
     9b4:	81 e0       	ldi	r24, 0x01	; 1
            break;

          case ACI_DEVICE_STANDBY:
            Serial_SendString("Evt Device Started: Standby\r\n");
     9b6:	80 93 b0 08 	sts	0x08B0, r24	; 0x8008b0 <__data_end>
     9ba:	ba c1       	rjmp	.+884    	; 0xd30 <__stack+0x231>
     9bc:	82 ee       	ldi	r24, 0xE2	; 226
            if (aci_evt->params.device_started.hw_error)
     9be:	91 e0       	ldi	r25, 0x01	; 1
     9c0:	8d de       	rcall	.-742    	; 0x6dc <Serial_SendString>
     9c2:	80 91 d7 08 	lds	r24, 0x08D7	; 0x8008d7 <aci_data+0x4>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     9c6:	88 23       	and	r24, r24
     9c8:	51 f0       	breq	.+20     	; 0x9de <aci_loop+0xec>
     9ca:	2f ef       	ldi	r18, 0xFF	; 255
     9cc:	89 ef       	ldi	r24, 0xF9	; 249
     9ce:	90 e0       	ldi	r25, 0x00	; 0
     9d0:	21 50       	subi	r18, 0x01	; 1
     9d2:	80 40       	sbci	r24, 0x00	; 0
     9d4:	90 40       	sbci	r25, 0x00	; 0
     9d6:	e1 f7       	brne	.-8      	; 0x9d0 <aci_loop+0xde>
     9d8:	00 c0       	rjmp	.+0      	; 0x9da <aci_loop+0xe8>
            else
            {
              //Manage the bond in EEPROM of the AVR
              {
                uint8_t eeprom_status = 0;
                eeprom_status = eeprom_read_byte(0);
     9da:	00 00       	nop
     9dc:	a5 c1       	rjmp	.+842    	; 0xd28 <__stack+0x229>
     9de:	80 e0       	ldi	r24, 0x00	; 0
     9e0:	90 e0       	ldi	r25, 0x00	; 0
                if (eeprom_status != 0x00)
     9e2:	0e 94 93 13 	call	0x2726	; 0x2726 <eeprom_read_byte>
                {
                  Serial_SendString("Previous Bond present. Restoring\r\n");
     9e6:	c8 2f       	mov	r28, r24
     9e8:	88 23       	and	r24, r24
                  Serial_SendString("Using existing bond stored in EEPROM.\r\n");
     9ea:	d9 f0       	breq	.+54     	; 0xa22 <aci_loop+0x130>
     9ec:	80 e0       	ldi	r24, 0x00	; 0
     9ee:	92 e0       	ldi	r25, 0x02	; 2
                  Serial_SendString("   To delete the bond stored in EEPROM, connect Pin 6 to 3.3v and Reset.\r\n");
     9f0:	75 de       	rcall	.-790    	; 0x6dc <Serial_SendString>
     9f2:	83 e2       	ldi	r24, 0x23	; 35
     9f4:	92 e0       	ldi	r25, 0x02	; 2
                  Serial_SendString("   Make sure that the bond on the phone/PC is deleted as well.\r\n");
     9f6:	72 de       	rcall	.-796    	; 0x6dc <Serial_SendString>
     9f8:	8b e4       	ldi	r24, 0x4B	; 75
     9fa:	92 e0       	ldi	r25, 0x02	; 2
                  //We must have lost power and restarted and must restore the bonding information using the ACI Write Dynamic Data
                  if (ACI_STATUS_TRANSACTION_COMPLETE == bond_data_restore(&aci_state, eeprom_status, &bonded_first_time))
     9fc:	6f de       	rcall	.-802    	; 0x6dc <Serial_SendString>
     9fe:	86 e9       	ldi	r24, 0x96	; 150
     a00:	92 e0       	ldi	r25, 0x02	; 2
     a02:	6c de       	rcall	.-808    	; 0x6dc <Serial_SendString>
     a04:	42 e0       	ldi	r20, 0x02	; 2
     a06:	51 e0       	ldi	r21, 0x01	; 1
     a08:	6c 2f       	mov	r22, r28
                  {
                    Serial_SendString("Bond restored successfully\r\n");
     a0a:	85 ef       	ldi	r24, 0xF5	; 245
     a0c:	98 e0       	ldi	r25, 0x08	; 8
     a0e:	8c de       	rcall	.-744    	; 0x728 <bond_data_restore>
     a10:	82 30       	cpi	r24, 0x02	; 2
                  }
                  else
                  {
                    Serial_SendString("Bond restore failed. Delete the bond and try again.\r\n");
     a12:	21 f4       	brne	.+8      	; 0xa1c <aci_loop+0x12a>
     a14:	87 ed       	ldi	r24, 0xD7	; 215
     a16:	92 e0       	ldi	r25, 0x02	; 2
                  }
                }
              }

              // Start bonding as all proximity devices need to be bonded to be usable
              if (ACI_BOND_STATUS_SUCCESS != aci_state.bonded)
     a18:	61 de       	rcall	.-830    	; 0x6dc <Serial_SendString>
     a1a:	03 c0       	rjmp	.+6      	; 0xa22 <aci_loop+0x130>
     a1c:	84 ef       	ldi	r24, 0xF4	; 244
              {
                lib_aci_bond(180/* in seconds */, 0x0050 /* advertising interval 50ms*/);
     a1e:	92 e0       	ldi	r25, 0x02	; 2
     a20:	5d de       	rcall	.-838    	; 0x6dc <Serial_SendString>
     a22:	80 91 07 09 	lds	r24, 0x0907	; 0x800907 <aci_state+0x12>
                Serial_SendString("No Bond present in EEPROM.\r\n");
     a26:	88 23       	and	r24, r24
     a28:	61 f0       	breq	.+24     	; 0xa42 <aci_loop+0x150>
     a2a:	60 e5       	ldi	r22, 0x50	; 80
                Serial_SendString("Advertising started : Waiting to be connected and bonded\r\n");
     a2c:	70 e0       	ldi	r23, 0x00	; 0
     a2e:	84 eb       	ldi	r24, 0xB4	; 180
     a30:	90 e0       	ldi	r25, 0x00	; 0
     a32:	53 d6       	rcall	.+3238   	; 0x16da <lib_aci_bond>
     a34:	8a e2       	ldi	r24, 0x2A	; 42
              }
              else
              {
                //connect to an already bonded device
                //Use lib_aci_direct_connect for faster re-connections with PC, not recommended to use with iOS/OS X
                lib_aci_connect(100/* in seconds */, 0x0020 /* advertising interval 20ms*/);
     a36:	93 e0       	ldi	r25, 0x03	; 3
     a38:	51 de       	rcall	.-862    	; 0x6dc <Serial_SendString>
     a3a:	87 e4       	ldi	r24, 0x47	; 71
     a3c:	93 e0       	ldi	r25, 0x03	; 3
     a3e:	4e de       	rcall	.-868    	; 0x6dc <Serial_SendString>
                Serial_SendString("Already bonded : Advertising started : Waiting to be connected\r\n");
     a40:	73 c1       	rjmp	.+742    	; 0xd28 <__stack+0x229>
     a42:	60 e2       	ldi	r22, 0x20	; 32
     a44:	70 e0       	ldi	r23, 0x00	; 0
     a46:	84 e6       	ldi	r24, 0x64	; 100
      }
        break; //ACI Device Started Event

      case ACI_EVT_CMD_RSP:
        //If an ACI command response event comes with an error -> stop
        if ((ACI_STATUS_SUCCESS != aci_evt->params.cmd_rsp.cmd_status )
     a48:	90 e0       	ldi	r25, 0x00	; 0
     a4a:	09 d6       	rcall	.+3090   	; 0x165e <lib_aci_connect>
     a4c:	82 e8       	ldi	r24, 0x82	; 130
            && (ACI_CMD_READ_DYNAMIC_DATA  != aci_evt->params.cmd_rsp.cmd_opcode)
     a4e:	93 e0       	ldi	r25, 0x03	; 3
     a50:	45 de       	rcall	.-886    	; 0x6dc <Serial_SendString>
     a52:	6a c1       	rjmp	.+724    	; 0xd28 <__stack+0x229>
     a54:	80 91 d7 08 	lds	r24, 0x08D7	; 0x8008d7 <aci_data+0x4>
        {
          //ACI ReadDynamicData and ACI WriteDynamicData will have status codes of
          //TRANSACTION_CONTINUE and TRANSACTION_COMPLETE
          //all other ACI commands will have status code of ACI_STATUS_SCUCCESS for a successful command

          Serial_SendString("ACI Command \r\n");
     a58:	88 23       	and	r24, r24
     a5a:	a1 f0       	breq	.+40     	; 0xa84 <aci_loop+0x192>
     a5c:	80 91 d6 08 	lds	r24, 0x08D6	; 0x8008d6 <aci_data+0x3>
          Serial_SendString((char*) aci_evt->params.cmd_rsp.cmd_opcode); //, HEX);
     a60:	87 50       	subi	r24, 0x07	; 7
     a62:	82 30       	cpi	r24, 0x02	; 2
     a64:	08 f4       	brcc	.+2      	; 0xa68 <aci_loop+0x176>
     a66:	60 c1       	rjmp	.+704    	; 0xd28 <__stack+0x229>
     a68:	83 ec       	ldi	r24, 0xC3	; 195
          Serial_SendString("Evt Cmd respone: Status \r\n");
     a6a:	93 e0       	ldi	r25, 0x03	; 3
     a6c:	37 de       	rcall	.-914    	; 0x6dc <Serial_SendString>
     a6e:	c3 ed       	ldi	r28, 0xD3	; 211
     a70:	d8 e0       	ldi	r29, 0x08	; 8
          Serial_SendString((char*) aci_evt->params.cmd_rsp.cmd_status); //, HEX);
     a72:	8b 81       	ldd	r24, Y+3	; 0x03
     a74:	90 e0       	ldi	r25, 0x00	; 0
        }
        if (ACI_CMD_GET_DEVICE_VERSION == aci_evt->params.cmd_rsp.cmd_opcode)
     a76:	32 de       	rcall	.-924    	; 0x6dc <Serial_SendString>
     a78:	82 ed       	ldi	r24, 0xD2	; 210
     a7a:	93 e0       	ldi	r25, 0x03	; 3
     a7c:	2f de       	rcall	.-930    	; 0x6dc <Serial_SendString>
        {
          //Store the version and configuration information of the nRF8001 in the Hardware Revision String Characteristic
          lib_aci_set_local_data(&aci_state, PIPE_DEVICE_INFORMATION_HARDWARE_REVISION_STRING_SET,
     a7e:	8c 81       	ldd	r24, Y+4	; 0x04
     a80:	90 e0       	ldi	r25, 0x00	; 0
     a82:	2c de       	rcall	.-936    	; 0x6dc <Serial_SendString>
     a84:	80 91 d6 08 	lds	r24, 0x08D6	; 0x8008d6 <aci_data+0x3>
     a88:	89 30       	cpi	r24, 0x09	; 9
     a8a:	09 f0       	breq	.+2      	; 0xa8e <aci_loop+0x19c>

      case ACI_EVT_CONNECTED:
        /*
        reset the credit available when the link gets connected
        */
        aci_state.data_credit_available = aci_state.data_credit_total;
     a8c:	4d c1       	rjmp	.+666    	; 0xd28 <__stack+0x229>
     a8e:	29 e0       	ldi	r18, 0x09	; 9
     a90:	48 ed       	ldi	r20, 0xD8	; 216
        Serial_SendString("Evt Connected\r\n");
     a92:	58 e0       	ldi	r21, 0x08	; 8
     a94:	6c e0       	ldi	r22, 0x0C	; 12
     a96:	85 ef       	ldi	r24, 0xF5	; 245
        /*
         Get the Device Version of the nRF8001 and place it in the
         Hardware Revision String Characteristic of the Device Info. GATT Service
         */
        lib_aci_device_version();
     a98:	98 e0       	ldi	r25, 0x08	; 8
     a9a:	a1 d5       	rcall	.+2882   	; 0x15de <lib_aci_set_local_data>
        break;
     a9c:	45 c1       	rjmp	.+650    	; 0xd28 <__stack+0x229>

      case ACI_EVT_PIPE_STATUS:
        Serial_SendString("Evt Pipe Status\r\n");
     a9e:	e5 ef       	ldi	r30, 0xF5	; 245
     aa0:	f8 e0       	ldi	r31, 0x08	; 8
     aa2:	83 89       	ldd	r24, Z+19	; 0x13
        if (lib_aci_is_pipe_available(&aci_state, PIPE_HID_SERVICE_HID_REPORT_ID1_TX)
     aa4:	85 8b       	std	Z+21, r24	; 0x15
     aa6:	8d ee       	ldi	r24, 0xED	; 237
     aa8:	93 e0       	ldi	r25, 0x03	; 3
     aaa:	18 de       	rcall	.-976    	; 0x6dc <Serial_SendString>
     aac:	91 d5       	rcall	.+2850   	; 0x15d0 <lib_aci_device_version>
     aae:	3c c1       	rjmp	.+632    	; 0xd28 <__stack+0x229>
     ab0:	8d ef       	ldi	r24, 0xFD	; 253
     ab2:	93 e0       	ldi	r25, 0x03	; 3
            && (false == timing_change_done))
     ab4:	13 de       	rcall	.-986    	; 0x6dc <Serial_SendString>
     ab6:	66 e0       	ldi	r22, 0x06	; 6
     ab8:	85 ef       	ldi	r24, 0xF5	; 245
     aba:	98 e0       	ldi	r25, 0x08	; 8
        {
          lib_aci_change_timing_GAP_PPCP(); //Uses the GAP preferred timing as put in the nRFGo studio xml file-> See also in services.h
     abc:	6a d5       	rcall	.+2772   	; 0x1592 <lib_aci_is_pipe_available>
     abe:	88 23       	and	r24, r24
          timing_change_done = true;
     ac0:	09 f4       	brne	.+2      	; 0xac4 <aci_loop+0x1d2>
     ac2:	32 c1       	rjmp	.+612    	; 0xd28 <__stack+0x229>
     ac4:	80 91 b1 08 	lds	r24, 0x08B1	; 0x8008b1 <timing_change_done>
        }
        break;

      case ACI_EVT_TIMING:
        Serial_SendString("Timing change received conn Interval: 0x");
     ac8:	81 11       	cpse	r24, r1
     aca:	2e c1       	rjmp	.+604    	; 0xd28 <__stack+0x229>
        Serial_SendString((char*) aci_evt->params.timing.conn_rf_interval); //, HEX);
     acc:	61 d6       	rcall	.+3266   	; 0x1790 <lib_aci_change_timing_GAP_PPCP>
     ace:	81 e0       	ldi	r24, 0x01	; 1
     ad0:	80 93 b1 08 	sts	0x08B1, r24	; 0x8008b1 <timing_change_done>
     ad4:	29 c1       	rjmp	.+594    	; 0xd28 <__stack+0x229>
        //Disconnect as soon as we are bonded and required pipes are available
        //This is used to store the bonding info on disconnect and then re-connect to verify the bond
        if((ACI_BOND_STATUS_SUCCESS == aci_state.bonded) &&
     ad6:	8f e0       	ldi	r24, 0x0F	; 15
     ad8:	94 e0       	ldi	r25, 0x04	; 4
     ada:	00 de       	rcall	.-1024   	; 0x6dc <Serial_SendString>
     adc:	80 91 d6 08 	lds	r24, 0x08D6	; 0x8008d6 <aci_data+0x3>
     ae0:	90 91 d7 08 	lds	r25, 0x08D7	; 0x8008d7 <aci_data+0x4>
           (true == bonded_first_time) &&
           (GAP_PPCP_MAX_CONN_INT >= aci_state.connection_interval) &&
     ae4:	fb dd       	rcall	.-1034   	; 0x6dc <Serial_SendString>
     ae6:	80 91 07 09 	lds	r24, 0x0907	; 0x800907 <aci_state+0x12>
     aea:	81 11       	cpse	r24, r1
     aec:	1d c1       	rjmp	.+570    	; 0xd28 <__stack+0x229>
     aee:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <bonded_first_time>
           (GAP_PPCP_MIN_CONN_INT <= aci_state.connection_interval) && //Timing change already done: Provide time for the the peer to finish
           (lib_aci_is_pipe_available(&aci_state, PIPE_HID_SERVICE_HID_REPORT_ID1_TX) &&
     af2:	88 23       	and	r24, r24
     af4:	09 f4       	brne	.+2      	; 0xaf8 <aci_loop+0x206>
     af6:	18 c1       	rjmp	.+560    	; 0xd28 <__stack+0x229>
     af8:	80 91 0b 09 	lds	r24, 0x090B	; 0x80090b <aci_state+0x16>
        //Disconnect as soon as we are bonded and required pipes are available
        //This is used to store the bonding info on disconnect and then re-connect to verify the bond
        if((ACI_BOND_STATUS_SUCCESS == aci_state.bonded) &&
           (true == bonded_first_time) &&
           (GAP_PPCP_MAX_CONN_INT >= aci_state.connection_interval) &&
           (GAP_PPCP_MIN_CONN_INT <= aci_state.connection_interval) && //Timing change already done: Provide time for the the peer to finish
     afc:	90 91 0c 09 	lds	r25, 0x090C	; 0x80090c <aci_state+0x17>
           (lib_aci_is_pipe_available(&aci_state, PIPE_HID_SERVICE_HID_REPORT_ID1_TX) &&
           (lib_aci_is_pipe_available(&aci_state, PIPE_HID_SERVICE_HID_REPORT_ID2_TX))))
     b00:	06 97       	sbiw	r24, 0x06	; 6
     b02:	43 97       	sbiw	r24, 0x13	; 19
     b04:	08 f0       	brcs	.+2      	; 0xb08 <__stack+0x9>
        //This is used to store the bonding info on disconnect and then re-connect to verify the bond
        if((ACI_BOND_STATUS_SUCCESS == aci_state.bonded) &&
           (true == bonded_first_time) &&
           (GAP_PPCP_MAX_CONN_INT >= aci_state.connection_interval) &&
           (GAP_PPCP_MIN_CONN_INT <= aci_state.connection_interval) && //Timing change already done: Provide time for the the peer to finish
           (lib_aci_is_pipe_available(&aci_state, PIPE_HID_SERVICE_HID_REPORT_ID1_TX) &&
     b06:	10 c1       	rjmp	.+544    	; 0xd28 <__stack+0x229>
     b08:	66 e0       	ldi	r22, 0x06	; 6
     b0a:	85 ef       	ldi	r24, 0xF5	; 245
           (lib_aci_is_pipe_available(&aci_state, PIPE_HID_SERVICE_HID_REPORT_ID2_TX))))
           {
             lib_aci_disconnect(&aci_state, ACI_REASON_TERMINATE);
     b0c:	98 e0       	ldi	r25, 0x08	; 8
     b0e:	41 d5       	rcall	.+2690   	; 0x1592 <lib_aci_is_pipe_available>
     b10:	88 23       	and	r24, r24
     b12:	09 f4       	brne	.+2      	; 0xb16 <__stack+0x17>
     b14:	09 c1       	rjmp	.+530    	; 0xd28 <__stack+0x229>
     b16:	68 e0       	ldi	r22, 0x08	; 8
      case ACI_EVT_DATA_CREDIT:
        /**
        Bluetooth Radio ack received from the peer radio for the data packet sent.
        Multiple data packets can be acked in a single aci data credit event.
        */
        aci_state.data_credit_available = aci_state.data_credit_available + aci_evt->params.data_credit.credit;
     b18:	85 ef       	ldi	r24, 0xF5	; 245
     b1a:	98 e0       	ldi	r25, 0x08	; 8
     b1c:	3a d5       	rcall	.+2676   	; 0x1592 <lib_aci_is_pipe_available>
     b1e:	88 23       	and	r24, r24
     b20:	09 f4       	brne	.+2      	; 0xb24 <__stack+0x25>
     b22:	02 c1       	rjmp	.+516    	; 0xd28 <__stack+0x229>
        break;
     b24:	61 e0       	ldi	r22, 0x01	; 1

      case ACI_EVT_PIPE_ERROR:
        //See the appendix in the nRF8001 Product Specification for details on the error codes
        Serial_SendString("ACI Evt Pipe Error: Pipe #:");
     b26:	85 ef       	ldi	r24, 0xF5	; 245
     b28:	98 e0       	ldi	r25, 0x08	; 8
     b2a:	b3 d5       	rcall	.+2918   	; 0x1692 <lib_aci_disconnect>
     b2c:	fd c0       	rjmp	.+506    	; 0xd28 <__stack+0x229>
        Serial_SendString((char*) aci_evt->params.pipe_error.pipe_number); //, DEC);
     b2e:	e5 ef       	ldi	r30, 0xF5	; 245
     b30:	f8 e0       	ldi	r31, 0x08	; 8
     b32:	95 89       	ldd	r25, Z+21	; 0x15
        Serial_SendString("  Pipe Error Code: 0x");
     b34:	80 91 d6 08 	lds	r24, 0x08D6	; 0x8008d6 <aci_data+0x3>
     b38:	89 0f       	add	r24, r25
     b3a:	85 8b       	std	Z+21, r24	; 0x15
        Serial_SendString((char*) aci_evt->params.pipe_error.error_code); //, HEX);
     b3c:	f5 c0       	rjmp	.+490    	; 0xd28 <__stack+0x229>
     b3e:	88 e3       	ldi	r24, 0x38	; 56
     b40:	94 e0       	ldi	r25, 0x04	; 4
     b42:	cc dd       	rcall	.-1128   	; 0x6dc <Serial_SendString>

        //Increment the credit available as the data packet was not sent.
        //The pipe error also represents the Attribute protocol Error Response sent from the peer and that should not be counted
        //for the credit.
        if (ACI_STATUS_ERROR_PEER_ATT_ERROR != aci_evt->params.pipe_error.error_code)
     b44:	c3 ed       	ldi	r28, 0xD3	; 211
     b46:	d8 e0       	ldi	r29, 0x08	; 8
     b48:	8b 81       	ldd	r24, Y+3	; 0x03
        {
          aci_state.data_credit_available++;
     b4a:	90 e0       	ldi	r25, 0x00	; 0
     b4c:	c7 dd       	rcall	.-1138   	; 0x6dc <Serial_SendString>
     b4e:	84 e5       	ldi	r24, 0x54	; 84
     b50:	94 e0       	ldi	r25, 0x04	; 4
        }
        break;

      case ACI_EVT_BOND_STATUS:
        Serial_SendString("Evt Bond Status\r\n");
     b52:	c4 dd       	rcall	.-1144   	; 0x6dc <Serial_SendString>
     b54:	8c 81       	ldd	r24, Y+4	; 0x04
     b56:	90 e0       	ldi	r25, 0x00	; 0
     b58:	c1 dd       	rcall	.-1150   	; 0x6dc <Serial_SendString>
        aci_state.bonded = aci_evt->params.bond_status.status_code;
     b5a:	8c 81       	ldd	r24, Y+4	; 0x04
     b5c:	82 39       	cpi	r24, 0x92	; 146
     b5e:	09 f4       	brne	.+2      	; 0xb62 <__stack+0x63>
        break;
     b60:	e3 c0       	rjmp	.+454    	; 0xd28 <__stack+0x229>

      case ACI_EVT_DISCONNECTED:
        /**
        Advertise again if the advertising timed out.
        */
        if(ACI_STATUS_ERROR_ADVT_TIMEOUT == aci_evt->params.disconnected.aci_status)
     b62:	e5 ef       	ldi	r30, 0xF5	; 245
     b64:	f8 e0       	ldi	r31, 0x08	; 8
     b66:	85 89       	ldd	r24, Z+21	; 0x15
        {
          Serial_SendString("Evt Disconnected -> Advertising timed out\r\n");
     b68:	8f 5f       	subi	r24, 0xFF	; 255
     b6a:	85 8b       	std	Z+21, r24	; 0x15
     b6c:	dd c0       	rjmp	.+442    	; 0xd28 <__stack+0x229>
          {
            Serial_SendString("nRF8001 going to sleep\r\n");
     b6e:	8a e6       	ldi	r24, 0x6A	; 106
     b70:	94 e0       	ldi	r25, 0x04	; 4
            lib_aci_sleep();
     b72:	b4 dd       	rcall	.-1176   	; 0x6dc <Serial_SendString>
     b74:	80 91 d6 08 	lds	r24, 0x08D6	; 0x8008d6 <aci_data+0x3>
            aci_state.device_state = ACI_DEVICE_SLEEP;
     b78:	80 93 07 09 	sts	0x0907, r24	; 0x800907 <aci_state+0x12>
            // Use lib_aci_device_wakeup() to wakeup the nRF8001
          }
        }
        else
        {
          if (ACI_BOND_STATUS_SUCCESS != aci_state.bonded)
     b7c:	d5 c0       	rjmp	.+426    	; 0xd28 <__stack+0x229>
     b7e:	80 91 d6 08 	lds	r24, 0x08D6	; 0x8008d6 <aci_data+0x3>
          {
            // Previous bonding failed. Try to bond again.
            lib_aci_bond(180/* in seconds */, 0x0050 /* advertising interval 50ms*/);
     b82:	83 39       	cpi	r24, 0x93	; 147
     b84:	59 f4       	brne	.+22     	; 0xb9c <__stack+0x9d>
     b86:	8c e7       	ldi	r24, 0x7C	; 124
     b88:	94 e0       	ldi	r25, 0x04	; 4
     b8a:	a8 dd       	rcall	.-1200   	; 0x6dc <Serial_SendString>
            Serial_SendString("Advertising started : Waiting to be connected and bonded\r\n");
     b8c:	88 ea       	ldi	r24, 0xA8	; 168
     b8e:	94 e0       	ldi	r25, 0x04	; 4
     b90:	a5 dd       	rcall	.-1206   	; 0x6dc <Serial_SendString>
     b92:	10 d5       	rcall	.+2592   	; 0x15b4 <lib_aci_sleep>
     b94:	84 e0       	ldi	r24, 0x04	; 4
          }
          else
          {
            if (bonded_first_time)
     b96:	80 93 09 09 	sts	0x0909, r24	; 0x800909 <aci_state+0x14>
     b9a:	c6 c0       	rjmp	.+396    	; 0xd28 <__stack+0x229>
     b9c:	80 91 07 09 	lds	r24, 0x0907	; 0x800907 <aci_state+0x12>
            {
              bonded_first_time = false;
     ba0:	88 23       	and	r24, r24
              //Store away the dynamic data of the nRF8001 in the Flash or EEPROM of the MCU
              // so we can restore the bond information of the nRF8001 in the event of power loss
              if (bond_data_read_store(&aci_state))
     ba2:	49 f0       	breq	.+18     	; 0xbb6 <__stack+0xb7>
     ba4:	60 e5       	ldi	r22, 0x50	; 80
     ba6:	70 e0       	ldi	r23, 0x00	; 0
     ba8:	84 eb       	ldi	r24, 0xB4	; 180
     baa:	90 e0       	ldi	r25, 0x00	; 0
              {
                Serial_SendString("Dynamic Data read and stored successfully\r\n");
     bac:	96 d5       	rcall	.+2860   	; 0x16da <lib_aci_bond>
     bae:	87 e4       	ldi	r24, 0x47	; 71
     bb0:	93 e0       	ldi	r25, 0x03	; 3
              }
            }

            //connect to an already bonded device
            //Use lib_aci_direct_connect for faster re-connections (advertising interval of 3.75 ms is used for directed advertising)
            lib_aci_connect(180/* in seconds */, 0x0020 /* advertising interval 20ms*/);
     bb2:	94 dd       	rcall	.-1240   	; 0x6dc <Serial_SendString>
     bb4:	b9 c0       	rjmp	.+370    	; 0xd28 <__stack+0x229>
     bb6:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <bonded_first_time>
     bba:	88 23       	and	r24, r24
     bbc:	51 f0       	breq	.+20     	; 0xbd2 <__stack+0xd3>
            Serial_SendString("Already bonded : Advertising started : Waiting to be connected\r\n");
     bbe:	10 92 02 01 	sts	0x0102, r1	; 0x800102 <bonded_first_time>
     bc2:	85 ef       	ldi	r24, 0xF5	; 245
     bc4:	98 e0       	ldi	r25, 0x08	; 8
          }
        }
        break;

      case ACI_EVT_DATA_RECEIVED:
        Serial_SendString("Pipe #: 0x\r\n");
     bc6:	60 de       	rcall	.-832    	; 0x888 <bond_data_read_store>
     bc8:	88 23       	and	r24, r24
     bca:	19 f0       	breq	.+6      	; 0xbd2 <__stack+0xd3>
        Serial_SendString(aci_evt->params.data_received.rx_data.pipe_number); //, HEX);
     bcc:	81 ec       	ldi	r24, 0xC1	; 193
     bce:	94 e0       	ldi	r25, 0x04	; 4
     bd0:	85 dd       	rcall	.-1270   	; 0x6dc <Serial_SendString>
     bd2:	60 e2       	ldi	r22, 0x20	; 32
     bd4:	70 e0       	ldi	r23, 0x00	; 0
        {
          int i;
          Serial_SendString(" Data(Hex) : \r\n");
     bd6:	84 eb       	ldi	r24, 0xB4	; 180
     bd8:	90 e0       	ldi	r25, 0x00	; 0
     bda:	41 d5       	rcall	.+2690   	; 0x165e <lib_aci_connect>
     bdc:	82 e8       	ldi	r24, 0x82	; 130
          for(i=0; i<aci_evt->len - 2; i++)
     bde:	93 e0       	ldi	r25, 0x03	; 3
     be0:	7d dd       	rcall	.-1286   	; 0x6dc <Serial_SendString>
     be2:	a2 c0       	rjmp	.+324    	; 0xd28 <__stack+0x229>
     be4:	8d ee       	ldi	r24, 0xED	; 237
     be6:	94 e0       	ldi	r25, 0x04	; 4
     be8:	79 dd       	rcall	.-1294   	; 0x6dc <Serial_SendString>
     bea:	c3 ed       	ldi	r28, 0xD3	; 211
     bec:	d8 e0       	ldi	r29, 0x08	; 8
     bee:	8b 81       	ldd	r24, Y+3	; 0x03
     bf0:	90 e0       	ldi	r25, 0x00	; 0
     bf2:	74 dd       	rcall	.-1304   	; 0x6dc <Serial_SendString>
     bf4:	8a ef       	ldi	r24, 0xFA	; 250
     bf6:	94 e0       	ldi	r25, 0x04	; 4
     bf8:	71 dd       	rcall	.-1310   	; 0x6dc <Serial_SendString>
     bfa:	89 81       	ldd	r24, Y+1	; 0x01
          {
            Serial_SendString(aci_evt->params.data_received.rx_data.aci_data[i]); //, HEX);
     bfc:	90 e0       	ldi	r25, 0x00	; 0
     bfe:	02 97       	sbiw	r24, 0x02	; 2
     c00:	18 16       	cp	r1, r24
     c02:	19 06       	cpc	r1, r25
     c04:	d4 f4       	brge	.+52     	; 0xc3a <__stack+0x13b>
            Serial_SendString(" \r\n");
     c06:	07 ed       	ldi	r16, 0xD7	; 215
     c08:	18 e0       	ldi	r17, 0x08	; 8
     c0a:	c0 e0       	ldi	r28, 0x00	; 0
     c0c:	d0 e0       	ldi	r29, 0x00	; 0
        Serial_SendString("Pipe #: 0x\r\n");
        Serial_SendString(aci_evt->params.data_received.rx_data.pipe_number); //, HEX);
        {
          int i;
          Serial_SendString(" Data(Hex) : \r\n");
          for(i=0; i<aci_evt->len - 2; i++)
     c0e:	0f 2e       	mov	r0, r31
     c10:	f3 ed       	ldi	r31, 0xD3	; 211
     c12:	ef 2e       	mov	r14, r31
     c14:	f8 e0       	ldi	r31, 0x08	; 8
     c16:	ff 2e       	mov	r15, r31
          {
            Serial_SendString(aci_evt->params.data_received.rx_data.aci_data[i]); //, HEX);
            Serial_SendString(" \r\n");
          }
        }
        Serial_SendString("\r\n");
     c18:	f0 2d       	mov	r31, r0
     c1a:	f8 01       	movw	r30, r16
        break;
     c1c:	81 91       	ld	r24, Z+

      case ACI_EVT_HW_ERROR:
        Serial_SendString("HW error: \r\n");
     c1e:	8f 01       	movw	r16, r30
     c20:	90 e0       	ldi	r25, 0x00	; 0
     c22:	5c dd       	rcall	.-1352   	; 0x6dc <Serial_SendString>
        Serial_SendString(aci_evt->params.hw_error.line_num);  //, DEC);
     c24:	86 e0       	ldi	r24, 0x06	; 6
     c26:	95 e0       	ldi	r25, 0x05	; 5
     c28:	59 dd       	rcall	.-1358   	; 0x6dc <Serial_SendString>
     c2a:	21 96       	adiw	r28, 0x01	; 1

        for(uint8_t counter = 0; counter <= (aci_evt->len - 3); counter++)
     c2c:	f7 01       	movw	r30, r14
     c2e:	81 81       	ldd	r24, Z+1	; 0x01
     c30:	90 e0       	ldi	r25, 0x00	; 0
     c32:	02 97       	sbiw	r24, 0x02	; 2
     c34:	c8 17       	cp	r28, r24
     c36:	d9 07       	cpc	r29, r25
        {
        Serial_SendString(aci_evt->params.hw_error.file_name[counter]); //uint8_t file_name[20];
     c38:	84 f3       	brlt	.-32     	; 0xc1a <__stack+0x11b>
     c3a:	87 e0       	ldi	r24, 0x07	; 7
     c3c:	95 e0       	ldi	r25, 0x05	; 5
     c3e:	4e dd       	rcall	.-1380   	; 0x6dc <Serial_SendString>
     c40:	73 c0       	rjmp	.+230    	; 0xd28 <__stack+0x229>
     c42:	8a e0       	ldi	r24, 0x0A	; 10

      case ACI_EVT_HW_ERROR:
        Serial_SendString("HW error: \r\n");
        Serial_SendString(aci_evt->params.hw_error.line_num);  //, DEC);

        for(uint8_t counter = 0; counter <= (aci_evt->len - 3); counter++)
     c44:	95 e0       	ldi	r25, 0x05	; 5
     c46:	4a dd       	rcall	.-1388   	; 0x6dc <Serial_SendString>
     c48:	c3 ed       	ldi	r28, 0xD3	; 211
     c4a:	d8 e0       	ldi	r29, 0x08	; 8
     c4c:	8b 81       	ldd	r24, Y+3	; 0x03
     c4e:	9c 81       	ldd	r25, Y+4	; 0x04
     c50:	45 dd       	rcall	.-1398   	; 0x6dc <Serial_SendString>
        {
        Serial_SendString(aci_evt->params.hw_error.file_name[counter]); //uint8_t file_name[20];
        }
        Serial_SendString("\r\n"); //blank serial.println(); 
     c52:	89 81       	ldd	r24, Y+1	; 0x01
     c54:	90 e0       	ldi	r25, 0x00	; 0

        //Manage the bond in EEPROM of the AVR
        {
          uint8_t eeprom_status = 0;
          eeprom_status = eeprom_read_byte(0);
     c56:	03 97       	sbiw	r24, 0x03	; 3
     c58:	92 f0       	brmi	.+36     	; 0xc7e <__stack+0x17f>
     c5a:	20 e0       	ldi	r18, 0x00	; 0
          if (eeprom_status != 0x00)
     c5c:	30 e0       	ldi	r19, 0x00	; 0
     c5e:	10 e0       	ldi	r17, 0x00	; 0
          {
            Serial_SendString("Previous Bond present. Restoring\r\n");
     c60:	f9 01       	movw	r30, r18
     c62:	ed 52       	subi	r30, 0x2D	; 45
     c64:	f7 4f       	sbci	r31, 0xF7	; 247
            Serial_SendString("Using existing bond stored in EEPROM.\r\n");
     c66:	85 81       	ldd	r24, Z+5	; 0x05
     c68:	90 e0       	ldi	r25, 0x00	; 0
     c6a:	38 dd       	rcall	.-1424   	; 0x6dc <Serial_SendString>
            Serial_SendString("   To delete the bond stored in EEPROM, connect Pin 6 to 3.3v and Reset.\r\n");
     c6c:	1f 5f       	subi	r17, 0xFF	; 255
     c6e:	21 2f       	mov	r18, r17
     c70:	30 e0       	ldi	r19, 0x00	; 0
            Serial_SendString("   Make sure that the bond on the phone/PC is deleted as well.\r\n");
     c72:	89 81       	ldd	r24, Y+1	; 0x01
     c74:	90 e0       	ldi	r25, 0x00	; 0
     c76:	03 97       	sbiw	r24, 0x03	; 3
            //We must have lost power and restarted and must restore the bonding information using the ACI Write Dynamic Data
            if (ACI_STATUS_TRANSACTION_COMPLETE == bond_data_restore(&aci_state, eeprom_status, &bonded_first_time))
     c78:	82 17       	cp	r24, r18
     c7a:	93 07       	cpc	r25, r19
     c7c:	8c f7       	brge	.-30     	; 0xc60 <__stack+0x161>
     c7e:	87 e0       	ldi	r24, 0x07	; 7
     c80:	95 e0       	ldi	r25, 0x05	; 5
     c82:	2c dd       	rcall	.-1448   	; 0x6dc <Serial_SendString>
     c84:	80 e0       	ldi	r24, 0x00	; 0
            {
              Serial_SendString("Bond restored successfully\r\n");
     c86:	90 e0       	ldi	r25, 0x00	; 0
     c88:	0e 94 93 13 	call	0x2726	; 0x2726 <eeprom_read_byte>
     c8c:	c8 2f       	mov	r28, r24
     c8e:	88 23       	and	r24, r24
            }
            else
            {
              Serial_SendString("Bond restore failed. Delete the bond and try again.\r\n");
     c90:	d9 f0       	breq	.+54     	; 0xcc8 <__stack+0x1c9>
     c92:	80 e0       	ldi	r24, 0x00	; 0
     c94:	92 e0       	ldi	r25, 0x02	; 2
     c96:	22 dd       	rcall	.-1468   	; 0x6dc <Serial_SendString>
            }
          }
        }

        // Start bonding as all proximity devices need to be bonded to be usable
        if (ACI_BOND_STATUS_SUCCESS != aci_state.bonded)
     c98:	83 e2       	ldi	r24, 0x23	; 35
     c9a:	92 e0       	ldi	r25, 0x02	; 2
     c9c:	1f dd       	rcall	.-1474   	; 0x6dc <Serial_SendString>
     c9e:	8b e4       	ldi	r24, 0x4B	; 75
        {
          lib_aci_bond(180/* in seconds */, 0x0050 /* advertising interval 50ms*/);
     ca0:	92 e0       	ldi	r25, 0x02	; 2
     ca2:	1c dd       	rcall	.-1480   	; 0x6dc <Serial_SendString>
     ca4:	86 e9       	ldi	r24, 0x96	; 150
     ca6:	92 e0       	ldi	r25, 0x02	; 2
     ca8:	19 dd       	rcall	.-1486   	; 0x6dc <Serial_SendString>
     caa:	42 e0       	ldi	r20, 0x02	; 2
          Serial_SendString("No Bond present in EEPROM.\r\n");
     cac:	51 e0       	ldi	r21, 0x01	; 1
     cae:	6c 2f       	mov	r22, r28
     cb0:	85 ef       	ldi	r24, 0xF5	; 245
     cb2:	98 e0       	ldi	r25, 0x08	; 8
          Serial_SendString("Advertising started : Waiting to be connected and bonded\r\n");
     cb4:	39 dd       	rcall	.-1422   	; 0x728 <bond_data_restore>
     cb6:	82 30       	cpi	r24, 0x02	; 2
     cb8:	21 f4       	brne	.+8      	; 0xcc2 <__stack+0x1c3>
     cba:	87 ed       	ldi	r24, 0xD7	; 215
     cbc:	92 e0       	ldi	r25, 0x02	; 2
        }
        else
        {
          //connect to an already bonded device
          //Use lib_aci_direct_connect for faster re-connections with PC, not recommended to use with iOS/OS X
          lib_aci_connect(100/* in seconds */, 0x0020 /* advertising interval 20ms*/);
     cbe:	0e dd       	rcall	.-1508   	; 0x6dc <Serial_SendString>
     cc0:	03 c0       	rjmp	.+6      	; 0xcc8 <__stack+0x1c9>
     cc2:	84 ef       	ldi	r24, 0xF4	; 244
     cc4:	92 e0       	ldi	r25, 0x02	; 2
     cc6:	0a dd       	rcall	.-1516   	; 0x6dc <Serial_SendString>
     cc8:	80 91 07 09 	lds	r24, 0x0907	; 0x800907 <aci_state+0x12>
          Serial_SendString("Already bonded : Advertising started : Waiting to be connected\r\n");
     ccc:	88 23       	and	r24, r24
     cce:	61 f0       	breq	.+24     	; 0xce8 <__stack+0x1e9>
     cd0:	60 e5       	ldi	r22, 0x50	; 80
     cd2:	70 e0       	ldi	r23, 0x00	; 0
        }
        break;

	  case ACI_EVT_INVALID:
			//Added AHJ not handled before
			Serial_SendString("ACI Event Invalid! I couldn't handle this before and I still can't\r\n");
     cd4:	84 eb       	ldi	r24, 0xB4	; 180
     cd6:	90 e0       	ldi	r25, 0x00	; 0
     cd8:	00 d5       	rcall	.+2560   	; 0x16da <lib_aci_bond>
     cda:	8a e2       	ldi	r24, 0x2A	; 42
			break;
     cdc:	93 e0       	ldi	r25, 0x03	; 3
		
	  case ACI_EVT_ECHO:
			//Added AHJ not handled before
			Serial_SendString("ACI Event ECHO! I couldn't handle this before and I still can't\r\n");
     cde:	fe dc       	rcall	.-1540   	; 0x6dc <Serial_SendString>
     ce0:	87 e4       	ldi	r24, 0x47	; 71
     ce2:	93 e0       	ldi	r25, 0x03	; 3
     ce4:	fb dc       	rcall	.-1546   	; 0x6dc <Serial_SendString>
			break;
     ce6:	20 c0       	rjmp	.+64     	; 0xd28 <__stack+0x229>

	  case ACI_EVT_DATA_ACK:
			//Added AHJ not handled before
			Serial_SendString("ACI Event Data Acknowledged! I couldn't handle this before and I still can't\r\n");
     ce8:	60 e2       	ldi	r22, 0x20	; 32
     cea:	70 e0       	ldi	r23, 0x00	; 0
     cec:	84 e6       	ldi	r24, 0x64	; 100
     cee:	90 e0       	ldi	r25, 0x00	; 0
			break;
     cf0:	b6 d4       	rcall	.+2412   	; 0x165e <lib_aci_connect>

	  case ACI_EVT_DISPLAY_PASSKEY:
			//Added AHJ not handled before
			Serial_SendString("ACI Event Display Passkey! I couldn't handle this before and I still can't\r\n");
     cf2:	82 e8       	ldi	r24, 0x82	; 130
     cf4:	93 e0       	ldi	r25, 0x03	; 3
     cf6:	f2 dc       	rcall	.-1564   	; 0x6dc <Serial_SendString>
     cf8:	17 c0       	rjmp	.+46     	; 0xd28 <__stack+0x229>
			break;
     cfa:	87 e1       	ldi	r24, 0x17	; 23

	  case ACI_EVT_KEY_REQUEST:
			//Added AHJ not handled before
			Serial_SendString("ACI Event Key Request! I couldn't handle this before and I still can't\r\n");
     cfc:	95 e0       	ldi	r25, 0x05	; 5
     cfe:	ee dc       	rcall	.-1572   	; 0x6dc <Serial_SendString>
     d00:	13 c0       	rjmp	.+38     	; 0xd28 <__stack+0x229>
     d02:	8c e5       	ldi	r24, 0x5C	; 92
			break;
     d04:	95 e0       	ldi	r25, 0x05	; 5
    }
  }
  else
  {
    Serial_SendString("No ACI Events available\r\n");
     d06:	ea dc       	rcall	.-1580   	; 0x6dc <Serial_SendString>
     d08:	0f c0       	rjmp	.+30     	; 0xd28 <__stack+0x229>
     d0a:	8e e9       	ldi	r24, 0x9E	; 158
     d0c:	95 e0       	ldi	r25, 0x05	; 5
  
  /* setup_required is set to true when the device starts up and enters setup mode.
   * It indicates that do_aci_setup() should be called. The flag should be cleared if
   * do_aci_setup() returns ACI_STATUS_TRANSACTION_COMPLETE.
   */
  if(setup_required)
     d0e:	e6 dc       	rcall	.-1588   	; 0x6dc <Serial_SendString>
     d10:	0b c0       	rjmp	.+22     	; 0xd28 <__stack+0x229>
     d12:	8d ee       	ldi	r24, 0xED	; 237
     d14:	95 e0       	ldi	r25, 0x05	; 5
  {
    if (SETUP_SUCCESS == do_aci_setup(&aci_state))
     d16:	e2 dc       	rcall	.-1596   	; 0x6dc <Serial_SendString>
     d18:	07 c0       	rjmp	.+14     	; 0xd28 <__stack+0x229>
     d1a:	8a e3       	ldi	r24, 0x3A	; 58
     d1c:	96 e0       	ldi	r25, 0x06	; 6
     d1e:	de dc       	rcall	.-1604   	; 0x6dc <Serial_SendString>
     d20:	03 c0       	rjmp	.+6      	; 0xd28 <__stack+0x229>
    {
      setup_required = false;
     d22:	83 e8       	ldi	r24, 0x83	; 131
     d24:	96 e0       	ldi	r25, 0x06	; 6
    }
  }
}
     d26:	da dc       	rcall	.-1612   	; 0x6dc <Serial_SendString>
     d28:	80 91 b0 08 	lds	r24, 0x08B0	; 0x8008b0 <__data_end>
     d2c:	88 23       	and	r24, r24
     d2e:	39 f0       	breq	.+14     	; 0xd3e <__stack+0x23f>
     d30:	85 ef       	ldi	r24, 0xF5	; 245
     d32:	98 e0       	ldi	r25, 0x08	; 8
     d34:	2c d2       	rcall	.+1112   	; 0x118e <do_aci_setup>
     d36:	81 11       	cpse	r24, r1
     d38:	02 c0       	rjmp	.+4      	; 0xd3e <__stack+0x23f>
     d3a:	10 92 b0 08 	sts	0x08B0, r1	; 0x8008b0 <__data_end>
     d3e:	df 91       	pop	r29
     d40:	cf 91       	pop	r28
     d42:	1f 91       	pop	r17
     d44:	0f 91       	pop	r16
     d46:	ff 90       	pop	r15
     d48:	ef 90       	pop	r14
     d4a:	08 95       	ret

00000d4c <setup>:

/*
This is called only once after a reset of the AVR
*/
void setup(void)
{
     d4c:	1f 93       	push	r17
     d4e:	cf 93       	push	r28
     d50:	df 93       	push	r29
			 *  \return Boolean \c true if a character can be queued for transmission immediately, \c false otherwise.
			 */
			static inline bool Serial_IsSendReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Serial_IsSendReady(void)
			{
				return ((UCSR1A & (1 << UDRE1)) ? true : false);
     d52:	e8 ec       	ldi	r30, 0xC8	; 200
     d54:	f0 e0       	ldi	r31, 0x00	; 0
     d56:	80 81       	ld	r24, Z
  //Wait until the serial port is available (useful only for the Leonardo)
  //As the Leonardo board is not reseted every time you open the Serial Monitor
  */
  #if defined (__AVR_ATmega32U4__)
	
		while(!Serial_IsSendReady())
     d58:	85 ff       	sbrs	r24, 5
     d5a:	fd cf       	rjmp	.-6      	; 0xd56 <setup+0xa>
  */
  
  /**
  Point ACI data structures to the the setup data that the nRFgo studio generated for the nRF8001
  */
  Serial_SendString("Setting up services\r\n"); //AHJ
     d5c:	8d e9       	ldi	r24, 0x9D	; 157
     d5e:	96 e0       	ldi	r25, 0x06	; 6
     d60:	bd dc       	rcall	.-1670   	; 0x6dc <Serial_SendString>
  if (NULL != services_pipe_type_mapping)
  {
    aci_state.aci_setup_info.services_pipe_type_mapping = &services_pipe_type_mapping[0];
     d62:	c5 ef       	ldi	r28, 0xF5	; 245
     d64:	d8 e0       	ldi	r29, 0x08	; 8
     d66:	83 e0       	ldi	r24, 0x03	; 3
     d68:	91 e0       	ldi	r25, 0x01	; 1
     d6a:	9d 87       	std	Y+13, r25	; 0x0d
     d6c:	8c 87       	std	Y+12, r24	; 0x0c
  }
  else
  {
    aci_state.aci_setup_info.services_pipe_type_mapping = NULL;
  }
  aci_state.aci_setup_info.number_of_pipes    = NUMBER_OF_PIPES;
     d6e:	8c e0       	ldi	r24, 0x0C	; 12
     d70:	8e 87       	std	Y+14, r24	; 0x0e
  aci_state.aci_setup_info.setup_msgs         = (hal_aci_data_t*) setup_msgs;
     d72:	83 e8       	ldi	r24, 0x83	; 131
     d74:	91 e0       	ldi	r25, 0x01	; 1
     d76:	98 8b       	std	Y+16, r25	; 0x10
     d78:	8f 87       	std	Y+15, r24	; 0x0f
  aci_state.aci_setup_info.num_setup_msgs     = NB_SETUP_MESSAGES;
     d7a:	81 e2       	ldi	r24, 0x21	; 33
     d7c:	89 8b       	std	Y+17, r24	; 0x11
  Tell the ACI library, the MCU to nRF8001 pin connections.
  The Active pin is optional and can be marked UNUSED
  */
  //Serial_SendString("Are these the right pins?\r\n"); //AHJ
  //All of these pin assignments are for setting up the pins and few other uses. Replaced with
  aci_state.aci_pins.board_name = BOARD_DEFAULT; //See board.h for details
     d7e:	18 82       	st	Y, r1
  aci_state.aci_pins.reqn_pin   = 28;	//PB4
     d80:	8c e1       	ldi	r24, 0x1C	; 28
     d82:	89 83       	std	Y+1, r24	; 0x01
  aci_state.aci_pins.rdyn_pin   = 8;	//PB0
     d84:	88 e0       	ldi	r24, 0x08	; 8
     d86:	8a 83       	std	Y+2, r24	; 0x02
  aci_state.aci_pins.mosi_pin   = 10;	//PB2
     d88:	8a e0       	ldi	r24, 0x0A	; 10
     d8a:	8b 83       	std	Y+3, r24	; 0x03
  aci_state.aci_pins.miso_pin   = 11;	//PB3
     d8c:	8b e0       	ldi	r24, 0x0B	; 11
     d8e:	8c 83       	std	Y+4, r24	; 0x04
  aci_state.aci_pins.sck_pin    = 9;	//PB1
     d90:	89 e0       	ldi	r24, 0x09	; 9
     d92:	8d 83       	std	Y+5, r24	; 0x05

  //DEFINED IN SPI_INIT(); AHJ
  aci_state.aci_pins.spi_clock_divider      = 1;//SPI_CLOCK_DIV8  = 2MHz SPI speed  or SPI_CLOCK_DIV16 = 1MHz SPI speed
     d94:	11 e0       	ldi	r17, 0x01	; 1
     d96:	1e 83       	std	Y+6, r17	; 0x06

  aci_state.aci_pins.reset_pin              = 29;	//PB5
     d98:	8d e1       	ldi	r24, 0x1D	; 29
     d9a:	8f 83       	std	Y+7, r24	; 0x07
  aci_state.aci_pins.active_pin             = 30;	//PB6
     d9c:	8e e1       	ldi	r24, 0x1E	; 30
     d9e:	88 87       	std	Y+8, r24	; 0x08
  aci_state.aci_pins.optional_chip_sel_pin  = UNUSED;
     da0:	8f ef       	ldi	r24, 0xFF	; 255
     da2:	89 87       	std	Y+9, r24	; 0x09

  aci_state.aci_pins.interface_is_interrupt = false;  //IS it ? AHJ
     da4:	1a 86       	std	Y+10, r1	; 0x0a
  aci_state.aci_pins.interrupt_number       = 1;
     da6:	1b 87       	std	Y+11, r17	; 0x0b

  /** We reset the nRF8001 here by toggling the RESET line connected to the nRF8001
   *  and initialize the data structures required to setup the nRF8001
   */
  //Initialize ACI library. The The second parameter is for turning debug printing on for the ACI Commands and Events so they be printed on the Serial
  lib_aci_init(&aci_state, true);
     da8:	61 e0       	ldi	r22, 0x01	; 1
     daa:	ce 01       	movw	r24, r28
     dac:	c1 d5       	rcall	.+2946   	; 0x1930 <lib_aci_init>
	
  //pinMode(6, INPUT); //Pin #6 on Arduino -> PAIRING CLEAR pin: Connect to 3.3v to clear the pairing WTF is this AHJ
  DDRD &= ~(1 << 2);  
     dae:	52 98       	cbi	0x0a, 2	; 10
  PORTD &= ~(1 << 2);
     db0:	5a 98       	cbi	0x0b, 2	; 11
    while(1) {};
  }

  //Initialize the state of the bond
  
  aci_state.bonded = ACI_BOND_STATUS_FAILED;
     db2:	1a 8b       	std	Y+18, r17	; 0x12
}
     db4:	df 91       	pop	r29
     db6:	cf 91       	pop	r28
     db8:	1f 91       	pop	r17
     dba:	08 95       	ret

00000dbc <loop>:


/* This is like a main() { while(1) { loop() } }
*/
void loop(void)
{
     dbc:	cf 93       	push	r28
     dbe:	df 93       	push	r29
     dc0:	00 d0       	rcall	.+0      	; 0xdc2 <loop+0x6>
     dc2:	1f 92       	push	r1
     dc4:	cd b7       	in	r28, 0x3d	; 61
	//Serial_SendString("I am doing BLE loop now\r\n");
  aci_loop();
     dc6:	de b7       	in	r29, 0x3e	; 62

  /*
  Method for sending HID Reports
  */
  if (lib_aci_is_pipe_available(&aci_state, PIPE_HID_SERVICE_HID_REPORT_ID1_TX)
     dc8:	94 dd       	rcall	.-1240   	; 0x8f2 <aci_loop>
     dca:	66 e0       	ldi	r22, 0x06	; 6
     dcc:	85 ef       	ldi	r24, 0xF5	; 245
     dce:	98 e0       	ldi	r25, 0x08	; 8
     dd0:	e0 d3       	rcall	.+1984   	; 0x1592 <lib_aci_is_pipe_available>
     dd2:	88 23       	and	r24, r24
      && (aci_state.data_credit_available > 0) )
     dd4:	99 f0       	breq	.+38     	; 0xdfc <loop+0x40>
     dd6:	80 91 0a 09 	lds	r24, 0x090A	; 0x80090a <aci_state+0x15>
     dda:	88 23       	and	r24, r24
  {
    uint8_t joy[3] = {0, 0, 0};
     ddc:	79 f0       	breq	.+30     	; 0xdfc <loop+0x40>

    joy[0] = 0;                  //Z axis
    joy[1] = 1; //analogRead(1) << 4; //Y axis
     dde:	19 82       	std	Y+1, r1	; 0x01
     de0:	81 e0       	ldi	r24, 0x01	; 1
    joy[2] = 1; //analogRead(0) << 4; //X axis
     de2:	8a 83       	std	Y+2, r24	; 0x02

    lib_aci_send_data(PIPE_HID_SERVICE_HID_REPORT_ID1_TX, &joy[0], 3); 
     de4:	8b 83       	std	Y+3, r24	; 0x03
     de6:	43 e0       	ldi	r20, 0x03	; 3
     de8:	be 01       	movw	r22, r28
     dea:	6f 5f       	subi	r22, 0xFF	; 255
     dec:	7f 4f       	sbci	r23, 0xFF	; 255
     dee:	86 e0       	ldi	r24, 0x06	; 6
	aci_state.data_credit_available--;
     df0:	8e d4       	rcall	.+2332   	; 0x170e <lib_aci_send_data>
     df2:	e5 ef       	ldi	r30, 0xF5	; 245
     df4:	f8 e0       	ldi	r31, 0x08	; 8
     df6:	85 89       	ldd	r24, Z+21	; 0x15
     df8:	81 50       	subi	r24, 0x01	; 1
  }

}
     dfa:	85 8b       	std	Z+21, r24	; 0x15
     dfc:	0f 90       	pop	r0
     dfe:	0f 90       	pop	r0
     e00:	0f 90       	pop	r0
     e02:	df 91       	pop	r29
     e04:	cf 91       	pop	r28
     e06:	08 95       	ret

00000e08 <BLE_main>:
{
	setup();
	
	for(;;)
	{
		loop();
     e08:	a1 df       	rcall	.-190    	; 0xd4c <setup>
     e0a:	d8 df       	rcall	.-80     	; 0xdbc <loop>
     e0c:	fe cf       	rjmp	.-4      	; 0xe0a <BLE_main+0x2>

00000e0e <acil_encode_cmd_sleep>:
     e0e:	21 e0       	ldi	r18, 0x01	; 1
     e10:	fc 01       	movw	r30, r24
     e12:	20 83       	st	Z, r18
     e14:	24 e0       	ldi	r18, 0x04	; 4
     e16:	21 83       	std	Z+1, r18	; 0x01
     e18:	08 95       	ret

00000e1a <acil_encode_cmd_get_device_version>:
     e1a:	21 e0       	ldi	r18, 0x01	; 1
     e1c:	fc 01       	movw	r30, r24
     e1e:	20 83       	st	Z, r18
     e20:	29 e0       	ldi	r18, 0x09	; 9
     e22:	21 83       	std	Z+1, r18	; 0x01
     e24:	08 95       	ret

00000e26 <acil_encode_cmd_set_local_data>:
     e26:	22 e0       	ldi	r18, 0x02	; 2
     e28:	24 0f       	add	r18, r20
     e2a:	dc 01       	movw	r26, r24
     e2c:	2c 93       	st	X, r18
     e2e:	2d e0       	ldi	r18, 0x0D	; 13
     e30:	11 96       	adiw	r26, 0x01	; 1
     e32:	2c 93       	st	X, r18
     e34:	11 97       	sbiw	r26, 0x01	; 1
     e36:	e6 2f       	mov	r30, r22
     e38:	f7 2f       	mov	r31, r23
     e3a:	21 91       	ld	r18, Z+
     e3c:	12 96       	adiw	r26, 0x02	; 2
     e3e:	2c 93       	st	X, r18
     e40:	50 e0       	ldi	r21, 0x00	; 0
     e42:	bf 01       	movw	r22, r30
     e44:	03 96       	adiw	r24, 0x03	; 3
     e46:	0c 94 8a 13 	jmp	0x2714	; 0x2714 <memcpy>
     e4a:	08 95       	ret

00000e4c <acil_encode_cmd_connect>:
     e4c:	fc 01       	movw	r30, r24
     e4e:	db 01       	movw	r26, r22
     e50:	85 e0       	ldi	r24, 0x05	; 5
     e52:	80 83       	st	Z, r24
     e54:	8f e0       	ldi	r24, 0x0F	; 15
     e56:	81 83       	std	Z+1, r24	; 0x01
     e58:	11 96       	adiw	r26, 0x01	; 1
     e5a:	8c 91       	ld	r24, X
     e5c:	11 97       	sbiw	r26, 0x01	; 1
     e5e:	83 83       	std	Z+3, r24	; 0x03
     e60:	8c 91       	ld	r24, X
     e62:	82 83       	std	Z+2, r24	; 0x02
     e64:	13 96       	adiw	r26, 0x03	; 3
     e66:	8c 91       	ld	r24, X
     e68:	13 97       	sbiw	r26, 0x03	; 3
     e6a:	85 83       	std	Z+5, r24	; 0x05
     e6c:	12 96       	adiw	r26, 0x02	; 2
     e6e:	8c 91       	ld	r24, X
     e70:	84 83       	std	Z+4, r24	; 0x04
     e72:	08 95       	ret

00000e74 <acil_encode_cmd_bond>:
     e74:	fc 01       	movw	r30, r24
     e76:	db 01       	movw	r26, r22
     e78:	85 e0       	ldi	r24, 0x05	; 5
     e7a:	80 83       	st	Z, r24
     e7c:	80 e1       	ldi	r24, 0x10	; 16
     e7e:	81 83       	std	Z+1, r24	; 0x01
     e80:	11 96       	adiw	r26, 0x01	; 1
     e82:	8c 91       	ld	r24, X
     e84:	11 97       	sbiw	r26, 0x01	; 1
     e86:	83 83       	std	Z+3, r24	; 0x03
     e88:	8c 91       	ld	r24, X
     e8a:	82 83       	std	Z+2, r24	; 0x02
     e8c:	13 96       	adiw	r26, 0x03	; 3
     e8e:	8c 91       	ld	r24, X
     e90:	13 97       	sbiw	r26, 0x03	; 3
     e92:	85 83       	std	Z+5, r24	; 0x05
     e94:	12 96       	adiw	r26, 0x02	; 2
     e96:	8c 91       	ld	r24, X
     e98:	84 83       	std	Z+4, r24	; 0x04
     e9a:	08 95       	ret

00000e9c <acil_encode_cmd_disconnect>:
     e9c:	fc 01       	movw	r30, r24
     e9e:	82 e0       	ldi	r24, 0x02	; 2
     ea0:	80 83       	st	Z, r24
     ea2:	81 e1       	ldi	r24, 0x11	; 17
     ea4:	81 83       	std	Z+1, r24	; 0x01
     ea6:	db 01       	movw	r26, r22
     ea8:	8c 91       	ld	r24, X
     eaa:	82 83       	std	Z+2, r24	; 0x02
     eac:	08 95       	ret

00000eae <acil_encode_baseband_reset>:
     eae:	21 e0       	ldi	r18, 0x01	; 1
     eb0:	fc 01       	movw	r30, r24
     eb2:	20 83       	st	Z, r18
     eb4:	2e e0       	ldi	r18, 0x0E	; 14
     eb6:	21 83       	std	Z+1, r18	; 0x01
     eb8:	08 95       	ret

00000eba <acil_encode_cmd_send_data>:
     eba:	22 e0       	ldi	r18, 0x02	; 2
     ebc:	24 0f       	add	r18, r20
     ebe:	dc 01       	movw	r26, r24
     ec0:	2c 93       	st	X, r18
     ec2:	25 e1       	ldi	r18, 0x15	; 21
     ec4:	11 96       	adiw	r26, 0x01	; 1
     ec6:	2c 93       	st	X, r18
     ec8:	11 97       	sbiw	r26, 0x01	; 1
     eca:	e6 2f       	mov	r30, r22
     ecc:	f7 2f       	mov	r31, r23
     ece:	21 91       	ld	r18, Z+
     ed0:	12 96       	adiw	r26, 0x02	; 2
     ed2:	2c 93       	st	X, r18
     ed4:	50 e0       	ldi	r21, 0x00	; 0
     ed6:	bf 01       	movw	r22, r30
     ed8:	03 96       	adiw	r24, 0x03	; 3
     eda:	0c 94 8a 13 	jmp	0x2714	; 0x2714 <memcpy>
     ede:	08 95       	ret

00000ee0 <acil_encode_cmd_read_dynamic_data>:
     ee0:	21 e0       	ldi	r18, 0x01	; 1
     ee2:	fc 01       	movw	r30, r24
     ee4:	20 83       	st	Z, r18
     ee6:	27 e0       	ldi	r18, 0x07	; 7
     ee8:	21 83       	std	Z+1, r18	; 0x01
     eea:	08 95       	ret

00000eec <acil_encode_cmd_change_timing_req_GAP_PPCP>:
     eec:	21 e0       	ldi	r18, 0x01	; 1
     eee:	fc 01       	movw	r30, r24
     ef0:	20 83       	st	Z, r18
     ef2:	23 e1       	ldi	r18, 0x13	; 19
     ef4:	21 83       	std	Z+1, r18	; 0x01
     ef6:	08 95       	ret

00000ef8 <aci_queue_init>:
#include  <stdbool.h>
#include <avr/interrupt.h>
//#define  NULL  0

void aci_queue_init(aci_queue_t *aci_q)
{
     ef8:	cf 93       	push	r28
     efa:	df 93       	push	r29
     efc:	ec 01       	movw	r28, r24
  uint8_t loop;

  ble_assert(NULL != aci_q);
     efe:	89 2b       	or	r24, r25
     f00:	29 f4       	brne	.+10     	; 0xf0c <aci_queue_init+0x14>
     f02:	65 e2       	ldi	r22, 0x25	; 37
     f04:	70 e0       	ldi	r23, 0x00	; 0
     f06:	83 eb       	ldi	r24, 0xB3	; 179
     f08:	96 e0       	ldi	r25, 0x06	; 6
     f0a:	fe db       	rcall	.-2052   	; 0x708 <__ble_assert>

  aci_q->head = 0;
     f0c:	fe 01       	movw	r30, r28
     f0e:	ec 57       	subi	r30, 0x7C	; 124
     f10:	ff 4f       	sbci	r31, 0xFF	; 255
     f12:	10 82       	st	Z, r1
  aci_q->tail = 0;
     f14:	31 96       	adiw	r30, 0x01	; 1
     f16:	10 82       	st	Z, r1
  for(loop=0; loop<ACI_QUEUE_SIZE; loop++)
  {
    aci_q->aci_data[loop].buffer[0] = 0x00;
     f18:	19 82       	std	Y+1, r1	; 0x01
    aci_q->aci_data[loop].buffer[1] = 0x00;
     f1a:	1a 82       	std	Y+2, r1	; 0x02

  aci_q->head = 0;
  aci_q->tail = 0;
  for(loop=0; loop<ACI_QUEUE_SIZE; loop++)
  {
    aci_q->aci_data[loop].buffer[0] = 0x00;
     f1c:	1a a2       	std	Y+34, r1	; 0x22
    aci_q->aci_data[loop].buffer[1] = 0x00;
     f1e:	1b a2       	std	Y+35, r1	; 0x23

  aci_q->head = 0;
  aci_q->tail = 0;
  for(loop=0; loop<ACI_QUEUE_SIZE; loop++)
  {
    aci_q->aci_data[loop].buffer[0] = 0x00;
     f20:	e2 54       	subi	r30, 0x42	; 66
     f22:	f1 09       	sbc	r31, r1
     f24:	10 82       	st	Z, r1
    aci_q->aci_data[loop].buffer[1] = 0x00;
     f26:	31 96       	adiw	r30, 0x01	; 1
     f28:	10 82       	st	Z, r1

  aci_q->head = 0;
  aci_q->tail = 0;
  for(loop=0; loop<ACI_QUEUE_SIZE; loop++)
  {
    aci_q->aci_data[loop].buffer[0] = 0x00;
     f2a:	b0 96       	adiw	r30, 0x20	; 32
     f2c:	10 82       	st	Z, r1
    aci_q->aci_data[loop].buffer[1] = 0x00;
     f2e:	cb 59       	subi	r28, 0x9B	; 155
     f30:	df 4f       	sbci	r29, 0xFF	; 255
     f32:	18 82       	st	Y, r1
  }
}
     f34:	df 91       	pop	r29
     f36:	cf 91       	pop	r28
     f38:	08 95       	ret

00000f3a <aci_queue_is_empty>:
  return true;
}
*/

bool aci_queue_is_empty(aci_queue_t *aci_q)
{
     f3a:	cf 93       	push	r28
     f3c:	df 93       	push	r29
     f3e:	ec 01       	movw	r28, r24
  bool state = false;

  ble_assert(NULL != aci_q);
     f40:	89 2b       	or	r24, r25
     f42:	29 f4       	brne	.+10     	; 0xf4e <aci_queue_is_empty+0x14>
     f44:	6d e7       	ldi	r22, 0x7D	; 125
     f46:	70 e0       	ldi	r23, 0x00	; 0
     f48:	83 eb       	ldi	r24, 0xB3	; 179
     f4a:	96 e0       	ldi	r25, 0x06	; 6
     f4c:	dd db       	rcall	.-2118   	; 0x708 <__ble_assert>

  //Critical section
  //noInterrupts();
  //GlobalInterruptDisable(); 
  
  if (aci_q->head == aci_q->tail)
     f4e:	fe 01       	movw	r30, r28
     f50:	ec 57       	subi	r30, 0x7C	; 124
     f52:	ff 4f       	sbci	r31, 0xFF	; 255
     f54:	cb 57       	subi	r28, 0x7B	; 123
     f56:	df 4f       	sbci	r29, 0xFF	; 255
    state = true;
  }
  //interrupts();
  //GlobalInterruptEnable();

  return state;
     f58:	81 e0       	ldi	r24, 0x01	; 1
     f5a:	20 81       	ld	r18, Z
     f5c:	98 81       	ld	r25, Y
     f5e:	29 13       	cpse	r18, r25
     f60:	80 e0       	ldi	r24, 0x00	; 0
}
     f62:	df 91       	pop	r29
     f64:	cf 91       	pop	r28
     f66:	08 95       	ret

00000f68 <aci_queue_dequeue>:
    aci_q->aci_data[loop].buffer[1] = 0x00;
  }
}

bool aci_queue_dequeue(aci_queue_t *aci_q, hal_aci_data_t *p_data)
{
     f68:	0f 93       	push	r16
     f6a:	1f 93       	push	r17
     f6c:	cf 93       	push	r28
     f6e:	df 93       	push	r29
     f70:	ec 01       	movw	r28, r24
     f72:	8b 01       	movw	r16, r22
  ble_assert(NULL != aci_q);
     f74:	89 2b       	or	r24, r25
     f76:	29 f4       	brne	.+10     	; 0xf82 <aci_queue_dequeue+0x1a>
     f78:	62 e3       	ldi	r22, 0x32	; 50
     f7a:	70 e0       	ldi	r23, 0x00	; 0
     f7c:	83 eb       	ldi	r24, 0xB3	; 179
     f7e:	96 e0       	ldi	r25, 0x06	; 6
     f80:	c3 db       	rcall	.-2170   	; 0x708 <__ble_assert>
  ble_assert(NULL != p_data);
     f82:	01 15       	cp	r16, r1
     f84:	11 05       	cpc	r17, r1
     f86:	29 f4       	brne	.+10     	; 0xf92 <aci_queue_dequeue+0x2a>
     f88:	63 e3       	ldi	r22, 0x33	; 51
     f8a:	70 e0       	ldi	r23, 0x00	; 0
     f8c:	83 eb       	ldi	r24, 0xB3	; 179
     f8e:	96 e0       	ldi	r25, 0x06	; 6

  if (aci_queue_is_empty(aci_q))
     f90:	bb db       	rcall	.-2186   	; 0x708 <__ble_assert>
     f92:	ce 01       	movw	r24, r28
     f94:	d2 df       	rcall	.-92     	; 0xf3a <aci_queue_is_empty>
     f96:	88 23       	and	r24, r24
  {
    Serial_SendString("ACI Queue is Empty\r\n");
     f98:	29 f0       	breq	.+10     	; 0xfa4 <aci_queue_dequeue+0x3c>
     f9a:	81 ed       	ldi	r24, 0xD1	; 209
     f9c:	96 e0       	ldi	r25, 0x06	; 6
	return false;
     f9e:	9e db       	rcall	.-2244   	; 0x6dc <Serial_SendString>
  }
  Serial_SendString("Writing Something to mem\r\n");
     fa0:	80 e0       	ldi	r24, 0x00	; 0
     fa2:	1a c0       	rjmp	.+52     	; 0xfd8 <aci_queue_dequeue+0x70>
     fa4:	86 ee       	ldi	r24, 0xE6	; 230
     fa6:	96 e0       	ldi	r25, 0x06	; 6
  memcpy((uint8_t *)p_data, (uint8_t *)&(aci_q->aci_data[aci_q->head % ACI_QUEUE_SIZE]), sizeof(hal_aci_data_t));
     fa8:	99 db       	rcall	.-2254   	; 0x6dc <Serial_SendString>
     faa:	ce 01       	movw	r24, r28
     fac:	8c 57       	subi	r24, 0x7C	; 124
     fae:	9f 4f       	sbci	r25, 0xFF	; 255
     fb0:	fc 01       	movw	r30, r24
     fb2:	20 81       	ld	r18, Z
     fb4:	23 70       	andi	r18, 0x03	; 3
     fb6:	fe 01       	movw	r30, r28
     fb8:	31 e2       	ldi	r19, 0x21	; 33
     fba:	23 9f       	mul	r18, r19
     fbc:	e0 0d       	add	r30, r0
     fbe:	f1 1d       	adc	r31, r1
     fc0:	11 24       	eor	r1, r1
     fc2:	21 e2       	ldi	r18, 0x21	; 33
     fc4:	d8 01       	movw	r26, r16
     fc6:	01 90       	ld	r0, Z+
     fc8:	0d 92       	st	X+, r0
     fca:	2a 95       	dec	r18
  ++aci_q->head;
     fcc:	e1 f7       	brne	.-8      	; 0xfc6 <aci_queue_dequeue+0x5e>
     fce:	fc 01       	movw	r30, r24
     fd0:	20 81       	ld	r18, Z
     fd2:	2f 5f       	subi	r18, 0xFF	; 255

  return true;
     fd4:	20 83       	st	Z, r18
}
     fd6:	81 e0       	ldi	r24, 0x01	; 1
     fd8:	df 91       	pop	r29
     fda:	cf 91       	pop	r28
     fdc:	1f 91       	pop	r17
     fde:	0f 91       	pop	r16
     fe0:	08 95       	ret

00000fe2 <aci_queue_is_full>:
  return aci_q->head == aci_q->tail;
}
*/

bool aci_queue_is_full(aci_queue_t *aci_q)
{
     fe2:	cf 93       	push	r28
     fe4:	df 93       	push	r29
     fe6:	ec 01       	movw	r28, r24
  bool state;

  ble_assert(NULL != aci_q);
     fe8:	89 2b       	or	r24, r25
     fea:	29 f4       	brne	.+10     	; 0xff6 <aci_queue_is_full+0x14>
     fec:	6a e9       	ldi	r22, 0x9A	; 154
     fee:	70 e0       	ldi	r23, 0x00	; 0
     ff0:	83 eb       	ldi	r24, 0xB3	; 179
     ff2:	96 e0       	ldi	r25, 0x06	; 6
     ff4:	89 db       	rcall	.-2286   	; 0x708 <__ble_assert>
  //This should be done in a critical section
  //noInterrupts();
  //GlobalInterruptDisable();
  //cli();
  
  state = (aci_q->tail == aci_q->head + ACI_QUEUE_SIZE);
     ff6:	fe 01       	movw	r30, r28
     ff8:	ec 57       	subi	r30, 0x7C	; 124
     ffa:	ff 4f       	sbci	r31, 0xFF	; 255
  //interrupts();
  //GlobalInterruptEnable();
  //sei();
  //end

  return state;
     ffc:	20 81       	ld	r18, Z
     ffe:	30 e0       	ldi	r19, 0x00	; 0
    1000:	2c 5f       	subi	r18, 0xFC	; 252
    1002:	3f 4f       	sbci	r19, 0xFF	; 255
  //This should be done in a critical section
  //noInterrupts();
  //GlobalInterruptDisable();
  //cli();
  
  state = (aci_q->tail == aci_q->head + ACI_QUEUE_SIZE);
    1004:	cb 57       	subi	r28, 0x7B	; 123
    1006:	df 4f       	sbci	r29, 0xFF	; 255
  //interrupts();
  //GlobalInterruptEnable();
  //sei();
  //end

  return state;
    1008:	48 81       	ld	r20, Y
    100a:	50 e0       	ldi	r21, 0x00	; 0
    100c:	81 e0       	ldi	r24, 0x01	; 1
    100e:	24 17       	cp	r18, r20
    1010:	35 07       	cpc	r19, r21
    1012:	09 f0       	breq	.+2      	; 0x1016 <aci_queue_is_full+0x34>
    1014:	80 e0       	ldi	r24, 0x00	; 0
}
    1016:	df 91       	pop	r29
    1018:	cf 91       	pop	r28
    101a:	08 95       	ret

0000101c <aci_queue_enqueue>:
  return true;
}
*/

bool aci_queue_enqueue(aci_queue_t *aci_q, hal_aci_data_t *p_data)
{
    101c:	df 92       	push	r13
    101e:	ef 92       	push	r14
    1020:	ff 92       	push	r15
    1022:	0f 93       	push	r16
    1024:	1f 93       	push	r17
    1026:	cf 93       	push	r28
    1028:	df 93       	push	r29
    102a:	ec 01       	movw	r28, r24
    102c:	8b 01       	movw	r16, r22
  const uint8_t length = p_data->buffer[0];
    102e:	fb 01       	movw	r30, r22
    1030:	d1 80       	ldd	r13, Z+1	; 0x01

  ble_assert(NULL != aci_q);
    1032:	89 2b       	or	r24, r25
    1034:	29 f4       	brne	.+10     	; 0x1040 <aci_queue_enqueue+0x24>
    1036:	66 e5       	ldi	r22, 0x56	; 86
    1038:	70 e0       	ldi	r23, 0x00	; 0
    103a:	83 eb       	ldi	r24, 0xB3	; 179
    103c:	96 e0       	ldi	r25, 0x06	; 6
    103e:	64 db       	rcall	.-2360   	; 0x708 <__ble_assert>
  ble_assert(NULL != p_data);
    1040:	01 15       	cp	r16, r1
    1042:	11 05       	cpc	r17, r1
    1044:	29 f4       	brne	.+10     	; 0x1050 <aci_queue_enqueue+0x34>
    1046:	67 e5       	ldi	r22, 0x57	; 87
    1048:	70 e0       	ldi	r23, 0x00	; 0
    104a:	83 eb       	ldi	r24, 0xB3	; 179
    104c:	96 e0       	ldi	r25, 0x06	; 6

  if (aci_queue_is_full(aci_q))
    104e:	5c db       	rcall	.-2376   	; 0x708 <__ble_assert>
    1050:	ce 01       	movw	r24, r28
    1052:	c7 df       	rcall	.-114    	; 0xfe2 <aci_queue_is_full>
    1054:	81 11       	cpse	r24, r1
    1056:	21 c0       	rjmp	.+66     	; 0x109a <aci_queue_enqueue+0x7e>
  {
    return false;
  }

  aci_q->aci_data[aci_q->tail % ACI_QUEUE_SIZE].status_byte = 0;
    1058:	7e 01       	movw	r14, r28
    105a:	f5 e8       	ldi	r31, 0x85	; 133
    105c:	ef 0e       	add	r14, r31
    105e:	f1 1c       	adc	r15, r1
    1060:	f7 01       	movw	r30, r14
    1062:	80 81       	ld	r24, Z
    1064:	83 70       	andi	r24, 0x03	; 3
    1066:	f1 e2       	ldi	r31, 0x21	; 33
    1068:	8f 9f       	mul	r24, r31
    106a:	c0 01       	movw	r24, r0
    106c:	11 24       	eor	r1, r1
    106e:	fe 01       	movw	r30, r28
    1070:	e8 0f       	add	r30, r24
    1072:	f9 1f       	adc	r31, r25
    1074:	10 82       	st	Z, r1
  memcpy((uint8_t *)&(aci_q->aci_data[aci_q->tail % ACI_QUEUE_SIZE].buffer[0]), (uint8_t *)&p_data->buffer[0], length + 1);
    1076:	01 96       	adiw	r24, 0x01	; 1
    1078:	4d 2d       	mov	r20, r13
    107a:	50 e0       	ldi	r21, 0x00	; 0
    107c:	4f 5f       	subi	r20, 0xFF	; 255
    107e:	5f 4f       	sbci	r21, 0xFF	; 255
    1080:	b8 01       	movw	r22, r16
    1082:	6f 5f       	subi	r22, 0xFF	; 255
    1084:	7f 4f       	sbci	r23, 0xFF	; 255
    1086:	8c 0f       	add	r24, r28
    1088:	9d 1f       	adc	r25, r29
    108a:	0e 94 8a 13 	call	0x2714	; 0x2714 <memcpy>
  ++aci_q->tail;
    108e:	f7 01       	movw	r30, r14
    1090:	80 81       	ld	r24, Z
    1092:	8f 5f       	subi	r24, 0xFF	; 255
    1094:	80 83       	st	Z, r24

  return true;
    1096:	81 e0       	ldi	r24, 0x01	; 1
    1098:	01 c0       	rjmp	.+2      	; 0x109c <aci_queue_enqueue+0x80>
  ble_assert(NULL != aci_q);
  ble_assert(NULL != p_data);

  if (aci_queue_is_full(aci_q))
  {
    return false;
    109a:	80 e0       	ldi	r24, 0x00	; 0
  aci_q->aci_data[aci_q->tail % ACI_QUEUE_SIZE].status_byte = 0;
  memcpy((uint8_t *)&(aci_q->aci_data[aci_q->tail % ACI_QUEUE_SIZE].buffer[0]), (uint8_t *)&p_data->buffer[0], length + 1);
  ++aci_q->tail;

  return true;
}
    109c:	df 91       	pop	r29
    109e:	cf 91       	pop	r28
    10a0:	1f 91       	pop	r17
    10a2:	0f 91       	pop	r16
    10a4:	ff 90       	pop	r15
    10a6:	ef 90       	pop	r14
    10a8:	df 90       	pop	r13
    10aa:	08 95       	ret

000010ac <aci_queue_peek>:

  return (aci_q->tail == aci_q->head + ACI_QUEUE_SIZE);
}
*/
bool aci_queue_peek(aci_queue_t *aci_q, hal_aci_data_t *p_data)
{
    10ac:	0f 93       	push	r16
    10ae:	1f 93       	push	r17
    10b0:	cf 93       	push	r28
    10b2:	df 93       	push	r29
    10b4:	ec 01       	movw	r28, r24
    10b6:	8b 01       	movw	r16, r22
  ble_assert(NULL != aci_q);
    10b8:	89 2b       	or	r24, r25
    10ba:	29 f4       	brne	.+10     	; 0x10c6 <aci_queue_peek+0x1a>
    10bc:	64 eb       	ldi	r22, 0xB4	; 180
    10be:	70 e0       	ldi	r23, 0x00	; 0
    10c0:	83 eb       	ldi	r24, 0xB3	; 179
    10c2:	96 e0       	ldi	r25, 0x06	; 6
    10c4:	21 db       	rcall	.-2494   	; 0x708 <__ble_assert>
  ble_assert(NULL != p_data);
    10c6:	01 15       	cp	r16, r1
    10c8:	11 05       	cpc	r17, r1
    10ca:	29 f4       	brne	.+10     	; 0x10d6 <aci_queue_peek+0x2a>
    10cc:	65 eb       	ldi	r22, 0xB5	; 181
    10ce:	70 e0       	ldi	r23, 0x00	; 0
    10d0:	83 eb       	ldi	r24, 0xB3	; 179
    10d2:	96 e0       	ldi	r25, 0x06	; 6

  if (aci_queue_is_empty(aci_q))
    10d4:	19 db       	rcall	.-2510   	; 0x708 <__ble_assert>
    10d6:	ce 01       	movw	r24, r28
    10d8:	30 df       	rcall	.-416    	; 0xf3a <aci_queue_is_empty>
    10da:	81 11       	cpse	r24, r1
    10dc:	13 c0       	rjmp	.+38     	; 0x1104 <aci_queue_peek+0x58>
  {
    return false;
  }

  memcpy((uint8_t *)p_data, (uint8_t *)&(aci_q->aci_data[aci_q->head % ACI_QUEUE_SIZE]), sizeof(hal_aci_data_t));
    10de:	fe 01       	movw	r30, r28
    10e0:	ec 57       	subi	r30, 0x7C	; 124
    10e2:	ff 4f       	sbci	r31, 0xFF	; 255
    10e4:	80 81       	ld	r24, Z
    10e6:	83 70       	andi	r24, 0x03	; 3
    10e8:	fe 01       	movw	r30, r28
    10ea:	91 e2       	ldi	r25, 0x21	; 33
    10ec:	89 9f       	mul	r24, r25
    10ee:	e0 0d       	add	r30, r0
    10f0:	f1 1d       	adc	r31, r1
    10f2:	11 24       	eor	r1, r1
    10f4:	81 e2       	ldi	r24, 0x21	; 33
    10f6:	d8 01       	movw	r26, r16
    10f8:	01 90       	ld	r0, Z+
    10fa:	0d 92       	st	X+, r0
    10fc:	8a 95       	dec	r24
    10fe:	e1 f7       	brne	.-8      	; 0x10f8 <aci_queue_peek+0x4c>

  return true;
    1100:	81 e0       	ldi	r24, 0x01	; 1
    1102:	01 c0       	rjmp	.+2      	; 0x1106 <aci_queue_peek+0x5a>
  ble_assert(NULL != aci_q);
  ble_assert(NULL != p_data);

  if (aci_queue_is_empty(aci_q))
  {
    return false;
    1104:	80 e0       	ldi	r24, 0x00	; 0
  }

  memcpy((uint8_t *)p_data, (uint8_t *)&(aci_q->aci_data[aci_q->head % ACI_QUEUE_SIZE]), sizeof(hal_aci_data_t));

  return true;
}
    1106:	df 91       	pop	r29
    1108:	cf 91       	pop	r28
    110a:	1f 91       	pop	r17
    110c:	0f 91       	pop	r16
    110e:	08 95       	ret

00001110 <aci_setup_fill>:
    1110:	df 92       	push	r13
    1112:	ef 92       	push	r14
    1114:	ff 92       	push	r15
    1116:	0f 93       	push	r16
    1118:	1f 93       	push	r17
    111a:	cf 93       	push	r28
    111c:	df 93       	push	r29
    111e:	ec 01       	movw	r28, r24
    1120:	fb 01       	movw	r30, r22
    1122:	90 81       	ld	r25, Z
    1124:	89 89       	ldd	r24, Y+17	; 0x11
    1126:	98 17       	cp	r25, r24
    1128:	40 f5       	brcc	.+80     	; 0x117a <aci_setup_fill+0x6a>
    112a:	8b 01       	movw	r16, r22
    112c:	f1 2c       	mov	r15, r1
    112e:	0f 2e       	mov	r0, r31
    1130:	f1 e2       	ldi	r31, 0x21	; 33
    1132:	ef 2e       	mov	r14, r31
    1134:	f0 2d       	mov	r31, r0
    1136:	dd 24       	eor	r13, r13
    1138:	d3 94       	inc	r13
    113a:	6f 85       	ldd	r22, Y+15	; 0x0f
    113c:	78 89       	ldd	r23, Y+16	; 0x10
    113e:	e9 9e       	mul	r14, r25
    1140:	60 0d       	add	r22, r0
    1142:	71 1d       	adc	r23, r1
    1144:	11 24       	eor	r1, r1
    1146:	fb 01       	movw	r30, r22
    1148:	31 96       	adiw	r30, 0x01	; 1
    114a:	44 91       	lpm	r20, Z
    114c:	50 e0       	ldi	r21, 0x00	; 0
    114e:	4e 5f       	subi	r20, 0xFE	; 254
    1150:	5f 4f       	sbci	r21, 0xFF	; 255
    1152:	8d e3       	ldi	r24, 0x3D	; 61
    1154:	9a e0       	ldi	r25, 0x0A	; 10
    1156:	0e 94 81 13 	call	0x2702	; 0x2702 <memcpy_P>
    115a:	8d e3       	ldi	r24, 0x3D	; 61
    115c:	9a e0       	ldi	r25, 0x0A	; 10
    115e:	ed d1       	rcall	.+986    	; 0x153a <hal_aci_tl_send>
    1160:	88 23       	and	r24, r24
    1162:	61 f0       	breq	.+24     	; 0x117c <aci_setup_fill+0x6c>
    1164:	f8 01       	movw	r30, r16
    1166:	90 81       	ld	r25, Z
    1168:	9f 5f       	subi	r25, 0xFF	; 255
    116a:	90 83       	st	Z, r25
    116c:	fd 2c       	mov	r15, r13
    116e:	89 89       	ldd	r24, Y+17	; 0x11
    1170:	98 17       	cp	r25, r24
    1172:	18 f3       	brcs	.-58     	; 0x113a <aci_setup_fill+0x2a>
    1174:	ff 24       	eor	r15, r15
    1176:	f3 94       	inc	r15
    1178:	01 c0       	rjmp	.+2      	; 0x117c <aci_setup_fill+0x6c>
    117a:	f1 2c       	mov	r15, r1
    117c:	8f 2d       	mov	r24, r15
    117e:	df 91       	pop	r29
    1180:	cf 91       	pop	r28
    1182:	1f 91       	pop	r17
    1184:	0f 91       	pop	r16
    1186:	ff 90       	pop	r15
    1188:	ef 90       	pop	r14
    118a:	df 90       	pop	r13
    118c:	08 95       	ret

0000118e <do_aci_setup>:
    118e:	7f 92       	push	r7
    1190:	8f 92       	push	r8
    1192:	9f 92       	push	r9
    1194:	af 92       	push	r10
    1196:	bf 92       	push	r11
    1198:	cf 92       	push	r12
    119a:	df 92       	push	r13
    119c:	ef 92       	push	r14
    119e:	ff 92       	push	r15
    11a0:	0f 93       	push	r16
    11a2:	1f 93       	push	r17
    11a4:	cf 93       	push	r28
    11a6:	df 93       	push	r29
    11a8:	1f 92       	push	r1
    11aa:	cd b7       	in	r28, 0x3d	; 61
    11ac:	de b7       	in	r29, 0x3e	; 62
    11ae:	8c 01       	movw	r16, r24
    11b0:	19 82       	std	Y+1, r1	; 0x01
    11b2:	fd d3       	rcall	.+2042   	; 0x19ae <lib_aci_command_queue_empty>
    11b4:	88 23       	and	r24, r24
    11b6:	09 f4       	brne	.+2      	; 0x11ba <do_aci_setup+0x2c>
    11b8:	57 c0       	rjmp	.+174    	; 0x1268 <do_aci_setup+0xda>
    11ba:	8d e3       	ldi	r24, 0x3D	; 61
    11bc:	9a e0       	ldi	r25, 0x0A	; 10
    11be:	ef d2       	rcall	.+1502   	; 0x179e <lib_aci_event_peek>
    11c0:	81 11       	cpse	r24, r1
    11c2:	54 c0       	rjmp	.+168    	; 0x126c <do_aci_setup+0xde>
    11c4:	be 01       	movw	r22, r28
    11c6:	6f 5f       	subi	r22, 0xFF	; 255
    11c8:	7f 4f       	sbci	r23, 0xFF	; 255
    11ca:	c8 01       	movw	r24, r16
    11cc:	a1 df       	rcall	.-190    	; 0x1110 <aci_setup_fill>
    11ce:	80 e0       	ldi	r24, 0x00	; 0
    11d0:	90 e0       	ldi	r25, 0x00	; 0
    11d2:	dc 01       	movw	r26, r24
    11d4:	71 2c       	mov	r7, r1
    11d6:	81 2c       	mov	r8, r1
    11d8:	91 2c       	mov	r9, r1
    11da:	a1 2c       	mov	r10, r1
    11dc:	2a c0       	rjmp	.+84     	; 0x1232 <do_aci_setup+0xa4>
    11de:	8d e3       	ldi	r24, 0x3D	; 61
    11e0:	9a e0       	ldi	r25, 0x0A	; 10
    11e2:	dd d2       	rcall	.+1466   	; 0x179e <lib_aci_event_peek>
    11e4:	88 23       	and	r24, r24
    11e6:	91 f1       	breq	.+100    	; 0x124c <do_aci_setup+0xbe>
    11e8:	80 91 3f 0a 	lds	r24, 0x0A3F	; 0x800a3f <msg_to_send+0x2>
    11ec:	84 38       	cpi	r24, 0x84	; 132
    11ee:	09 f0       	breq	.+2      	; 0x11f2 <do_aci_setup+0x64>
    11f0:	3f c0       	rjmp	.+126    	; 0x1270 <do_aci_setup+0xe2>
    11f2:	b0 90 41 0a 	lds	r11, 0x0A41	; 0x800a41 <msg_to_send+0x4>
    11f6:	21 e0       	ldi	r18, 0x01	; 1
    11f8:	b2 16       	cp	r11, r18
    11fa:	21 f0       	breq	.+8      	; 0x1204 <do_aci_setup+0x76>
    11fc:	82 e0       	ldi	r24, 0x02	; 2
    11fe:	b8 16       	cp	r11, r24
    1200:	79 f0       	breq	.+30     	; 0x1220 <do_aci_setup+0x92>
    1202:	38 c0       	rjmp	.+112    	; 0x1274 <do_aci_setup+0xe6>
    1204:	be 01       	movw	r22, r28
    1206:	6f 5f       	subi	r22, 0xFF	; 255
    1208:	7f 4f       	sbci	r23, 0xFF	; 255
    120a:	c8 01       	movw	r24, r16
    120c:	81 df       	rcall	.-254    	; 0x1110 <aci_setup_fill>
    120e:	6d e3       	ldi	r22, 0x3D	; 61
    1210:	7a e0       	ldi	r23, 0x0A	; 10
    1212:	c8 01       	movw	r24, r16
    1214:	c6 d2       	rcall	.+1420   	; 0x17a2 <lib_aci_event_get>
    1216:	87 2d       	mov	r24, r7
    1218:	98 2d       	mov	r25, r8
    121a:	a9 2d       	mov	r26, r9
    121c:	ba 2d       	mov	r27, r10
    121e:	09 c0       	rjmp	.+18     	; 0x1232 <do_aci_setup+0xa4>
    1220:	6d e3       	ldi	r22, 0x3D	; 61
    1222:	7a e0       	ldi	r23, 0x0A	; 10
    1224:	c8 01       	movw	r24, r16
    1226:	bd d2       	rcall	.+1402   	; 0x17a2 <lib_aci_event_get>
    1228:	22 e0       	ldi	r18, 0x02	; 2
    122a:	b2 16       	cp	r11, r18
    122c:	29 f1       	breq	.+74     	; 0x1278 <do_aci_setup+0xea>
    122e:	d7 01       	movw	r26, r14
    1230:	c6 01       	movw	r24, r12
    1232:	6c 01       	movw	r12, r24
    1234:	7d 01       	movw	r14, r26
    1236:	2f ef       	ldi	r18, 0xFF	; 255
    1238:	c2 1a       	sub	r12, r18
    123a:	d2 0a       	sbc	r13, r18
    123c:	e2 0a       	sbc	r14, r18
    123e:	f2 0a       	sbc	r15, r18
    1240:	8f 3f       	cpi	r24, 0xFF	; 255
    1242:	9f 4f       	sbci	r25, 0xFF	; 255
    1244:	af 40       	sbci	r26, 0x0F	; 15
    1246:	b1 05       	cpc	r27, r1
    1248:	50 f2       	brcs	.-108    	; 0x11de <do_aci_setup+0x50>
    124a:	18 c0       	rjmp	.+48     	; 0x127c <do_aci_setup+0xee>
    124c:	8f ef       	ldi	r24, 0xFF	; 255
    124e:	c8 1a       	sub	r12, r24
    1250:	d8 0a       	sbc	r13, r24
    1252:	e8 0a       	sbc	r14, r24
    1254:	f8 0a       	sbc	r15, r24
    1256:	c1 14       	cp	r12, r1
    1258:	d1 04       	cpc	r13, r1
    125a:	20 e1       	ldi	r18, 0x10	; 16
    125c:	e2 06       	cpc	r14, r18
    125e:	f1 04       	cpc	r15, r1
    1260:	09 f0       	breq	.+2      	; 0x1264 <do_aci_setup+0xd6>
    1262:	bd cf       	rjmp	.-134    	; 0x11de <do_aci_setup+0x50>
    1264:	83 e0       	ldi	r24, 0x03	; 3
    1266:	0b c0       	rjmp	.+22     	; 0x127e <do_aci_setup+0xf0>
    1268:	81 e0       	ldi	r24, 0x01	; 1
    126a:	09 c0       	rjmp	.+18     	; 0x127e <do_aci_setup+0xf0>
    126c:	82 e0       	ldi	r24, 0x02	; 2
    126e:	07 c0       	rjmp	.+14     	; 0x127e <do_aci_setup+0xf0>
    1270:	85 e0       	ldi	r24, 0x05	; 5
    1272:	05 c0       	rjmp	.+10     	; 0x127e <do_aci_setup+0xf0>
    1274:	84 e0       	ldi	r24, 0x04	; 4
    1276:	03 c0       	rjmp	.+6      	; 0x127e <do_aci_setup+0xf0>
    1278:	80 e0       	ldi	r24, 0x00	; 0
    127a:	01 c0       	rjmp	.+2      	; 0x127e <do_aci_setup+0xf0>
    127c:	83 e0       	ldi	r24, 0x03	; 3
    127e:	0f 90       	pop	r0
    1280:	df 91       	pop	r29
    1282:	cf 91       	pop	r28
    1284:	1f 91       	pop	r17
    1286:	0f 91       	pop	r16
    1288:	ff 90       	pop	r15
    128a:	ef 90       	pop	r14
    128c:	df 90       	pop	r13
    128e:	cf 90       	pop	r12
    1290:	bf 90       	pop	r11
    1292:	af 90       	pop	r10
    1294:	9f 90       	pop	r9
    1296:	8f 90       	pop	r8
    1298:	7f 90       	pop	r7
    129a:	08 95       	ret

0000129c <m_aci_data_print>:
}

bool hal_aci_tl_rx_q_full (void)
{
  return aci_queue_is_full(&aci_rx_q);
}
    129c:	cf 92       	push	r12
    129e:	df 92       	push	r13
    12a0:	ef 92       	push	r14
    12a2:	ff 92       	push	r15
    12a4:	0f 93       	push	r16
    12a6:	1f 93       	push	r17
    12a8:	cf 93       	push	r28
    12aa:	df 93       	push	r29
    12ac:	7c 01       	movw	r14, r24
    12ae:	fc 01       	movw	r30, r24
    12b0:	01 81       	ldd	r16, Z+1	; 0x01
    12b2:	90 e3       	ldi	r25, 0x30	; 48
    12b4:	90 0f       	add	r25, r16
    12b6:	e8 ec       	ldi	r30, 0xC8	; 200
    12b8:	f0 e0       	ldi	r31, 0x00	; 0
    12ba:	80 81       	ld	r24, Z
    12bc:	85 ff       	sbrs	r24, 5
    12be:	fd cf       	rjmp	.-6      	; 0x12ba <m_aci_data_print+0x1e>
    12c0:	90 93 ce 00 	sts	0x00CE, r25	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7e00ce>
    12c4:	81 e0       	ldi	r24, 0x01	; 1
    12c6:	97 e0       	ldi	r25, 0x07	; 7
    12c8:	09 da       	rcall	.-3054   	; 0x6dc <Serial_SendString>
    12ca:	10 e0       	ldi	r17, 0x00	; 0
    12cc:	c8 ec       	ldi	r28, 0xC8	; 200
    12ce:	d0 e0       	ldi	r29, 0x00	; 0
    12d0:	0f 2e       	mov	r0, r31
    12d2:	fe ec       	ldi	r31, 0xCE	; 206
    12d4:	cf 2e       	mov	r12, r31
    12d6:	d1 2c       	mov	r13, r1
    12d8:	f0 2d       	mov	r31, r0
    12da:	f7 01       	movw	r30, r14
    12dc:	e1 0f       	add	r30, r17
    12de:	f1 1d       	adc	r31, r1
    12e0:	91 81       	ldd	r25, Z+1	; 0x01
    12e2:	90 5d       	subi	r25, 0xD0	; 208
    12e4:	88 81       	ld	r24, Y
    12e6:	85 ff       	sbrs	r24, 5
    12e8:	fd cf       	rjmp	.-6      	; 0x12e4 <m_aci_data_print+0x48>
    12ea:	f6 01       	movw	r30, r12
    12ec:	90 83       	st	Z, r25
    12ee:	84 e0       	ldi	r24, 0x04	; 4
    12f0:	97 e0       	ldi	r25, 0x07	; 7
    12f2:	f4 d9       	rcall	.-3096   	; 0x6dc <Serial_SendString>
    12f4:	1f 5f       	subi	r17, 0xFF	; 255
    12f6:	01 17       	cp	r16, r17
    12f8:	80 f7       	brcc	.-32     	; 0x12da <m_aci_data_print+0x3e>
    12fa:	87 e0       	ldi	r24, 0x07	; 7
    12fc:	95 e0       	ldi	r25, 0x05	; 5
    12fe:	ee d9       	rcall	.-3108   	; 0x6dc <Serial_SendString>
    1300:	df 91       	pop	r29
    1302:	cf 91       	pop	r28
    1304:	1f 91       	pop	r17
    1306:	0f 91       	pop	r16
    1308:	ff 90       	pop	r15
    130a:	ef 90       	pop	r14
    130c:	df 90       	pop	r13
    130e:	cf 90       	pop	r12
    1310:	08 95       	ret

00001312 <m_aci_event_check>:
    1312:	cf 93       	push	r28
    1314:	df 93       	push	r29
    1316:	cd b7       	in	r28, 0x3d	; 61
    1318:	de b7       	in	r29, 0x3e	; 62
    131a:	c2 54       	subi	r28, 0x42	; 66
    131c:	d1 09       	sbc	r29, r1
    131e:	0f b6       	in	r0, 0x3f	; 63
    1320:	f8 94       	cli
    1322:	de bf       	out	0x3e, r29	; 62
    1324:	0f be       	out	0x3f, r0	; 63
    1326:	cd bf       	out	0x3d, r28	; 61
    1328:	81 e3       	ldi	r24, 0x31	; 49
    132a:	99 e0       	ldi	r25, 0x09	; 9
    132c:	5a de       	rcall	.-844    	; 0xfe2 <aci_queue_is_full>
    132e:	81 11       	cpse	r24, r1
    1330:	56 c0       	rjmp	.+172    	; 0x13de <m_aci_event_check+0xcc>
    1332:	be 01       	movw	r22, r28
    1334:	6f 5f       	subi	r22, 0xFF	; 255
    1336:	7f 4f       	sbci	r23, 0xFF	; 255
    1338:	87 eb       	ldi	r24, 0xB7	; 183
    133a:	99 e0       	ldi	r25, 0x09	; 9
    133c:	15 de       	rcall	.-982    	; 0xf68 <aci_queue_dequeue>
    133e:	81 11       	cpse	r24, r1
    1340:	02 c0       	rjmp	.+4      	; 0x1346 <m_aci_event_check+0x34>
    1342:	19 82       	std	Y+1, r1	; 0x01
    1344:	1a 82       	std	Y+2, r1	; 0x02
    1346:	2c 98       	cbi	0x05, 4	; 5
    1348:	8a 81       	ldd	r24, Y+2	; 0x02
    134a:	8e bd       	out	0x2e, r24	; 46
    134c:	0d b4       	in	r0, 0x2d	; 45
    134e:	07 fe       	sbrs	r0, 7
    1350:	fd cf       	rjmp	.-6      	; 0x134c <m_aci_event_check+0x3a>
    1352:	8e b5       	in	r24, 0x2e	; 46
    1354:	8a a3       	std	Y+34, r24	; 0x22
    1356:	8b 81       	ldd	r24, Y+3	; 0x03
    1358:	8e bd       	out	0x2e, r24	; 46
    135a:	0d b4       	in	r0, 0x2d	; 45
    135c:	07 fe       	sbrs	r0, 7
    135e:	fd cf       	rjmp	.-6      	; 0x135a <m_aci_event_check+0x48>
    1360:	8e b5       	in	r24, 0x2e	; 46
    1362:	8b a3       	std	Y+35, r24	; 0x23
    1364:	2a 81       	ldd	r18, Y+2	; 0x02
    1366:	22 23       	and	r18, r18
    1368:	49 f0       	breq	.+18     	; 0x137c <m_aci_event_check+0x6a>
    136a:	30 e0       	ldi	r19, 0x00	; 0
    136c:	48 2f       	mov	r20, r24
    136e:	50 e0       	ldi	r21, 0x00	; 0
    1370:	c9 01       	movw	r24, r18
    1372:	01 97       	sbiw	r24, 0x01	; 1
    1374:	84 17       	cp	r24, r20
    1376:	95 07       	cpc	r25, r21
    1378:	0c f4       	brge	.+2      	; 0x137c <m_aci_event_check+0x6a>
    137a:	ca 01       	movw	r24, r20
    137c:	80 32       	cpi	r24, 0x20	; 32
    137e:	08 f0       	brcs	.+2      	; 0x1382 <m_aci_event_check+0x70>
    1380:	8f e1       	ldi	r24, 0x1F	; 31
    1382:	88 23       	and	r24, r24
    1384:	a1 f0       	breq	.+40     	; 0x13ae <m_aci_event_check+0x9c>
    1386:	fe 01       	movw	r30, r28
    1388:	34 96       	adiw	r30, 0x04	; 4
    138a:	de 01       	movw	r26, r28
    138c:	94 96       	adiw	r26, 0x24	; 36
    138e:	81 50       	subi	r24, 0x01	; 1
    1390:	9e 01       	movw	r18, r28
    1392:	28 0f       	add	r18, r24
    1394:	31 1d       	adc	r19, r1
    1396:	2b 5f       	subi	r18, 0xFB	; 251
    1398:	3f 4f       	sbci	r19, 0xFF	; 255
    139a:	81 91       	ld	r24, Z+
    139c:	8e bd       	out	0x2e, r24	; 46
    139e:	0d b4       	in	r0, 0x2d	; 45
    13a0:	07 fe       	sbrs	r0, 7
    13a2:	fd cf       	rjmp	.-6      	; 0x139e <m_aci_event_check+0x8c>
    13a4:	8e b5       	in	r24, 0x2e	; 46
    13a6:	8d 93       	st	X+, r24
    13a8:	e2 17       	cp	r30, r18
    13aa:	f3 07       	cpc	r31, r19
    13ac:	b1 f7       	brne	.-20     	; 0x139a <m_aci_event_check+0x88>
    13ae:	2c 9a       	sbi	0x05, 4	; 5
    13b0:	81 e3       	ldi	r24, 0x31	; 49
    13b2:	99 e0       	ldi	r25, 0x09	; 9
    13b4:	16 de       	rcall	.-980    	; 0xfe2 <aci_queue_is_full>
    13b6:	81 11       	cpse	r24, r1
    13b8:	06 c0       	rjmp	.+12     	; 0x13c6 <m_aci_event_check+0xb4>
    13ba:	87 eb       	ldi	r24, 0xB7	; 183
    13bc:	99 e0       	ldi	r25, 0x09	; 9
    13be:	bd dd       	rcall	.-1158   	; 0xf3a <aci_queue_is_empty>
    13c0:	81 11       	cpse	r24, r1
    13c2:	01 c0       	rjmp	.+2      	; 0x13c6 <m_aci_event_check+0xb4>
    13c4:	2c 98       	cbi	0x05, 4	; 5
    13c6:	8b a1       	ldd	r24, Y+35	; 0x23
    13c8:	88 23       	and	r24, r24
    13ca:	49 f0       	breq	.+18     	; 0x13de <m_aci_event_check+0xcc>
    13cc:	be 01       	movw	r22, r28
    13ce:	6e 5d       	subi	r22, 0xDE	; 222
    13d0:	7f 4f       	sbci	r23, 0xFF	; 255
    13d2:	81 e3       	ldi	r24, 0x31	; 49
    13d4:	99 e0       	ldi	r25, 0x09	; 9
    13d6:	22 de       	rcall	.-956    	; 0x101c <aci_queue_enqueue>
    13d8:	81 11       	cpse	r24, r1
    13da:	01 c0       	rjmp	.+2      	; 0x13de <m_aci_event_check+0xcc>
    13dc:	ff cf       	rjmp	.-2      	; 0x13dc <m_aci_event_check+0xca>
    13de:	ce 5b       	subi	r28, 0xBE	; 190
    13e0:	df 4f       	sbci	r29, 0xFF	; 255
    13e2:	0f b6       	in	r0, 0x3f	; 63
    13e4:	f8 94       	cli
    13e6:	de bf       	out	0x3e, r29	; 62
    13e8:	0f be       	out	0x3f, r0	; 63
    13ea:	cd bf       	out	0x3d, r28	; 61
    13ec:	df 91       	pop	r29
    13ee:	cf 91       	pop	r28
    13f0:	08 95       	ret

000013f2 <hal_aci_tl_pin_reset>:
    13f2:	e0 91 22 09 	lds	r30, 0x0922	; 0x800922 <a_pins_local_ptr>
    13f6:	f0 91 23 09 	lds	r31, 0x0923	; 0x800923 <a_pins_local_ptr+0x1>
    13fa:	87 81       	ldd	r24, Z+7	; 0x07
    13fc:	8f 3f       	cpi	r24, 0xFF	; 255
    13fe:	d9 f0       	breq	.+54     	; 0x1436 <hal_aci_tl_pin_reset+0x44>
    1400:	25 9a       	sbi	0x04, 5	; 4
    1402:	e0 91 22 09 	lds	r30, 0x0922	; 0x800922 <a_pins_local_ptr>
    1406:	f0 91 23 09 	lds	r31, 0x0923	; 0x800923 <a_pins_local_ptr+0x1>
    140a:	80 81       	ld	r24, Z
    140c:	81 30       	cpi	r24, 0x01	; 1
    140e:	61 f4       	brne	.+24     	; 0x1428 <hal_aci_tl_pin_reset+0x36>
    1410:	2d 9a       	sbi	0x05, 5	; 5
    1412:	2f ef       	ldi	r18, 0xFF	; 255
    1414:	81 ee       	ldi	r24, 0xE1	; 225
    1416:	94 e0       	ldi	r25, 0x04	; 4
    1418:	21 50       	subi	r18, 0x01	; 1
    141a:	80 40       	sbci	r24, 0x00	; 0
    141c:	90 40       	sbci	r25, 0x00	; 0
    141e:	e1 f7       	brne	.-8      	; 0x1418 <hal_aci_tl_pin_reset+0x26>
    1420:	00 c0       	rjmp	.+0      	; 0x1422 <hal_aci_tl_pin_reset+0x30>
    1422:	00 00       	nop
    1424:	2d 98       	cbi	0x05, 5	; 5
    1426:	08 95       	ret
    1428:	87 e0       	ldi	r24, 0x07	; 7
    142a:	97 e0       	ldi	r25, 0x07	; 7
    142c:	57 d9       	rcall	.-3410   	; 0x6dc <Serial_SendString>
    142e:	25 9a       	sbi	0x04, 5	; 4
    1430:	2d 9a       	sbi	0x05, 5	; 5
    1432:	2d 98       	cbi	0x05, 5	; 5
    1434:	2d 9a       	sbi	0x05, 5	; 5
    1436:	08 95       	ret

00001438 <hal_aci_tl_event_peek>:
    1438:	cf 93       	push	r28
    143a:	df 93       	push	r29
    143c:	ec 01       	movw	r28, r24
    143e:	69 df       	rcall	.-302    	; 0x1312 <m_aci_event_check>
    1440:	be 01       	movw	r22, r28
    1442:	81 e3       	ldi	r24, 0x31	; 49
    1444:	99 e0       	ldi	r25, 0x09	; 9
    1446:	32 de       	rcall	.-924    	; 0x10ac <aci_queue_peek>
    1448:	df 91       	pop	r29
    144a:	cf 91       	pop	r28
    144c:	08 95       	ret

0000144e <hal_aci_tl_event_get>:
    144e:	0f 93       	push	r16
    1450:	1f 93       	push	r17
    1452:	cf 93       	push	r28
    1454:	8c 01       	movw	r16, r24
    1456:	81 e3       	ldi	r24, 0x31	; 49
    1458:	99 e0       	ldi	r25, 0x09	; 9
    145a:	c3 dd       	rcall	.-1146   	; 0xfe2 <aci_queue_is_full>
    145c:	81 11       	cpse	r24, r1
    145e:	01 c0       	rjmp	.+2      	; 0x1462 <hal_aci_tl_event_get+0x14>
    1460:	58 df       	rcall	.-336    	; 0x1312 <m_aci_event_check>
    1462:	81 e3       	ldi	r24, 0x31	; 49
    1464:	99 e0       	ldi	r25, 0x09	; 9
    1466:	bd dd       	rcall	.-1158   	; 0xfe2 <aci_queue_is_full>
    1468:	b8 01       	movw	r22, r16
    146a:	81 e3       	ldi	r24, 0x31	; 49
    146c:	99 e0       	ldi	r25, 0x09	; 9
    146e:	7c dd       	rcall	.-1288   	; 0xf68 <aci_queue_dequeue>
    1470:	c8 2f       	mov	r28, r24
    1472:	88 23       	and	r24, r24
    1474:	c1 f0       	breq	.+48     	; 0x14a6 <hal_aci_tl_event_get+0x58>
    1476:	80 91 24 09 	lds	r24, 0x0924	; 0x800924 <aci_debug_print>
    147a:	88 23       	and	r24, r24
    147c:	29 f0       	breq	.+10     	; 0x1488 <hal_aci_tl_event_get+0x3a>
    147e:	8b e1       	ldi	r24, 0x1B	; 27
    1480:	97 e0       	ldi	r25, 0x07	; 7
    1482:	2c d9       	rcall	.-3496   	; 0x6dc <Serial_SendString>
    1484:	c8 01       	movw	r24, r16
    1486:	0a df       	rcall	.-492    	; 0x129c <m_aci_data_print>
    1488:	81 e3       	ldi	r24, 0x31	; 49
    148a:	99 e0       	ldi	r25, 0x09	; 9
    148c:	aa dd       	rcall	.-1196   	; 0xfe2 <aci_queue_is_full>
    148e:	81 11       	cpse	r24, r1
    1490:	07 c0       	rjmp	.+14     	; 0x14a0 <hal_aci_tl_event_get+0x52>
    1492:	87 eb       	ldi	r24, 0xB7	; 183
    1494:	99 e0       	ldi	r25, 0x09	; 9
    1496:	51 dd       	rcall	.-1374   	; 0xf3a <aci_queue_is_empty>
    1498:	81 11       	cpse	r24, r1
    149a:	04 c0       	rjmp	.+8      	; 0x14a4 <hal_aci_tl_event_get+0x56>
    149c:	2c 98       	cbi	0x05, 4	; 5
    149e:	03 c0       	rjmp	.+6      	; 0x14a6 <hal_aci_tl_event_get+0x58>
    14a0:	c8 2f       	mov	r28, r24
    14a2:	01 c0       	rjmp	.+2      	; 0x14a6 <hal_aci_tl_event_get+0x58>
    14a4:	c8 2f       	mov	r28, r24
    14a6:	8c 2f       	mov	r24, r28
    14a8:	cf 91       	pop	r28
    14aa:	1f 91       	pop	r17
    14ac:	0f 91       	pop	r16
    14ae:	08 95       	ret

000014b0 <hal_aci_tl_init>:
    14b0:	cf 93       	push	r28
    14b2:	df 93       	push	r29
    14b4:	ec 01       	movw	r28, r24
    14b6:	60 93 24 09 	sts	0x0924, r22	; 0x800924 <aci_debug_print>
    14ba:	90 93 23 09 	sts	0x0923, r25	; 0x800923 <a_pins_local_ptr+0x1>
    14be:	80 93 22 09 	sts	0x0922, r24	; 0x800922 <a_pins_local_ptr>
    14c2:	20 9a       	sbi	0x04, 0	; 4
    14c4:	28 9a       	sbi	0x05, 0	; 5
    14c6:	84 b1       	in	r24, 0x04	; 4
    14c8:	86 60       	ori	r24, 0x06	; 6
    14ca:	84 b9       	out	0x04, r24	; 4
    14cc:	23 98       	cbi	0x04, 3	; 4
    14ce:	2b 9a       	sbi	0x05, 3	; 5
    14d0:	8d b5       	in	r24, 0x2d	; 45
    14d2:	81 60       	ori	r24, 0x01	; 1
    14d4:	8d bd       	out	0x2d, r24	; 45
    14d6:	20 98       	cbi	0x04, 0	; 4
    14d8:	82 e7       	ldi	r24, 0x72	; 114
    14da:	8c bd       	out	0x2c, r24	; 44
    14dc:	2f ef       	ldi	r18, 0xFF	; 255
    14de:	83 ed       	ldi	r24, 0xD3	; 211
    14e0:	90 e3       	ldi	r25, 0x30	; 48
    14e2:	21 50       	subi	r18, 0x01	; 1
    14e4:	80 40       	sbci	r24, 0x00	; 0
    14e6:	90 40       	sbci	r25, 0x00	; 0
    14e8:	e1 f7       	brne	.-8      	; 0x14e2 <hal_aci_tl_init+0x32>
    14ea:	00 c0       	rjmp	.+0      	; 0x14ec <hal_aci_tl_init+0x3c>
    14ec:	00 00       	nop
    14ee:	8d e1       	ldi	r24, 0x1D	; 29
    14f0:	97 e0       	ldi	r25, 0x07	; 7
    14f2:	f4 d8       	rcall	.-3608   	; 0x6dc <Serial_SendString>
    14f4:	87 eb       	ldi	r24, 0xB7	; 183
    14f6:	99 e0       	ldi	r25, 0x09	; 9
    14f8:	ff dc       	rcall	.-1538   	; 0xef8 <aci_queue_init>
    14fa:	85 e3       	ldi	r24, 0x35	; 53
    14fc:	97 e0       	ldi	r25, 0x07	; 7
    14fe:	ee d8       	rcall	.-3620   	; 0x6dc <Serial_SendString>
    1500:	81 e3       	ldi	r24, 0x31	; 49
    1502:	99 e0       	ldi	r25, 0x09	; 9
    1504:	f9 dc       	rcall	.-1550   	; 0xef8 <aci_queue_init>
    1506:	20 98       	cbi	0x04, 0	; 4
    1508:	28 9a       	sbi	0x05, 0	; 5
    150a:	24 9a       	sbi	0x04, 4	; 4
    150c:	2c 98       	cbi	0x05, 4	; 5
    150e:	88 85       	ldd	r24, Y+8	; 0x08
    1510:	8f 3f       	cpi	r24, 0xFF	; 255
    1512:	11 f0       	breq	.+4      	; 0x1518 <hal_aci_tl_init+0x68>
    1514:	26 98       	cbi	0x04, 6	; 4
    1516:	2e 9a       	sbi	0x05, 6	; 5
    1518:	6c df       	rcall	.-296    	; 0x13f2 <hal_aci_tl_pin_reset>
    151a:	2b 98       	cbi	0x05, 3	; 5
    151c:	2a 98       	cbi	0x05, 2	; 5
    151e:	2c 9a       	sbi	0x05, 4	; 5
    1520:	29 98       	cbi	0x05, 1	; 5
    1522:	2f ef       	ldi	r18, 0xFF	; 255
    1524:	86 e7       	ldi	r24, 0x76	; 118
    1526:	91 e0       	ldi	r25, 0x01	; 1
    1528:	21 50       	subi	r18, 0x01	; 1
    152a:	80 40       	sbci	r24, 0x00	; 0
    152c:	90 40       	sbci	r25, 0x00	; 0
    152e:	e1 f7       	brne	.-8      	; 0x1528 <hal_aci_tl_init+0x78>
    1530:	00 c0       	rjmp	.+0      	; 0x1532 <hal_aci_tl_init+0x82>
    1532:	00 00       	nop
    1534:	df 91       	pop	r29
    1536:	cf 91       	pop	r28
    1538:	08 95       	ret

0000153a <hal_aci_tl_send>:
    153a:	1f 93       	push	r17
    153c:	cf 93       	push	r28
    153e:	df 93       	push	r29
    1540:	fc 01       	movw	r30, r24
    1542:	21 81       	ldd	r18, Z+1	; 0x01
    1544:	20 32       	cpi	r18, 0x20	; 32
    1546:	b8 f4       	brcc	.+46     	; 0x1576 <hal_aci_tl_send+0x3c>
    1548:	ec 01       	movw	r28, r24
    154a:	bc 01       	movw	r22, r24
    154c:	87 eb       	ldi	r24, 0xB7	; 183
    154e:	99 e0       	ldi	r25, 0x09	; 9
    1550:	65 dd       	rcall	.-1334   	; 0x101c <aci_queue_enqueue>
    1552:	88 23       	and	r24, r24
    1554:	91 f0       	breq	.+36     	; 0x157a <hal_aci_tl_send+0x40>
    1556:	81 e3       	ldi	r24, 0x31	; 49
    1558:	99 e0       	ldi	r25, 0x09	; 9
    155a:	43 dd       	rcall	.-1402   	; 0xfe2 <aci_queue_is_full>
    155c:	81 11       	cpse	r24, r1
    155e:	01 c0       	rjmp	.+2      	; 0x1562 <hal_aci_tl_send+0x28>
    1560:	2c 98       	cbi	0x05, 4	; 5
    1562:	10 91 24 09 	lds	r17, 0x0924	; 0x800924 <aci_debug_print>
    1566:	11 23       	and	r17, r17
    1568:	51 f0       	breq	.+20     	; 0x157e <hal_aci_tl_send+0x44>
    156a:	8d e4       	ldi	r24, 0x4D	; 77
    156c:	97 e0       	ldi	r25, 0x07	; 7
    156e:	b6 d8       	rcall	.-3732   	; 0x6dc <Serial_SendString>
    1570:	ce 01       	movw	r24, r28
    1572:	94 de       	rcall	.-728    	; 0x129c <m_aci_data_print>
    1574:	05 c0       	rjmp	.+10     	; 0x1580 <hal_aci_tl_send+0x46>
    1576:	10 e0       	ldi	r17, 0x00	; 0
    1578:	03 c0       	rjmp	.+6      	; 0x1580 <hal_aci_tl_send+0x46>
    157a:	10 e0       	ldi	r17, 0x00	; 0
    157c:	01 c0       	rjmp	.+2      	; 0x1580 <hal_aci_tl_send+0x46>
    157e:	11 e0       	ldi	r17, 0x01	; 1
    1580:	81 2f       	mov	r24, r17
    1582:	df 91       	pop	r29
    1584:	cf 91       	pop	r28
    1586:	1f 91       	pop	r17
    1588:	08 95       	ret

0000158a <hal_aci_tl_tx_q_empty>:

bool hal_aci_tl_tx_q_empty (void)
{
  return aci_queue_is_empty(&aci_tx_q);
    158a:	87 eb       	ldi	r24, 0xB7	; 183
    158c:	99 e0       	ldi	r25, 0x09	; 9
    158e:	d5 cc       	rjmp	.-1622   	; 0xf3a <aci_queue_is_empty>
}
    1590:	08 95       	ret

00001592 <lib_aci_is_pipe_available>:
}

bool lib_aci_event_queue_full(void)
{
  return hal_aci_tl_rx_q_full();
}
    1592:	26 2f       	mov	r18, r22
    1594:	26 95       	lsr	r18
    1596:	26 95       	lsr	r18
    1598:	26 95       	lsr	r18
    159a:	82 0f       	add	r24, r18
    159c:	91 1d       	adc	r25, r1
    159e:	fc 01       	movw	r30, r24
    15a0:	84 8d       	ldd	r24, Z+28	; 0x1c
    15a2:	90 e0       	ldi	r25, 0x00	; 0
    15a4:	67 70       	andi	r22, 0x07	; 7
    15a6:	02 c0       	rjmp	.+4      	; 0x15ac <lib_aci_is_pipe_available+0x1a>
    15a8:	95 95       	asr	r25
    15aa:	87 95       	ror	r24
    15ac:	6a 95       	dec	r22
    15ae:	e2 f7       	brpl	.-8      	; 0x15a8 <lib_aci_is_pipe_available+0x16>
    15b0:	81 70       	andi	r24, 0x01	; 1
    15b2:	08 95       	ret

000015b4 <lib_aci_sleep>:
    15b4:	8e e3       	ldi	r24, 0x3E	; 62
    15b6:	9a e0       	ldi	r25, 0x0A	; 10
    15b8:	2a dc       	rcall	.-1964   	; 0xe0e <acil_encode_cmd_sleep>
    15ba:	8d e3       	ldi	r24, 0x3D	; 61
    15bc:	9a e0       	ldi	r25, 0x0A	; 10
    15be:	bd cf       	rjmp	.-134    	; 0x153a <hal_aci_tl_send>
    15c0:	08 95       	ret

000015c2 <lib_aci_radio_reset>:
    15c2:	8e e3       	ldi	r24, 0x3E	; 62
    15c4:	9a e0       	ldi	r25, 0x0A	; 10
    15c6:	73 dc       	rcall	.-1818   	; 0xeae <acil_encode_baseband_reset>
    15c8:	8d e3       	ldi	r24, 0x3D	; 61
    15ca:	9a e0       	ldi	r25, 0x0A	; 10
    15cc:	b6 cf       	rjmp	.-148    	; 0x153a <hal_aci_tl_send>
    15ce:	08 95       	ret

000015d0 <lib_aci_device_version>:
    15d0:	8e e3       	ldi	r24, 0x3E	; 62
    15d2:	9a e0       	ldi	r25, 0x0A	; 10
    15d4:	22 dc       	rcall	.-1980   	; 0xe1a <acil_encode_cmd_get_device_version>
    15d6:	8d e3       	ldi	r24, 0x3D	; 61
    15d8:	9a e0       	ldi	r25, 0x0A	; 10
    15da:	af cf       	rjmp	.-162    	; 0x153a <hal_aci_tl_send>
    15dc:	08 95       	ret

000015de <lib_aci_set_local_data>:
    15de:	1f 93       	push	r17
    15e0:	cf 93       	push	r28
    15e2:	df 93       	push	r29
    15e4:	cd b7       	in	r28, 0x3d	; 61
    15e6:	de b7       	in	r29, 0x3e	; 62
    15e8:	65 97       	sbiw	r28, 0x15	; 21
    15ea:	0f b6       	in	r0, 0x3f	; 63
    15ec:	f8 94       	cli
    15ee:	de bf       	out	0x3e, r29	; 62
    15f0:	0f be       	out	0x3f, r0	; 63
    15f2:	cd bf       	out	0x3d, r28	; 61
    15f4:	86 2f       	mov	r24, r22
    15f6:	90 e0       	ldi	r25, 0x00	; 0
    15f8:	fc 01       	movw	r30, r24
    15fa:	ee 0f       	add	r30, r30
    15fc:	ff 1f       	adc	r31, r31
    15fe:	8e 0f       	add	r24, r30
    1600:	9f 1f       	adc	r25, r31
    1602:	e0 91 2d 09 	lds	r30, 0x092D	; 0x80092d <p_services_pipe_type_map>
    1606:	f0 91 2e 09 	lds	r31, 0x092E	; 0x80092e <p_services_pipe_type_map+0x1>
    160a:	e8 0f       	add	r30, r24
    160c:	f9 1f       	adc	r31, r25
    160e:	33 97       	sbiw	r30, 0x03	; 3
    1610:	80 81       	ld	r24, Z
    1612:	81 30       	cpi	r24, 0x01	; 1
    1614:	b9 f4       	brne	.+46     	; 0x1644 <lib_aci_set_local_data+0x66>
    1616:	25 31       	cpi	r18, 0x15	; 21
    1618:	b8 f4       	brcc	.+46     	; 0x1648 <lib_aci_set_local_data+0x6a>
    161a:	12 2f       	mov	r17, r18
    161c:	9a 01       	movw	r18, r20
    161e:	69 83       	std	Y+1, r22	; 0x01
    1620:	41 2f       	mov	r20, r17
    1622:	50 e0       	ldi	r21, 0x00	; 0
    1624:	b9 01       	movw	r22, r18
    1626:	ce 01       	movw	r24, r28
    1628:	02 96       	adiw	r24, 0x02	; 2
    162a:	0e 94 8a 13 	call	0x2714	; 0x2714 <memcpy>
    162e:	41 2f       	mov	r20, r17
    1630:	be 01       	movw	r22, r28
    1632:	6f 5f       	subi	r22, 0xFF	; 255
    1634:	7f 4f       	sbci	r23, 0xFF	; 255
    1636:	8e e3       	ldi	r24, 0x3E	; 62
    1638:	9a e0       	ldi	r25, 0x0A	; 10
    163a:	f5 db       	rcall	.-2070   	; 0xe26 <acil_encode_cmd_set_local_data>
    163c:	8d e3       	ldi	r24, 0x3D	; 61
    163e:	9a e0       	ldi	r25, 0x0A	; 10
    1640:	7c df       	rcall	.-264    	; 0x153a <hal_aci_tl_send>
    1642:	03 c0       	rjmp	.+6      	; 0x164a <lib_aci_set_local_data+0x6c>
    1644:	80 e0       	ldi	r24, 0x00	; 0
    1646:	01 c0       	rjmp	.+2      	; 0x164a <lib_aci_set_local_data+0x6c>
    1648:	80 e0       	ldi	r24, 0x00	; 0
    164a:	65 96       	adiw	r28, 0x15	; 21
    164c:	0f b6       	in	r0, 0x3f	; 63
    164e:	f8 94       	cli
    1650:	de bf       	out	0x3e, r29	; 62
    1652:	0f be       	out	0x3f, r0	; 63
    1654:	cd bf       	out	0x3d, r28	; 61
    1656:	df 91       	pop	r29
    1658:	cf 91       	pop	r28
    165a:	1f 91       	pop	r17
    165c:	08 95       	ret

0000165e <lib_aci_connect>:
    165e:	cf 93       	push	r28
    1660:	df 93       	push	r29
    1662:	00 d0       	rcall	.+0      	; 0x1664 <lib_aci_connect+0x6>
    1664:	00 d0       	rcall	.+0      	; 0x1666 <lib_aci_connect+0x8>
    1666:	cd b7       	in	r28, 0x3d	; 61
    1668:	de b7       	in	r29, 0x3e	; 62
    166a:	9a 83       	std	Y+2, r25	; 0x02
    166c:	89 83       	std	Y+1, r24	; 0x01
    166e:	7c 83       	std	Y+4, r23	; 0x04
    1670:	6b 83       	std	Y+3, r22	; 0x03
    1672:	be 01       	movw	r22, r28
    1674:	6f 5f       	subi	r22, 0xFF	; 255
    1676:	7f 4f       	sbci	r23, 0xFF	; 255
    1678:	8e e3       	ldi	r24, 0x3E	; 62
    167a:	9a e0       	ldi	r25, 0x0A	; 10
    167c:	e7 db       	rcall	.-2098   	; 0xe4c <acil_encode_cmd_connect>
    167e:	8d e3       	ldi	r24, 0x3D	; 61
    1680:	9a e0       	ldi	r25, 0x0A	; 10
    1682:	5b df       	rcall	.-330    	; 0x153a <hal_aci_tl_send>
    1684:	0f 90       	pop	r0
    1686:	0f 90       	pop	r0
    1688:	0f 90       	pop	r0
    168a:	0f 90       	pop	r0
    168c:	df 91       	pop	r29
    168e:	cf 91       	pop	r28
    1690:	08 95       	ret

00001692 <lib_aci_disconnect>:
    1692:	0f 93       	push	r16
    1694:	1f 93       	push	r17
    1696:	cf 93       	push	r28
    1698:	df 93       	push	r29
    169a:	1f 92       	push	r1
    169c:	cd b7       	in	r28, 0x3d	; 61
    169e:	de b7       	in	r29, 0x3e	; 62
    16a0:	8c 01       	movw	r16, r24
    16a2:	69 83       	std	Y+1, r22	; 0x01
    16a4:	be 01       	movw	r22, r28
    16a6:	6f 5f       	subi	r22, 0xFF	; 255
    16a8:	7f 4f       	sbci	r23, 0xFF	; 255
    16aa:	8e e3       	ldi	r24, 0x3E	; 62
    16ac:	9a e0       	ldi	r25, 0x0A	; 10
    16ae:	f6 db       	rcall	.-2068   	; 0xe9c <acil_encode_cmd_disconnect>
    16b0:	8d e3       	ldi	r24, 0x3D	; 61
    16b2:	9a e0       	ldi	r25, 0x0A	; 10
    16b4:	42 df       	rcall	.-380    	; 0x153a <hal_aci_tl_send>
    16b6:	88 23       	and	r24, r24
    16b8:	51 f0       	breq	.+20     	; 0x16ce <lib_aci_disconnect+0x3c>
    16ba:	f8 01       	movw	r30, r16
    16bc:	7c 96       	adiw	r30, 0x1c	; 28
    16be:	98 01       	movw	r18, r16
    16c0:	2c 5d       	subi	r18, 0xDC	; 220
    16c2:	3f 4f       	sbci	r19, 0xFF	; 255
    16c4:	11 92       	st	Z+, r1
    16c6:	17 82       	std	Z+7, r1	; 0x07
    16c8:	e2 17       	cp	r30, r18
    16ca:	f3 07       	cpc	r31, r19
    16cc:	d9 f7       	brne	.-10     	; 0x16c4 <lib_aci_disconnect+0x32>
    16ce:	0f 90       	pop	r0
    16d0:	df 91       	pop	r29
    16d2:	cf 91       	pop	r28
    16d4:	1f 91       	pop	r17
    16d6:	0f 91       	pop	r16
    16d8:	08 95       	ret

000016da <lib_aci_bond>:
    16da:	cf 93       	push	r28
    16dc:	df 93       	push	r29
    16de:	00 d0       	rcall	.+0      	; 0x16e0 <lib_aci_bond+0x6>
    16e0:	00 d0       	rcall	.+0      	; 0x16e2 <lib_aci_bond+0x8>
    16e2:	cd b7       	in	r28, 0x3d	; 61
    16e4:	de b7       	in	r29, 0x3e	; 62
    16e6:	9a 83       	std	Y+2, r25	; 0x02
    16e8:	89 83       	std	Y+1, r24	; 0x01
    16ea:	7c 83       	std	Y+4, r23	; 0x04
    16ec:	6b 83       	std	Y+3, r22	; 0x03
    16ee:	be 01       	movw	r22, r28
    16f0:	6f 5f       	subi	r22, 0xFF	; 255
    16f2:	7f 4f       	sbci	r23, 0xFF	; 255
    16f4:	8e e3       	ldi	r24, 0x3E	; 62
    16f6:	9a e0       	ldi	r25, 0x0A	; 10
    16f8:	bd db       	rcall	.-2182   	; 0xe74 <acil_encode_cmd_bond>
    16fa:	8d e3       	ldi	r24, 0x3D	; 61
    16fc:	9a e0       	ldi	r25, 0x0A	; 10
    16fe:	1d df       	rcall	.-454    	; 0x153a <hal_aci_tl_send>
    1700:	0f 90       	pop	r0
    1702:	0f 90       	pop	r0
    1704:	0f 90       	pop	r0
    1706:	0f 90       	pop	r0
    1708:	df 91       	pop	r29
    170a:	cf 91       	pop	r28
    170c:	08 95       	ret

0000170e <lib_aci_send_data>:
    170e:	1f 93       	push	r17
    1710:	cf 93       	push	r28
    1712:	df 93       	push	r29
    1714:	cd b7       	in	r28, 0x3d	; 61
    1716:	de b7       	in	r29, 0x3e	; 62
    1718:	65 97       	sbiw	r28, 0x15	; 21
    171a:	0f b6       	in	r0, 0x3f	; 63
    171c:	f8 94       	cli
    171e:	de bf       	out	0x3e, r29	; 62
    1720:	0f be       	out	0x3f, r0	; 63
    1722:	cd bf       	out	0x3d, r28	; 61
    1724:	28 2f       	mov	r18, r24
    1726:	30 e0       	ldi	r19, 0x00	; 0
    1728:	f9 01       	movw	r30, r18
    172a:	ee 0f       	add	r30, r30
    172c:	ff 1f       	adc	r31, r31
    172e:	2e 0f       	add	r18, r30
    1730:	3f 1f       	adc	r19, r31
    1732:	e0 91 2d 09 	lds	r30, 0x092D	; 0x80092d <p_services_pipe_type_map>
    1736:	f0 91 2e 09 	lds	r31, 0x092E	; 0x80092e <p_services_pipe_type_map+0x1>
    173a:	e2 0f       	add	r30, r18
    173c:	f3 1f       	adc	r31, r19
    173e:	33 97       	sbiw	r30, 0x03	; 3
    1740:	21 81       	ldd	r18, Z+1	; 0x01
    1742:	32 81       	ldd	r19, Z+2	; 0x02
    1744:	22 30       	cpi	r18, 0x02	; 2
    1746:	31 05       	cpc	r19, r1
    1748:	19 f0       	breq	.+6      	; 0x1750 <lib_aci_send_data+0x42>
    174a:	24 30       	cpi	r18, 0x04	; 4
    174c:	31 05       	cpc	r19, r1
    174e:	99 f4       	brne	.+38     	; 0x1776 <lib_aci_send_data+0x68>
    1750:	45 31       	cpi	r20, 0x15	; 21
    1752:	98 f4       	brcc	.+38     	; 0x177a <lib_aci_send_data+0x6c>
    1754:	14 2f       	mov	r17, r20
    1756:	89 83       	std	Y+1, r24	; 0x01
    1758:	50 e0       	ldi	r21, 0x00	; 0
    175a:	ce 01       	movw	r24, r28
    175c:	02 96       	adiw	r24, 0x02	; 2
    175e:	da d7       	rcall	.+4020   	; 0x2714 <memcpy>
    1760:	41 2f       	mov	r20, r17
    1762:	be 01       	movw	r22, r28
    1764:	6f 5f       	subi	r22, 0xFF	; 255
    1766:	7f 4f       	sbci	r23, 0xFF	; 255
    1768:	8e e3       	ldi	r24, 0x3E	; 62
    176a:	9a e0       	ldi	r25, 0x0A	; 10
    176c:	a6 db       	rcall	.-2228   	; 0xeba <acil_encode_cmd_send_data>
    176e:	8d e3       	ldi	r24, 0x3D	; 61
    1770:	9a e0       	ldi	r25, 0x0A	; 10
    1772:	e3 de       	rcall	.-570    	; 0x153a <hal_aci_tl_send>
    1774:	03 c0       	rjmp	.+6      	; 0x177c <lib_aci_send_data+0x6e>
    1776:	80 e0       	ldi	r24, 0x00	; 0
    1778:	01 c0       	rjmp	.+2      	; 0x177c <lib_aci_send_data+0x6e>
    177a:	80 e0       	ldi	r24, 0x00	; 0
    177c:	65 96       	adiw	r28, 0x15	; 21
    177e:	0f b6       	in	r0, 0x3f	; 63
    1780:	f8 94       	cli
    1782:	de bf       	out	0x3e, r29	; 62
    1784:	0f be       	out	0x3f, r0	; 63
    1786:	cd bf       	out	0x3d, r28	; 61
    1788:	df 91       	pop	r29
    178a:	cf 91       	pop	r28
    178c:	1f 91       	pop	r17
    178e:	08 95       	ret

00001790 <lib_aci_change_timing_GAP_PPCP>:
    1790:	8e e3       	ldi	r24, 0x3E	; 62
    1792:	9a e0       	ldi	r25, 0x0A	; 10
    1794:	ab db       	rcall	.-2218   	; 0xeec <acil_encode_cmd_change_timing_req_GAP_PPCP>
    1796:	8d e3       	ldi	r24, 0x3D	; 61
    1798:	9a e0       	ldi	r25, 0x0A	; 10
    179a:	cf ce       	rjmp	.-610    	; 0x153a <hal_aci_tl_send>
    179c:	08 95       	ret

0000179e <lib_aci_event_peek>:
    179e:	4c ce       	rjmp	.-872    	; 0x1438 <hal_aci_tl_event_peek>
    17a0:	08 95       	ret

000017a2 <lib_aci_event_get>:
    17a2:	ff 92       	push	r15
    17a4:	0f 93       	push	r16
    17a6:	1f 93       	push	r17
    17a8:	cf 93       	push	r28
    17aa:	df 93       	push	r29
    17ac:	8c 01       	movw	r16, r24
    17ae:	eb 01       	movw	r28, r22
    17b0:	8f e4       	ldi	r24, 0x4F	; 79
    17b2:	97 e0       	ldi	r25, 0x07	; 7
    17b4:	0e 94 6e 03 	call	0x6dc	; 0x6dc <Serial_SendString>
    17b8:	ce 01       	movw	r24, r28
    17ba:	49 de       	rcall	.-878    	; 0x144e <hal_aci_tl_event_get>
    17bc:	f8 2e       	mov	r15, r24
    17be:	88 23       	and	r24, r24
    17c0:	09 f4       	brne	.+2      	; 0x17c4 <lib_aci_event_get+0x22>
    17c2:	48 c0       	rjmp	.+144    	; 0x1854 <lib_aci_event_get+0xb2>
    17c4:	88 e6       	ldi	r24, 0x68	; 104
    17c6:	97 e0       	ldi	r25, 0x07	; 7
    17c8:	0e 94 6e 03 	call	0x6dc	; 0x6dc <Serial_SendString>
    17cc:	8a 81       	ldd	r24, Y+2	; 0x02
    17ce:	86 38       	cpi	r24, 0x86	; 134
    17d0:	c1 f0       	breq	.+48     	; 0x1802 <lib_aci_event_get+0x60>
    17d2:	18 f4       	brcc	.+6      	; 0x17da <lib_aci_event_get+0x38>
    17d4:	85 38       	cpi	r24, 0x85	; 133
    17d6:	89 f1       	breq	.+98     	; 0x183a <lib_aci_event_get+0x98>
    17d8:	3d c0       	rjmp	.+122    	; 0x1854 <lib_aci_event_get+0xb2>
    17da:	88 38       	cpi	r24, 0x88	; 136
    17dc:	19 f0       	breq	.+6      	; 0x17e4 <lib_aci_event_get+0x42>
    17de:	89 38       	cpi	r24, 0x89	; 137
    17e0:	f1 f0       	breq	.+60     	; 0x181e <lib_aci_event_get+0x7c>
    17e2:	38 c0       	rjmp	.+112    	; 0x1854 <lib_aci_event_get+0xb2>
    17e4:	fe 01       	movw	r30, r28
    17e6:	33 96       	adiw	r30, 0x03	; 3
    17e8:	d8 01       	movw	r26, r16
    17ea:	5c 96       	adiw	r26, 0x1c	; 28
    17ec:	2b 96       	adiw	r28, 0x0b	; 11
    17ee:	81 91       	ld	r24, Z+
    17f0:	8d 93       	st	X+, r24
    17f2:	87 81       	ldd	r24, Z+7	; 0x07
    17f4:	17 96       	adiw	r26, 0x07	; 7
    17f6:	8c 93       	st	X, r24
    17f8:	17 97       	sbiw	r26, 0x07	; 7
    17fa:	ec 17       	cp	r30, r28
    17fc:	fd 07       	cpc	r31, r29
    17fe:	b9 f7       	brne	.-18     	; 0x17ee <lib_aci_event_get+0x4c>
    1800:	29 c0       	rjmp	.+82     	; 0x1854 <lib_aci_event_get+0xb2>
    1802:	f8 01       	movw	r30, r16
    1804:	7c 96       	adiw	r30, 0x1c	; 28
    1806:	c8 01       	movw	r24, r16
    1808:	84 96       	adiw	r24, 0x24	; 36
    180a:	11 92       	st	Z+, r1
    180c:	17 82       	std	Z+7, r1	; 0x07
    180e:	8e 17       	cp	r24, r30
    1810:	9f 07       	cpc	r25, r31
    1812:	d9 f7       	brne	.-10     	; 0x180a <lib_aci_event_get+0x68>
    1814:	f8 01       	movw	r30, r16
    1816:	14 a6       	std	Z+44, r1	; 0x2c
    1818:	83 89       	ldd	r24, Z+19	; 0x13
    181a:	85 8b       	std	Z+21, r24	; 0x15
    181c:	1b c0       	rjmp	.+54     	; 0x1854 <lib_aci_event_get+0xb2>
    181e:	8b 81       	ldd	r24, Y+3	; 0x03
    1820:	9c 81       	ldd	r25, Y+4	; 0x04
    1822:	f8 01       	movw	r30, r16
    1824:	97 8b       	std	Z+23, r25	; 0x17
    1826:	86 8b       	std	Z+22, r24	; 0x16
    1828:	8d 81       	ldd	r24, Y+5	; 0x05
    182a:	9e 81       	ldd	r25, Y+6	; 0x06
    182c:	91 8f       	std	Z+25, r25	; 0x19
    182e:	80 8f       	std	Z+24, r24	; 0x18
    1830:	8f 81       	ldd	r24, Y+7	; 0x07
    1832:	98 85       	ldd	r25, Y+8	; 0x08
    1834:	93 8f       	std	Z+27, r25	; 0x1b
    1836:	82 8f       	std	Z+26, r24	; 0x1a
    1838:	0d c0       	rjmp	.+26     	; 0x1854 <lib_aci_event_get+0xb2>
    183a:	8a 85       	ldd	r24, Y+10	; 0x0a
    183c:	9b 85       	ldd	r25, Y+11	; 0x0b
    183e:	f8 01       	movw	r30, r16
    1840:	97 8b       	std	Z+23, r25	; 0x17
    1842:	86 8b       	std	Z+22, r24	; 0x16
    1844:	8c 85       	ldd	r24, Y+12	; 0x0c
    1846:	9d 85       	ldd	r25, Y+13	; 0x0d
    1848:	91 8f       	std	Z+25, r25	; 0x19
    184a:	80 8f       	std	Z+24, r24	; 0x18
    184c:	8e 85       	ldd	r24, Y+14	; 0x0e
    184e:	9f 85       	ldd	r25, Y+15	; 0x0f
    1850:	93 8f       	std	Z+27, r25	; 0x1b
    1852:	82 8f       	std	Z+26, r24	; 0x1a
    1854:	8f 2d       	mov	r24, r15
    1856:	df 91       	pop	r29
    1858:	cf 91       	pop	r28
    185a:	1f 91       	pop	r17
    185c:	0f 91       	pop	r16
    185e:	ff 90       	pop	r15
    1860:	08 95       	ret

00001862 <lib_aci_board_init>:
    1862:	cf 93       	push	r28
    1864:	df 93       	push	r29
    1866:	fc 01       	movw	r30, r24
    1868:	20 81       	ld	r18, Z
    186a:	21 30       	cpi	r18, 0x01	; 1
    186c:	09 f0       	breq	.+2      	; 0x1870 <lib_aci_board_init+0xe>
    186e:	5d c0       	rjmp	.+186    	; 0x192a <lib_aci_board_init+0xc8>
    1870:	ec 01       	movw	r28, r24
    1872:	ff ef       	ldi	r31, 0xFF	; 255
    1874:	21 ee       	ldi	r18, 0xE1	; 225
    1876:	84 e0       	ldi	r24, 0x04	; 4
    1878:	f1 50       	subi	r31, 0x01	; 1
    187a:	20 40       	sbci	r18, 0x00	; 0
    187c:	80 40       	sbci	r24, 0x00	; 0
    187e:	e1 f7       	brne	.-8      	; 0x1878 <lib_aci_board_init+0x16>
    1880:	00 c0       	rjmp	.+0      	; 0x1882 <lib_aci_board_init+0x20>
    1882:	00 00       	nop
    1884:	9e de       	rcall	.-708    	; 0x15c2 <lib_aci_radio_reset>
    1886:	6d e3       	ldi	r22, 0x3D	; 61
    1888:	7a e0       	ldi	r23, 0x0A	; 10
    188a:	ce 01       	movw	r24, r28
    188c:	8a df       	rcall	.-236    	; 0x17a2 <lib_aci_event_get>
    188e:	88 23       	and	r24, r24
    1890:	d1 f3       	breq	.-12     	; 0x1886 <lib_aci_board_init+0x24>
    1892:	80 91 3f 0a 	lds	r24, 0x0A3F	; 0x800a3f <msg_to_send+0x2>
    1896:	84 38       	cpi	r24, 0x84	; 132
    1898:	09 f0       	breq	.+2      	; 0x189c <lib_aci_board_init+0x3a>
    189a:	42 c0       	rjmp	.+132    	; 0x1920 <lib_aci_board_init+0xbe>
    189c:	80 91 41 0a 	lds	r24, 0x0A41	; 0x800a41 <msg_to_send+0x4>
    18a0:	83 38       	cpi	r24, 0x83	; 131
    18a2:	99 f4       	brne	.+38     	; 0x18ca <lib_aci_board_init+0x68>
    18a4:	88 e8       	ldi	r24, 0x88	; 136
    18a6:	97 e0       	ldi	r25, 0x07	; 7
    18a8:	0e 94 6e 03 	call	0x6dc	; 0x6dc <Serial_SendString>
    18ac:	ed e3       	ldi	r30, 0x3D	; 61
    18ae:	fa e0       	ldi	r31, 0x0A	; 10
    18b0:	84 e0       	ldi	r24, 0x04	; 4
    18b2:	81 83       	std	Z+1, r24	; 0x01
    18b4:	81 e8       	ldi	r24, 0x81	; 129
    18b6:	82 83       	std	Z+2, r24	; 0x02
    18b8:	82 e0       	ldi	r24, 0x02	; 2
    18ba:	83 83       	std	Z+3, r24	; 0x03
    18bc:	14 82       	std	Z+4, r1	; 0x04
    18be:	85 83       	std	Z+5, r24	; 0x05
    18c0:	bf 01       	movw	r22, r30
    18c2:	81 e3       	ldi	r24, 0x31	; 49
    18c4:	99 e0       	ldi	r25, 0x09	; 9
    18c6:	aa db       	rcall	.-2220   	; 0x101c <aci_queue_enqueue>
    18c8:	30 c0       	rjmp	.+96     	; 0x192a <lib_aci_board_init+0xc8>
    18ca:	81 11       	cpse	r24, r1
    18cc:	14 c0       	rjmp	.+40     	; 0x18f6 <lib_aci_board_init+0x94>
    18ce:	8f ea       	ldi	r24, 0xAF	; 175
    18d0:	97 e0       	ldi	r25, 0x07	; 7
    18d2:	0e 94 6e 03 	call	0x6dc	; 0x6dc <Serial_SendString>
    18d6:	ed e3       	ldi	r30, 0x3D	; 61
    18d8:	fa e0       	ldi	r31, 0x0A	; 10
    18da:	84 e0       	ldi	r24, 0x04	; 4
    18dc:	81 83       	std	Z+1, r24	; 0x01
    18de:	81 e8       	ldi	r24, 0x81	; 129
    18e0:	82 83       	std	Z+2, r24	; 0x02
    18e2:	83 e0       	ldi	r24, 0x03	; 3
    18e4:	83 83       	std	Z+3, r24	; 0x03
    18e6:	14 82       	std	Z+4, r1	; 0x04
    18e8:	82 e0       	ldi	r24, 0x02	; 2
    18ea:	85 83       	std	Z+5, r24	; 0x05
    18ec:	bf 01       	movw	r22, r30
    18ee:	81 e3       	ldi	r24, 0x31	; 49
    18f0:	99 e0       	ldi	r25, 0x09	; 9
    18f2:	94 db       	rcall	.-2264   	; 0x101c <aci_queue_enqueue>
    18f4:	1a c0       	rjmp	.+52     	; 0x192a <lib_aci_board_init+0xc8>
    18f6:	82 38       	cpi	r24, 0x82	; 130
    18f8:	c1 f4       	brne	.+48     	; 0x192a <lib_aci_board_init+0xc8>
    18fa:	85 ed       	ldi	r24, 0xD5	; 213
    18fc:	97 e0       	ldi	r25, 0x07	; 7
    18fe:	0e 94 6e 03 	call	0x6dc	; 0x6dc <Serial_SendString>
    1902:	ed e3       	ldi	r30, 0x3D	; 61
    1904:	fa e0       	ldi	r31, 0x0A	; 10
    1906:	84 e0       	ldi	r24, 0x04	; 4
    1908:	81 83       	std	Z+1, r24	; 0x01
    190a:	81 e8       	ldi	r24, 0x81	; 129
    190c:	82 83       	std	Z+2, r24	; 0x02
    190e:	81 e0       	ldi	r24, 0x01	; 1
    1910:	83 83       	std	Z+3, r24	; 0x03
    1912:	14 82       	std	Z+4, r1	; 0x04
    1914:	15 82       	std	Z+5, r1	; 0x05
    1916:	bf 01       	movw	r22, r30
    1918:	81 e3       	ldi	r24, 0x31	; 49
    191a:	99 e0       	ldi	r25, 0x09	; 9
    191c:	7f db       	rcall	.-2306   	; 0x101c <aci_queue_enqueue>
    191e:	05 c0       	rjmp	.+10     	; 0x192a <lib_aci_board_init+0xc8>
    1920:	88 ef       	ldi	r24, 0xF8	; 248
    1922:	97 e0       	ldi	r25, 0x07	; 7
    1924:	0e 94 6e 03 	call	0x6dc	; 0x6dc <Serial_SendString>
    1928:	ae cf       	rjmp	.-164    	; 0x1886 <lib_aci_board_init+0x24>
    192a:	df 91       	pop	r29
    192c:	cf 91       	pop	r28
    192e:	08 95       	ret

00001930 <lib_aci_init>:
    1930:	bf 92       	push	r11
    1932:	cf 92       	push	r12
    1934:	df 92       	push	r13
    1936:	ef 92       	push	r14
    1938:	ff 92       	push	r15
    193a:	0f 93       	push	r16
    193c:	1f 93       	push	r17
    193e:	cf 93       	push	r28
    1940:	df 93       	push	r29
    1942:	6c 01       	movw	r12, r24
    1944:	b6 2e       	mov	r11, r22
    1946:	8c 01       	movw	r16, r24
    1948:	04 5e       	subi	r16, 0xE4	; 228
    194a:	1f 4f       	sbci	r17, 0xFF	; 255
    194c:	c5 e2       	ldi	r28, 0x25	; 37
    194e:	d9 e0       	ldi	r29, 0x09	; 9
    1950:	0f 2e       	mov	r0, r31
    1952:	fd e2       	ldi	r31, 0x2D	; 45
    1954:	ef 2e       	mov	r14, r31
    1956:	f9 e0       	ldi	r31, 0x09	; 9
    1958:	ff 2e       	mov	r15, r31
    195a:	f0 2d       	mov	r31, r0
    195c:	85 e1       	ldi	r24, 0x15	; 21
    195e:	98 e0       	ldi	r25, 0x08	; 8
    1960:	0e 94 6e 03 	call	0x6dc	; 0x6dc <Serial_SendString>
    1964:	f8 01       	movw	r30, r16
    1966:	11 92       	st	Z+, r1
    1968:	8f 01       	movw	r16, r30
    196a:	17 82       	std	Z+7, r1	; 0x07
    196c:	19 92       	st	Y+, r1
    196e:	ce 15       	cp	r28, r14
    1970:	df 05       	cpc	r29, r15
    1972:	a1 f7       	brne	.-24     	; 0x195c <lib_aci_init+0x2c>
    1974:	f6 01       	movw	r30, r12
    1976:	84 85       	ldd	r24, Z+12	; 0x0c
    1978:	95 85       	ldd	r25, Z+13	; 0x0d
    197a:	90 93 2e 09 	sts	0x092E, r25	; 0x80092e <p_services_pipe_type_map+0x1>
    197e:	80 93 2d 09 	sts	0x092D, r24	; 0x80092d <p_services_pipe_type_map>
    1982:	6b 2d       	mov	r22, r11
    1984:	c6 01       	movw	r24, r12
    1986:	94 dd       	rcall	.-1240   	; 0x14b0 <hal_aci_tl_init>
    1988:	c6 01       	movw	r24, r12
    198a:	6b df       	rcall	.-298    	; 0x1862 <lib_aci_board_init>
    198c:	df 91       	pop	r29
    198e:	cf 91       	pop	r28
    1990:	1f 91       	pop	r17
    1992:	0f 91       	pop	r16
    1994:	ff 90       	pop	r15
    1996:	ef 90       	pop	r14
    1998:	df 90       	pop	r13
    199a:	cf 90       	pop	r12
    199c:	bf 90       	pop	r11
    199e:	08 95       	ret

000019a0 <lib_aci_read_dynamic_data>:
    19a0:	8e e3       	ldi	r24, 0x3E	; 62
    19a2:	9a e0       	ldi	r25, 0x0A	; 10
    19a4:	9d da       	rcall	.-2758   	; 0xee0 <acil_encode_cmd_read_dynamic_data>
    19a6:	8d e3       	ldi	r24, 0x3D	; 61
    19a8:	9a e0       	ldi	r25, 0x0A	; 10
    19aa:	c7 cd       	rjmp	.-1138   	; 0x153a <hal_aci_tl_send>
    19ac:	08 95       	ret

000019ae <lib_aci_command_queue_empty>:

bool lib_aci_command_queue_empty(void)
{
    19ae:	ed cd       	rjmp	.-1062   	; 0x158a <hal_aci_tl_tx_q_empty>
    19b0:	08 95       	ret

000019b2 <SetupHardware>:
/** Configures the board hardware and chip peripherals for the demo's functionality. */
void SetupHardware(void)
{
#if (ARCH == ARCH_AVR8)
	/* Disable watchdog if enabled by bootloader/fuses */
	MCUSR &= ~(1 << WDRF);
    19b2:	84 b7       	in	r24, 0x34	; 52
    19b4:	87 7f       	andi	r24, 0xF7	; 247
    19b6:	84 bf       	out	0x34, r24	; 52
    19b8:	0f b6       	in	r0, 0x3f	; 63
    19ba:	f8 94       	cli
    19bc:	a8 95       	wdr
    19be:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__TEXT_REGION_LENGTH__+0x7e0060>
    19c2:	88 61       	ori	r24, 0x18	; 24
    19c4:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__TEXT_REGION_LENGTH__+0x7e0060>
    19c8:	10 92 60 00 	sts	0x0060, r1	; 0x800060 <__TEXT_REGION_LENGTH__+0x7e0060>
    19cc:	0f be       	out	0x3f, r0	; 63
from 1 to 129. Thus, one does not need to use \c clock_div_t type as argument.
*/
void clock_prescale_set(clock_div_t __x)
{
    uint8_t __tmp = _BV(CLKPCE);
    __asm__ __volatile__ (
    19ce:	90 e0       	ldi	r25, 0x00	; 0
    19d0:	80 e8       	ldi	r24, 0x80	; 128
    19d2:	0f b6       	in	r0, 0x3f	; 63
    19d4:	f8 94       	cli
    19d6:	80 93 61 00 	sts	0x0061, r24	; 0x800061 <__TEXT_REGION_LENGTH__+0x7e0061>
    19da:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__TEXT_REGION_LENGTH__+0x7e0061>
    19de:	0f be       	out	0x3f, r0	; 63
			#define JOY_RX			ADC_GetChannelReading(ADC_REFERENCE_AVCC | ADC_RIGHT_ADJUSTED | ADC_CHANNEL6 )
			#define JOY_RY			ADC_GetChannelReading(ADC_REFERENCE_AVCC | ADC_RIGHT_ADJUSTED | ADC_CHANNEL5 )
			
			static inline void       Joystick_Init(void) 
			{
				DDRF &= ~JOY_MASK;
    19e0:	84 98       	cbi	0x10, 4	; 16
				PORTF |=  JOY_MASK;
    19e2:	8c 9a       	sbi	0x11, 4	; 17
			 *  \param[in] Mode  Mask of ADC prescale and mode settings.
			 */
			static inline void ADC_Init(const uint8_t Mode) ATTR_ALWAYS_INLINE;
			static inline void ADC_Init(const uint8_t Mode)
			{
				ADCSRA = ((1 << ADEN) | Mode);
    19e4:	86 e8       	ldi	r24, 0x86	; 134
    19e6:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
		#include "../../Common/Common.h"

		#if (BOARD == BOARD_NONE)
			static inline void       LEDs_Init(void) 
			{
				DDRE  |=  LEDS_ALL_LEDS;
    19ea:	8d b1       	in	r24, 0x0d	; 13
    19ec:	80 6f       	ori	r24, 0xF0	; 240
    19ee:	8d b9       	out	0x0d, r24	; 13
				PORTE &= ~LEDS_ALL_LEDS;				
    19f0:	8e b1       	in	r24, 0x0e	; 14
    19f2:	8f 70       	andi	r24, 0x0F	; 15
    19f4:	8e b9       	out	0x0e, r24	; 14
			//#define BUTTONS_UP			(1 << 0)
			//#define BUTTONS_DOWN		(1 << 1)
						
			static inline void       Buttons_Init(void) 
			{
				DDRD  &= ~BUTTONS_MASK;
    19f6:	8a b1       	in	r24, 0x0a	; 10
    19f8:	1a b8       	out	0x0a, r1	; 10
				PORTD |=  BUTTONS_MASK;
    19fa:	8b b1       	in	r24, 0x0b	; 11
    19fc:	8f ef       	ldi	r24, 0xFF	; 255

	/* Hardware Initialization */
	Joystick_Init();
	LEDs_Init();
	Buttons_Init();
	USB_Init();
    19fe:	8b b9       	out	0x0b, r24	; 11
			static inline void Serial_Init(const uint32_t BaudRate,
			                               const bool DoubleSpeed);
			static inline void Serial_Init(const uint32_t BaudRate,
			                               const bool DoubleSpeed)
			{
				UBRR1  = (DoubleSpeed ? SERIAL_2X_UBBRVAL(BaudRate) : SERIAL_UBBRVAL(BaudRate));
    1a00:	0e d4       	rcall	.+2076   	; 0x221e <USB_Init>
    1a02:	87 e6       	ldi	r24, 0x67	; 103
    1a04:	90 e0       	ldi	r25, 0x00	; 0
    1a06:	90 93 cd 00 	sts	0x00CD, r25	; 0x8000cd <__TEXT_REGION_LENGTH__+0x7e00cd>
    1a0a:	80 93 cc 00 	sts	0x00CC, r24	; 0x8000cc <__TEXT_REGION_LENGTH__+0x7e00cc>

				UCSR1C = ((1 << UCSZ11) | (1 << UCSZ10));
    1a0e:	86 e0       	ldi	r24, 0x06	; 6
    1a10:	80 93 ca 00 	sts	0x00CA, r24	; 0x8000ca <__TEXT_REGION_LENGTH__+0x7e00ca>
				UCSR1A = (DoubleSpeed ? (1 << U2X1) : 0);
    1a14:	10 92 c8 00 	sts	0x00C8, r1	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7e00c8>
				UCSR1B = ((1 << TXEN1)  | (1 << RXEN1));
    1a18:	88 e1       	ldi	r24, 0x18	; 24
    1a1a:	80 93 c9 00 	sts	0x00C9, r24	; 0x8000c9 <__TEXT_REGION_LENGTH__+0x7e00c9>

				DDRD  |= (1 << 3);
				PORTD |= (1 << 2);
    1a1e:	53 9a       	sbi	0x0a, 3	; 10
    1a20:	5a 9a       	sbi	0x0b, 2	; 11
    1a22:	08 95       	ret

00001a24 <EVENT_USB_Device_Connect>:
			{
				PORTE &= ~LedMask;				
			}
			static inline void       LEDs_SetAllLEDs(const uint_reg_t LEDMask) 
			{
				PORTE = ((PORTE & ~LEDS_ALL_LEDS) | LedMask);				
    1a24:	8e b1       	in	r24, 0x0e	; 14
    1a26:	80 6f       	ori	r24, 0xF0	; 240
    1a28:	8e b9       	out	0x0e, r24	; 14
    1a2a:	08 95       	ret

00001a2c <EVENT_USB_Device_Disconnect>:
    1a2c:	8e b1       	in	r24, 0x0e	; 14
    1a2e:	80 6f       	ori	r24, 0xF0	; 240
    1a30:	8e b9       	out	0x0e, r24	; 14
    1a32:	08 95       	ret

00001a34 <EVENT_USB_Device_ConfigurationChanged>:
				uint8_t Number = (Address & ENDPOINT_EPNUM_MASK);

				if (Number >= ENDPOINT_TOTAL_ENDPOINTS)
				  return false;

				return Endpoint_ConfigureEndpoint_Prv(Number,
    1a34:	42 e1       	ldi	r20, 0x12	; 18
    1a36:	61 ec       	ldi	r22, 0xC1	; 193
    1a38:	81 e0       	ldi	r24, 0x01	; 1
    1a3a:	e6 d2       	rcall	.+1484   	; 0x2008 <Endpoint_ConfigureEndpoint_Prv>
    1a3c:	8e b1       	in	r24, 0x0e	; 14
    1a3e:	80 6f       	ori	r24, 0xF0	; 240
    1a40:	8e b9       	out	0x0e, r24	; 14
    1a42:	08 95       	ret

00001a44 <GetNextReport>:
 *  \param[out] ReportData  Pointer to a HID report data structure to be filled
 *
 *  \return Boolean \c true if the new report differs from the last report, \c false otherwise
 */
bool GetNextReport(USB_JoystickReport_Data_t* const ReportData)
{
    1a44:	0f 93       	push	r16
    1a46:	1f 93       	push	r17
    1a48:	cf 93       	push	r28
    1a4a:	8c 01       	movw	r16, r24
				PORTD |=  BUTTONS_BUTTON4;
				*/
			}
			static inline uint_reg_t Buttons_GetStatus(void) 
			{
				return ((PIND & BUTTONS_MASK) ^ BUTTONS_MASK);				
    1a4c:	c9 b1       	in	r28, 0x09	; 9
    1a4e:	c0 95       	com	r28
	uint8_t        ButtonStatus_LCL = Buttons_GetStatus();
	bool           InputChanged     = false;
	int8_t			HatMask			= 0;

	/* Clear the report contents */
	memset(ReportData, 0, sizeof(USB_JoystickReport_Data_t));
    1a50:	8b e0       	ldi	r24, 0x0B	; 11
    1a52:	d8 01       	movw	r26, r16
    1a54:	1d 92       	st	X+, r1
    1a56:	8a 95       	dec	r24
    1a58:	e9 f7       	brne	.-6      	; 0x1a54 <GetNextReport+0x10>
	Serial_SendString("I made it to the start of the report collection\r\n");
    1a5a:	81 e3       	ldi	r24, 0x31	; 49
    1a5c:	98 e0       	ldi	r25, 0x08	; 8
    1a5e:	0e 94 6e 03 	call	0x6dc	; 0x6dc <Serial_SendString>
			 *
			 *  \param[in] MUXMask  ADC channel mask, reference mask and adjustment mask.
			 */
			static inline void ADC_StartReading(const uint16_t MUXMask)
			{
				ADMUX = MUXMask;
    1a62:	81 e4       	ldi	r24, 0x41	; 65
    1a64:	80 93 7c 00 	sts	0x007C, r24	; 0x80007c <__TEXT_REGION_LENGTH__+0x7e007c>

				#if (defined(__AVR_ATmega16U4__)  || defined(__AVR_ATmega32U4__) || defined(__DOXYGEN__))
				if (MUXMask & (1 << 8))
				  ADCSRB |=  (1 << MUX5);
				else
				  ADCSRB &= ~(1 << MUX5);
    1a68:	eb e7       	ldi	r30, 0x7B	; 123
    1a6a:	f0 e0       	ldi	r31, 0x00	; 0
    1a6c:	80 81       	ld	r24, Z
    1a6e:	8f 7d       	andi	r24, 0xDF	; 223
    1a70:	80 83       	st	Z, r24
				#endif

				ADCSRA |= (1 << ADSC);
    1a72:	ea e7       	ldi	r30, 0x7A	; 122
    1a74:	f0 e0       	ldi	r31, 0x00	; 0
    1a76:	80 81       	ld	r24, Z
    1a78:	80 64       	ori	r24, 0x40	; 64
    1a7a:	80 83       	st	Z, r24
			 *          complete and ready to be read out with \ref ADC_GetResult().
			 */
			static inline bool ADC_IsReadingComplete(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool ADC_IsReadingComplete(void)
			{
				return ((ADCSRA & (1 << ADIF)) ? true : false);
    1a7c:	80 81       	ld	r24, Z
			static inline uint16_t ADC_GetChannelReading(const uint16_t MUXMask) ATTR_WARN_UNUSED_RESULT;
			static inline uint16_t ADC_GetChannelReading(const uint16_t MUXMask)
			{
				ADC_StartReading(MUXMask);

				while (!(ADC_IsReadingComplete()));
    1a7e:	84 ff       	sbrs	r24, 4
    1a80:	fd cf       	rjmp	.-6      	; 0x1a7c <GetNextReport+0x38>
			 *  \return The result of the last ADC conversion as an unsigned value.
			 */
			static inline uint16_t ADC_GetResult(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t ADC_GetResult(void)
			{
				ADCSRA |= (1 << ADIF);
    1a82:	ea e7       	ldi	r30, 0x7A	; 122
    1a84:	f0 e0       	ldi	r31, 0x00	; 0
    1a86:	80 81       	ld	r24, Z
    1a88:	80 61       	ori	r24, 0x10	; 16
    1a8a:	80 83       	st	Z, r24
				return ADC;
    1a8c:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7e0078>
    1a90:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7e0079>
	//Send Left Stick X-Axis ADC Reading to Y in Report Data, axis inverted with 9-bit for signed int 
	ReportData->X = (JOY_X ^ 0x3FF);
    1a94:	80 95       	com	r24
    1a96:	b3 e0       	ldi	r27, 0x03	; 3
    1a98:	9b 27       	eor	r25, r27
    1a9a:	d8 01       	movw	r26, r16
    1a9c:	8d 93       	st	X+, r24
    1a9e:	9c 93       	st	X, r25
			 *
			 *  \param[in] MUXMask  ADC channel mask, reference mask and adjustment mask.
			 */
			static inline void ADC_StartReading(const uint16_t MUXMask)
			{
				ADMUX = MUXMask;
    1aa0:	80 e4       	ldi	r24, 0x40	; 64
    1aa2:	80 93 7c 00 	sts	0x007C, r24	; 0x80007c <__TEXT_REGION_LENGTH__+0x7e007c>

				#if (defined(__AVR_ATmega16U4__)  || defined(__AVR_ATmega32U4__) || defined(__DOXYGEN__))
				if (MUXMask & (1 << 8))
				  ADCSRB |=  (1 << MUX5);
				else
				  ADCSRB &= ~(1 << MUX5);
    1aa6:	ab e7       	ldi	r26, 0x7B	; 123
    1aa8:	b0 e0       	ldi	r27, 0x00	; 0
    1aaa:	8c 91       	ld	r24, X
    1aac:	8f 7d       	andi	r24, 0xDF	; 223
    1aae:	8c 93       	st	X, r24
				#endif

				ADCSRA |= (1 << ADSC);
    1ab0:	80 81       	ld	r24, Z
    1ab2:	80 64       	ori	r24, 0x40	; 64
    1ab4:	80 83       	st	Z, r24
			 *          complete and ready to be read out with \ref ADC_GetResult().
			 */
			static inline bool ADC_IsReadingComplete(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool ADC_IsReadingComplete(void)
			{
				return ((ADCSRA & (1 << ADIF)) ? true : false);
    1ab6:	80 81       	ld	r24, Z
			static inline uint16_t ADC_GetChannelReading(const uint16_t MUXMask) ATTR_WARN_UNUSED_RESULT;
			static inline uint16_t ADC_GetChannelReading(const uint16_t MUXMask)
			{
				ADC_StartReading(MUXMask);

				while (!(ADC_IsReadingComplete()));
    1ab8:	84 ff       	sbrs	r24, 4
    1aba:	fd cf       	rjmp	.-6      	; 0x1ab6 <GetNextReport+0x72>
			 *  \return The result of the last ADC conversion as an unsigned value.
			 */
			static inline uint16_t ADC_GetResult(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t ADC_GetResult(void)
			{
				ADCSRA |= (1 << ADIF);
    1abc:	ea e7       	ldi	r30, 0x7A	; 122
    1abe:	f0 e0       	ldi	r31, 0x00	; 0
    1ac0:	80 81       	ld	r24, Z
    1ac2:	80 61       	ori	r24, 0x10	; 16
    1ac4:	80 83       	st	Z, r24
				return ADC;
    1ac6:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7e0078>
    1aca:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7e0079>
	
	//Send Left Stick Y-Axis ADC Reading to X in Report Data
	ReportData->Y = JOY_Y;
    1ace:	d8 01       	movw	r26, r16
    1ad0:	13 96       	adiw	r26, 0x03	; 3
    1ad2:	9c 93       	st	X, r25
    1ad4:	8e 93       	st	-X, r24
    1ad6:	12 97       	sbiw	r26, 0x02	; 2
			 *
			 *  \param[in] MUXMask  ADC channel mask, reference mask and adjustment mask.
			 */
			static inline void ADC_StartReading(const uint16_t MUXMask)
			{
				ADMUX = MUXMask;
    1ad8:	86 e4       	ldi	r24, 0x46	; 70
    1ada:	80 93 7c 00 	sts	0x007C, r24	; 0x80007c <__TEXT_REGION_LENGTH__+0x7e007c>

				#if (defined(__AVR_ATmega16U4__)  || defined(__AVR_ATmega32U4__) || defined(__DOXYGEN__))
				if (MUXMask & (1 << 8))
				  ADCSRB |=  (1 << MUX5);
				else
				  ADCSRB &= ~(1 << MUX5);
    1ade:	ab e7       	ldi	r26, 0x7B	; 123
    1ae0:	b0 e0       	ldi	r27, 0x00	; 0
    1ae2:	8c 91       	ld	r24, X
    1ae4:	8f 7d       	andi	r24, 0xDF	; 223
    1ae6:	8c 93       	st	X, r24
				#endif

				ADCSRA |= (1 << ADSC);
    1ae8:	80 81       	ld	r24, Z
    1aea:	80 64       	ori	r24, 0x40	; 64
    1aec:	80 83       	st	Z, r24
			 *          complete and ready to be read out with \ref ADC_GetResult().
			 */
			static inline bool ADC_IsReadingComplete(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool ADC_IsReadingComplete(void)
			{
				return ((ADCSRA & (1 << ADIF)) ? true : false);
    1aee:	80 81       	ld	r24, Z
			static inline uint16_t ADC_GetChannelReading(const uint16_t MUXMask) ATTR_WARN_UNUSED_RESULT;
			static inline uint16_t ADC_GetChannelReading(const uint16_t MUXMask)
			{
				ADC_StartReading(MUXMask);

				while (!(ADC_IsReadingComplete()));
    1af0:	84 ff       	sbrs	r24, 4
    1af2:	fd cf       	rjmp	.-6      	; 0x1aee <GetNextReport+0xaa>
			 *  \return The result of the last ADC conversion as an unsigned value.
			 */
			static inline uint16_t ADC_GetResult(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t ADC_GetResult(void)
			{
				ADCSRA |= (1 << ADIF);
    1af4:	ea e7       	ldi	r30, 0x7A	; 122
    1af6:	f0 e0       	ldi	r31, 0x00	; 0
    1af8:	80 81       	ld	r24, Z
    1afa:	80 61       	ori	r24, 0x10	; 16
    1afc:	80 83       	st	Z, r24
				return ADC;
    1afe:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7e0078>
    1b02:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7e0079>
	
	//Send Right Stick X-Axis ADC Reading to RX in Report Data, axis inverted with 9-bit for signed int  
	ReportData->RX = (JOY_RX ^ 0x3FF);
    1b06:	80 95       	com	r24
    1b08:	b3 e0       	ldi	r27, 0x03	; 3
    1b0a:	9b 27       	eor	r25, r27
    1b0c:	d8 01       	movw	r26, r16
    1b0e:	15 96       	adiw	r26, 0x05	; 5
    1b10:	9c 93       	st	X, r25
    1b12:	8e 93       	st	-X, r24
    1b14:	14 97       	sbiw	r26, 0x04	; 4
			 *
			 *  \param[in] MUXMask  ADC channel mask, reference mask and adjustment mask.
			 */
			static inline void ADC_StartReading(const uint16_t MUXMask)
			{
				ADMUX = MUXMask;
    1b16:	85 e4       	ldi	r24, 0x45	; 69
    1b18:	80 93 7c 00 	sts	0x007C, r24	; 0x80007c <__TEXT_REGION_LENGTH__+0x7e007c>

				#if (defined(__AVR_ATmega16U4__)  || defined(__AVR_ATmega32U4__) || defined(__DOXYGEN__))
				if (MUXMask & (1 << 8))
				  ADCSRB |=  (1 << MUX5);
				else
				  ADCSRB &= ~(1 << MUX5);
    1b1c:	ab e7       	ldi	r26, 0x7B	; 123
    1b1e:	b0 e0       	ldi	r27, 0x00	; 0
    1b20:	8c 91       	ld	r24, X
    1b22:	8f 7d       	andi	r24, 0xDF	; 223
    1b24:	8c 93       	st	X, r24
				#endif

				ADCSRA |= (1 << ADSC);
    1b26:	80 81       	ld	r24, Z
    1b28:	80 64       	ori	r24, 0x40	; 64
    1b2a:	80 83       	st	Z, r24
			 *          complete and ready to be read out with \ref ADC_GetResult().
			 */
			static inline bool ADC_IsReadingComplete(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool ADC_IsReadingComplete(void)
			{
				return ((ADCSRA & (1 << ADIF)) ? true : false);
    1b2c:	80 81       	ld	r24, Z
			static inline uint16_t ADC_GetChannelReading(const uint16_t MUXMask) ATTR_WARN_UNUSED_RESULT;
			static inline uint16_t ADC_GetChannelReading(const uint16_t MUXMask)
			{
				ADC_StartReading(MUXMask);

				while (!(ADC_IsReadingComplete()));
    1b2e:	84 ff       	sbrs	r24, 4
    1b30:	fd cf       	rjmp	.-6      	; 0x1b2c <GetNextReport+0xe8>
			 *  \return The result of the last ADC conversion as an unsigned value.
			 */
			static inline uint16_t ADC_GetResult(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t ADC_GetResult(void)
			{
				ADCSRA |= (1 << ADIF);
    1b32:	ea e7       	ldi	r30, 0x7A	; 122
    1b34:	f0 e0       	ldi	r31, 0x00	; 0
    1b36:	80 81       	ld	r24, Z
    1b38:	80 61       	ori	r24, 0x10	; 16
    1b3a:	80 83       	st	Z, r24
				return ADC;
    1b3c:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7e0078>
    1b40:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7e0079>

	//Send Right Stick Y-Axis ADC Reading to RY in Report Data
	ReportData->RY = JOY_RY;
    1b44:	f8 01       	movw	r30, r16
    1b46:	97 83       	std	Z+7, r25	; 0x07
    1b48:	86 83       	std	Z+6, r24	; 0x06
		
	//Left press joystick button (not working yet)
	if (JoyStatus_LCL & JOY_PRESS)
		ReportData->Button |= (1 << 7);
	//Check if Button X is pressed and add it to the report
	if (ButtonStatus_LCL & BUTTONS_BUTTON1)
    1b4a:	c5 ff       	sbrs	r28, 5
    1b4c:	03 c0       	rjmp	.+6      	; 0x1b54 <GetNextReport+0x110>
		ReportData->Button |= (1 << 0); 
    1b4e:	81 85       	ldd	r24, Z+9	; 0x09
    1b50:	81 60       	ori	r24, 0x01	; 1
    1b52:	81 87       	std	Z+9, r24	; 0x09
		
	if (ButtonStatus_LCL & BUTTONS_BUTTON2)
    1b54:	cc 23       	and	r28, r28
    1b56:	3c f4       	brge	.+14     	; 0x1b66 <GetNextReport+0x122>
		ReportData->Button |= (1 << 1); 
    1b58:	d8 01       	movw	r26, r16
    1b5a:	19 96       	adiw	r26, 0x09	; 9
    1b5c:	8c 91       	ld	r24, X
    1b5e:	19 97       	sbiw	r26, 0x09	; 9
    1b60:	82 60       	ori	r24, 0x02	; 2
    1b62:	19 96       	adiw	r26, 0x09	; 9
    1b64:	8c 93       	st	X, r24
	
	if (ButtonStatus_LCL & BUTTONS_BUTTON3)
    1b66:	c4 ff       	sbrs	r28, 4
    1b68:	04 c0       	rjmp	.+8      	; 0x1b72 <GetNextReport+0x12e>
		ReportData->Button |= (1 << 2); 
    1b6a:	f8 01       	movw	r30, r16
    1b6c:	81 85       	ldd	r24, Z+9	; 0x09
    1b6e:	84 60       	ori	r24, 0x04	; 4
    1b70:	81 87       	std	Z+9, r24	; 0x09

	if (ButtonStatus_LCL & BUTTONS_BUTTON4)
    1b72:	c6 ff       	sbrs	r28, 6
    1b74:	07 c0       	rjmp	.+14     	; 0x1b84 <GetNextReport+0x140>
		ReportData->Button |= (1 << 3);
    1b76:	d8 01       	movw	r26, r16
    1b78:	19 96       	adiw	r26, 0x09	; 9
    1b7a:	8c 91       	ld	r24, X
    1b7c:	19 97       	sbiw	r26, 0x09	; 9
    1b7e:	88 60       	ori	r24, 0x08	; 8
    1b80:	19 96       	adiw	r26, 0x09	; 9
    1b82:	8c 93       	st	X, r24
	static uint8_t PrevJoyStatus    = 0;
	static uint8_t PrevButtonStatus = 0;
	uint8_t        JoyStatus_LCL    = Joystick_GetStatus();
	uint8_t        ButtonStatus_LCL = Buttons_GetStatus();
	bool           InputChanged     = false;
	int8_t			HatMask			= 0;
    1b84:	8c 2f       	mov	r24, r28
    1b86:	81 70       	andi	r24, 0x01	; 1
	
	// Map pressed D-pad / hat switch buttons to HatMask 
	if (ButtonStatus_LCL & BUTTONS_BUTTON5)
		HatMask |= (1 << 0);
		
	if (ButtonStatus_LCL & BUTTONS_BUTTON6)
    1b88:	c1 fd       	sbrc	r28, 1
		HatMask |= (1 << 1);
    1b8a:	82 60       	ori	r24, 0x02	; 2
		
	if (ButtonStatus_LCL & BUTTONS_BUTTON7)
    1b8c:	c2 fd       	sbrc	r28, 2
		HatMask |= (1 << 2);	
    1b8e:	84 60       	ori	r24, 0x04	; 4

	if (ButtonStatus_LCL & BUTTONS_BUTTON8)
    1b90:	c3 fd       	sbrc	r28, 3
		HatMask |= (1 << 3);
    1b92:	88 60       	ori	r24, 0x08	; 8
		
	// Convert HatMask to direction and send to report data hat	(no direction if two opposing ordinals are pressed at the same time)
	switch(HatMask)
    1b94:	85 30       	cpi	r24, 0x05	; 5
    1b96:	89 f1       	breq	.+98     	; 0x1bfa <GetNextReport+0x1b6>
    1b98:	3c f4       	brge	.+14     	; 0x1ba8 <GetNextReport+0x164>
    1b9a:	82 30       	cpi	r24, 0x02	; 2
    1b9c:	99 f0       	breq	.+38     	; 0x1bc4 <GetNextReport+0x180>
    1b9e:	84 30       	cpi	r24, 0x04	; 4
    1ba0:	b1 f0       	breq	.+44     	; 0x1bce <GetNextReport+0x18a>
    1ba2:	81 30       	cpi	r24, 0x01	; 1
    1ba4:	79 f5       	brne	.+94     	; 0x1c04 <GetNextReport+0x1c0>
    1ba6:	0b c0       	rjmp	.+22     	; 0x1bbe <GetNextReport+0x17a>
    1ba8:	88 30       	cpi	r24, 0x08	; 8
    1baa:	a9 f0       	breq	.+42     	; 0x1bd6 <GetNextReport+0x192>
    1bac:	1c f4       	brge	.+6      	; 0x1bb4 <GetNextReport+0x170>
    1bae:	86 30       	cpi	r24, 0x06	; 6
    1bb0:	01 f1       	breq	.+64     	; 0x1bf2 <GetNextReport+0x1ae>
    1bb2:	28 c0       	rjmp	.+80     	; 0x1c04 <GetNextReport+0x1c0>
    1bb4:	89 30       	cpi	r24, 0x09	; 9
    1bb6:	a1 f0       	breq	.+40     	; 0x1be0 <GetNextReport+0x19c>
    1bb8:	8a 30       	cpi	r24, 0x0A	; 10
    1bba:	b1 f0       	breq	.+44     	; 0x1be8 <GetNextReport+0x1a4>
    1bbc:	23 c0       	rjmp	.+70     	; 0x1c04 <GetNextReport+0x1c0>
	{
		case 0x01:					 //Up
			ReportData->Hat = 0;
    1bbe:	f8 01       	movw	r30, r16
    1bc0:	10 86       	std	Z+8, r1	; 0x08
			break;
    1bc2:	23 c0       	rjmp	.+70     	; 0x1c0a <GetNextReport+0x1c6>
		
		case 0x02:					 //Down
			ReportData->Hat = 4;
    1bc4:	84 e0       	ldi	r24, 0x04	; 4
    1bc6:	d8 01       	movw	r26, r16
    1bc8:	18 96       	adiw	r26, 0x08	; 8
    1bca:	8c 93       	st	X, r24
			break;		
    1bcc:	1e c0       	rjmp	.+60     	; 0x1c0a <GetNextReport+0x1c6>
		
		case 0x04:					//Left
			ReportData->Hat = 6;
    1bce:	86 e0       	ldi	r24, 0x06	; 6
    1bd0:	f8 01       	movw	r30, r16
    1bd2:	80 87       	std	Z+8, r24	; 0x08
			break;	
    1bd4:	1a c0       	rjmp	.+52     	; 0x1c0a <GetNextReport+0x1c6>
				
		case 0x08:					//Right
			ReportData->Hat = 2;
    1bd6:	82 e0       	ldi	r24, 0x02	; 2
    1bd8:	d8 01       	movw	r26, r16
    1bda:	18 96       	adiw	r26, 0x08	; 8
    1bdc:	8c 93       	st	X, r24
			break;	
    1bde:	15 c0       	rjmp	.+42     	; 0x1c0a <GetNextReport+0x1c6>
				
		case 0x09:					//Up - Right
			ReportData->Hat = 1;
    1be0:	81 e0       	ldi	r24, 0x01	; 1
    1be2:	f8 01       	movw	r30, r16
    1be4:	80 87       	std	Z+8, r24	; 0x08
			break;	
    1be6:	11 c0       	rjmp	.+34     	; 0x1c0a <GetNextReport+0x1c6>
				
		case 0x0A:					//Down - Right
			ReportData->Hat = 3;
    1be8:	83 e0       	ldi	r24, 0x03	; 3
    1bea:	d8 01       	movw	r26, r16
    1bec:	18 96       	adiw	r26, 0x08	; 8
    1bee:	8c 93       	st	X, r24
			break;		
    1bf0:	0c c0       	rjmp	.+24     	; 0x1c0a <GetNextReport+0x1c6>
			
		case 0x06:					//Down -Left
			ReportData->Hat = 5;
    1bf2:	85 e0       	ldi	r24, 0x05	; 5
    1bf4:	f8 01       	movw	r30, r16
    1bf6:	80 87       	std	Z+8, r24	; 0x08
			break;	
    1bf8:	08 c0       	rjmp	.+16     	; 0x1c0a <GetNextReport+0x1c6>
				
		case 0x05:					//Up - Left
			ReportData->Hat = 7;
    1bfa:	87 e0       	ldi	r24, 0x07	; 7
    1bfc:	d8 01       	movw	r26, r16
    1bfe:	18 96       	adiw	r26, 0x08	; 8
    1c00:	8c 93       	st	X, r24
			break;
    1c02:	03 c0       	rjmp	.+6      	; 0x1c0a <GetNextReport+0x1c6>
					
		default :					//Neutral position
			ReportData->Hat = -1;
    1c04:	8f ef       	ldi	r24, 0xFF	; 255
    1c06:	f8 01       	movw	r30, r16
    1c08:	80 87       	std	Z+8, r24	; 0x08
	}
	
	/* Check if the new report is different to the previous report */
	InputChanged = (uint8_t)(PrevJoyStatus ^ JoyStatus_LCL) | (uint8_t)(PrevButtonStatus ^ ButtonStatus_LCL);
    1c0a:	80 91 2f 09 	lds	r24, 0x092F	; 0x80092f <PrevButtonStatus.4476>
    1c0e:	8c 27       	eor	r24, r28
    1c10:	90 91 30 09 	lds	r25, 0x0930	; 0x800930 <PrevJoyStatus.4475>
    1c14:	89 2b       	or	r24, r25
    1c16:	11 e0       	ldi	r17, 0x01	; 1
    1c18:	09 f4       	brne	.+2      	; 0x1c1c <GetNextReport+0x1d8>
    1c1a:	10 e0       	ldi	r17, 0x00	; 0

	/* Save the current joystick status for later comparison */
	PrevJoyStatus    = JoyStatus_LCL;
    1c1c:	10 92 30 09 	sts	0x0930, r1	; 0x800930 <PrevJoyStatus.4475>
	PrevButtonStatus = ButtonStatus_LCL;
    1c20:	c0 93 2f 09 	sts	0x092F, r28	; 0x80092f <PrevButtonStatus.4476>
	Serial_SendString("I did the report\r\n");
    1c24:	83 e6       	ldi	r24, 0x63	; 99
    1c26:	98 e0       	ldi	r25, 0x08	; 8
    1c28:	0e 94 6e 03 	call	0x6dc	; 0x6dc <Serial_SendString>
	/* Return whether the new report is different to the previous report or not */
	return InputChanged;
	
}
    1c2c:	81 2f       	mov	r24, r17
    1c2e:	cf 91       	pop	r28
    1c30:	1f 91       	pop	r17
    1c32:	0f 91       	pop	r16
    1c34:	08 95       	ret

00001c36 <EVENT_USB_Device_ControlRequest>:
/** Event handler for the USB_ControlRequest event. This is used to catch and process control requests sent to
 *  the device from the USB host before passing along unhandled control requests to the library for processing
 *  internally.
 */
void EVENT_USB_Device_ControlRequest(void)
{
    1c36:	0f 93       	push	r16
    1c38:	1f 93       	push	r17
    1c3a:	cf 93       	push	r28
    1c3c:	df 93       	push	r29
    1c3e:	cd b7       	in	r28, 0x3d	; 61
    1c40:	de b7       	in	r29, 0x3e	; 62
    1c42:	2b 97       	sbiw	r28, 0x0b	; 11
    1c44:	0f b6       	in	r0, 0x3f	; 63
    1c46:	f8 94       	cli
    1c48:	de bf       	out	0x3e, r29	; 62
    1c4a:	0f be       	out	0x3f, r0	; 63
    1c4c:	cd bf       	out	0x3d, r28	; 61
	/* Handle HID Class specific requests */
	switch (USB_ControlRequest.bRequest)
    1c4e:	80 91 64 0a 	lds	r24, 0x0A64	; 0x800a64 <USB_ControlRequest+0x1>
    1c52:	81 30       	cpi	r24, 0x01	; 1
    1c54:	b1 f4       	brne	.+44     	; 0x1c82 <EVENT_USB_Device_ControlRequest+0x4c>
	{
		case HID_REQ_GetReport:
			if (USB_ControlRequest.bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE))
    1c56:	80 91 63 0a 	lds	r24, 0x0A63	; 0x800a63 <USB_ControlRequest>
    1c5a:	81 3a       	cpi	r24, 0xA1	; 161
    1c5c:	91 f4       	brne	.+36     	; 0x1c82 <EVENT_USB_Device_ControlRequest+0x4c>
			{
				USB_JoystickReport_Data_t JoystickReportData;

				/* Create the next HID report to send to the host */
				GetNextReport(&JoystickReportData);
    1c5e:	ce 01       	movw	r24, r28
    1c60:	01 96       	adiw	r24, 0x01	; 1
    1c62:	f0 de       	rcall	.-544    	; 0x1a44 <GetNextReport>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    1c64:	08 ee       	ldi	r16, 0xE8	; 232
    1c66:	10 e0       	ldi	r17, 0x00	; 0
    1c68:	f8 01       	movw	r30, r16
    1c6a:	80 81       	ld	r24, Z
    1c6c:	87 7f       	andi	r24, 0xF7	; 247
    1c6e:	80 83       	st	Z, r24

				Endpoint_ClearSETUP();

				/* Write the report data to the control endpoint */
				Endpoint_Write_Control_Stream_LE(&JoystickReportData, sizeof(JoystickReportData));
    1c70:	6b e0       	ldi	r22, 0x0B	; 11
    1c72:	70 e0       	ldi	r23, 0x00	; 0
    1c74:	ce 01       	movw	r24, r28
    1c76:	01 96       	adiw	r24, 0x01	; 1
    1c78:	be d0       	rcall	.+380    	; 0x1df6 <Endpoint_Write_Control_Stream_LE>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    1c7a:	f8 01       	movw	r30, r16
    1c7c:	80 81       	ld	r24, Z
    1c7e:	8b 77       	andi	r24, 0x7B	; 123
    1c80:	80 83       	st	Z, r24
				Endpoint_ClearOUT();
			}

			break;
	}
}
    1c82:	2b 96       	adiw	r28, 0x0b	; 11
    1c84:	0f b6       	in	r0, 0x3f	; 63
    1c86:	f8 94       	cli
    1c88:	de bf       	out	0x3e, r29	; 62
    1c8a:	0f be       	out	0x3f, r0	; 63
    1c8c:	cd bf       	out	0x3d, r28	; 61
    1c8e:	df 91       	pop	r29
    1c90:	cf 91       	pop	r28
    1c92:	1f 91       	pop	r17
    1c94:	0f 91       	pop	r16
    1c96:	08 95       	ret

00001c98 <HID_Task>:
	
}

/** Function to manage HID report generation and transmission to the host. */
void HID_Task(void)
{
    1c98:	cf 93       	push	r28
    1c9a:	df 93       	push	r29
    1c9c:	cd b7       	in	r28, 0x3d	; 61
    1c9e:	de b7       	in	r29, 0x3e	; 62
    1ca0:	2b 97       	sbiw	r28, 0x0b	; 11
    1ca2:	0f b6       	in	r0, 0x3f	; 63
    1ca4:	f8 94       	cli
    1ca6:	de bf       	out	0x3e, r29	; 62
    1ca8:	0f be       	out	0x3f, r0	; 63
    1caa:	cd bf       	out	0x3d, r28	; 61
	/* Device must be connected and configured for the task to run */
	if (USB_DeviceState != DEVICE_STATE_Configured)
    1cac:	80 91 62 0a 	lds	r24, 0x0A62	; 0x800a62 <USB_DeviceState>
    1cb0:	84 30       	cpi	r24, 0x04	; 4
    1cb2:	b1 f4       	brne	.+44     	; 0x1ce0 <HID_Task+0x48>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    1cb4:	81 e0       	ldi	r24, 0x01	; 1
    1cb6:	80 93 e9 00 	sts	0x00E9, r24	; 0x8000e9 <__TEXT_REGION_LENGTH__+0x7e00e9>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    1cba:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
	
	/* Select the Joystick Report Endpoint */
	Endpoint_SelectEndpoint(JOYSTICK_EPADDR);

	/* Check to see if the host is ready for another packet */
	if (Endpoint_IsINReady())
    1cbe:	80 ff       	sbrs	r24, 0
    1cc0:	0f c0       	rjmp	.+30     	; 0x1ce0 <HID_Task+0x48>
	{
		USB_JoystickReport_Data_t JoystickReportData;

		/* Create the next HID report to send to the host */
		GetNextReport(&JoystickReportData);
    1cc2:	ce 01       	movw	r24, r28
    1cc4:	01 96       	adiw	r24, 0x01	; 1
    1cc6:	be de       	rcall	.-644    	; 0x1a44 <GetNextReport>
		
		/* Write Joystick Report Data */
		Endpoint_Write_Stream_LE(&JoystickReportData, sizeof(JoystickReportData), NULL);
    1cc8:	40 e0       	ldi	r20, 0x00	; 0
    1cca:	50 e0       	ldi	r21, 0x00	; 0
    1ccc:	6b e0       	ldi	r22, 0x0B	; 11
    1cce:	70 e0       	ldi	r23, 0x00	; 0
    1cd0:	ce 01       	movw	r24, r28
    1cd2:	01 96       	adiw	r24, 0x01	; 1
    1cd4:	33 d0       	rcall	.+102    	; 0x1d3c <Endpoint_Write_Stream_LE>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    1cd6:	e8 ee       	ldi	r30, 0xE8	; 232
    1cd8:	f0 e0       	ldi	r31, 0x00	; 0
    1cda:	80 81       	ld	r24, Z
    1cdc:	8e 77       	andi	r24, 0x7E	; 126
    1cde:	80 83       	st	Z, r24
		Endpoint_ClearIN();

		/* Clear the report data afterwards */
		memset(&JoystickReportData, 0, sizeof(JoystickReportData));
	}
}
    1ce0:	2b 96       	adiw	r28, 0x0b	; 11
    1ce2:	0f b6       	in	r0, 0x3f	; 63
    1ce4:	f8 94       	cli
    1ce6:	de bf       	out	0x3e, r29	; 62
    1ce8:	0f be       	out	0x3f, r0	; 63
    1cea:	cd bf       	out	0x3d, r28	; 61
    1cec:	df 91       	pop	r29
    1cee:	cf 91       	pop	r28
    1cf0:	08 95       	ret

00001cf2 <main>:

/** Main program entry point. This routine configures the hardware required by the application, then
 *  enters a loop to run the application tasks in sequence.
 */
int main(void)
{
    1cf2:	5f de       	rcall	.-834    	; 0x19b2 <SetupHardware>
    1cf4:	8e b1       	in	r24, 0x0e	; 14
    1cf6:	80 6f       	ori	r24, 0xF0	; 240
    1cf8:	8e b9       	out	0x0e, r24	; 14
    1cfa:	78 94       	sei
    1cfc:	c8 ec       	ldi	r28, 0xC8	; 200
    1cfe:	d0 e0       	ldi	r29, 0x00	; 0
    1d00:	0e ec       	ldi	r16, 0xCE	; 206
    1d02:	10 e0       	ldi	r17, 0x00	; 0
    1d04:	c9 df       	rcall	.-110    	; 0x1c98 <HID_Task>
    1d06:	e3 d4       	rcall	.+2502   	; 0x26ce <USB_USBTask>
    1d08:	86 e7       	ldi	r24, 0x76	; 118
    1d0a:	98 e0       	ldi	r25, 0x08	; 8
    1d0c:	0e 94 6e 03 	call	0x6dc	; 0x6dc <Serial_SendString>
    1d10:	90 91 62 0a 	lds	r25, 0x0A62	; 0x800a62 <USB_DeviceState>
    1d14:	90 5d       	subi	r25, 0xD0	; 208
    1d16:	88 81       	ld	r24, Y
    1d18:	85 ff       	sbrs	r24, 5
    1d1a:	fd cf       	rjmp	.-6      	; 0x1d16 <main+0x24>
    1d1c:	f8 01       	movw	r30, r16
    1d1e:	90 83       	st	Z, r25
    1d20:	87 e0       	ldi	r24, 0x07	; 7
    1d22:	95 e0       	ldi	r25, 0x05	; 5
    1d24:	0e 94 6e 03 	call	0x6dc	; 0x6dc <Serial_SendString>
    1d28:	80 91 62 0a 	lds	r24, 0x0A62	; 0x800a62 <USB_DeviceState>
    1d2c:	85 30       	cpi	r24, 0x05	; 5
    1d2e:	51 f7       	brne	.-44     	; 0x1d04 <main+0x12>
    1d30:	80 e9       	ldi	r24, 0x90	; 144
    1d32:	98 e0       	ldi	r25, 0x08	; 8
    1d34:	0e 94 6e 03 	call	0x6dc	; 0x6dc <Serial_SendString>
    1d38:	67 d8       	rcall	.-3890   	; 0xe08 <BLE_main>
    1d3a:	e4 cf       	rjmp	.-56     	; 0x1d04 <main+0x12>

00001d3c <Endpoint_Write_Stream_LE>:
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    1d3c:	8f 92       	push	r8
    1d3e:	9f 92       	push	r9
    1d40:	af 92       	push	r10
    1d42:	bf 92       	push	r11
    1d44:	cf 92       	push	r12
    1d46:	df 92       	push	r13
    1d48:	ef 92       	push	r14
    1d4a:	ff 92       	push	r15
    1d4c:	0f 93       	push	r16
    1d4e:	1f 93       	push	r17
    1d50:	cf 93       	push	r28
    1d52:	df 93       	push	r29
    1d54:	8c 01       	movw	r16, r24
    1d56:	eb 01       	movw	r28, r22
    1d58:	5a 01       	movw	r10, r20
    1d5a:	e0 d1       	rcall	.+960    	; 0x211c <Endpoint_WaitUntilReady>
    1d5c:	81 11       	cpse	r24, r1
    1d5e:	3e c0       	rjmp	.+124    	; 0x1ddc <Endpoint_Write_Stream_LE+0xa0>
    1d60:	a1 14       	cp	r10, r1
    1d62:	b1 04       	cpc	r11, r1
    1d64:	39 f0       	breq	.+14     	; 0x1d74 <Endpoint_Write_Stream_LE+0x38>
    1d66:	f5 01       	movw	r30, r10
    1d68:	80 81       	ld	r24, Z
    1d6a:	91 81       	ldd	r25, Z+1	; 0x01
    1d6c:	c8 1b       	sub	r28, r24
    1d6e:	d9 0b       	sbc	r29, r25
    1d70:	08 0f       	add	r16, r24
    1d72:	19 1f       	adc	r17, r25
    1d74:	20 97       	sbiw	r28, 0x00	; 0
    1d76:	89 f1       	breq	.+98     	; 0x1dda <Endpoint_Write_Stream_LE+0x9e>
    1d78:	e1 2c       	mov	r14, r1
    1d7a:	f1 2c       	mov	r15, r1
    1d7c:	0f 2e       	mov	r0, r31
    1d7e:	f8 ee       	ldi	r31, 0xE8	; 232
    1d80:	8f 2e       	mov	r8, r31
    1d82:	91 2c       	mov	r9, r1
    1d84:	f0 2d       	mov	r31, r0
    1d86:	0f 2e       	mov	r0, r31
    1d88:	f1 ef       	ldi	r31, 0xF1	; 241
    1d8a:	cf 2e       	mov	r12, r31
    1d8c:	d1 2c       	mov	r13, r1
    1d8e:	f0 2d       	mov	r31, r0
    1d90:	f4 01       	movw	r30, r8
    1d92:	80 81       	ld	r24, Z
    1d94:	85 fd       	sbrc	r24, 5
    1d96:	14 c0       	rjmp	.+40     	; 0x1dc0 <Endpoint_Write_Stream_LE+0x84>
    1d98:	80 81       	ld	r24, Z
    1d9a:	8e 77       	andi	r24, 0x7E	; 126
    1d9c:	80 83       	st	Z, r24
    1d9e:	97 d4       	rcall	.+2350   	; 0x26ce <USB_USBTask>
    1da0:	a1 14       	cp	r10, r1
    1da2:	b1 04       	cpc	r11, r1
    1da4:	49 f0       	breq	.+18     	; 0x1db8 <Endpoint_Write_Stream_LE+0x7c>
    1da6:	f5 01       	movw	r30, r10
    1da8:	80 81       	ld	r24, Z
    1daa:	91 81       	ldd	r25, Z+1	; 0x01
    1dac:	e8 0e       	add	r14, r24
    1dae:	f9 1e       	adc	r15, r25
    1db0:	f1 82       	std	Z+1, r15	; 0x01
    1db2:	e0 82       	st	Z, r14
    1db4:	85 e0       	ldi	r24, 0x05	; 5
    1db6:	12 c0       	rjmp	.+36     	; 0x1ddc <Endpoint_Write_Stream_LE+0xa0>
    1db8:	b1 d1       	rcall	.+866    	; 0x211c <Endpoint_WaitUntilReady>
    1dba:	88 23       	and	r24, r24
    1dbc:	51 f0       	breq	.+20     	; 0x1dd2 <Endpoint_Write_Stream_LE+0x96>
    1dbe:	0e c0       	rjmp	.+28     	; 0x1ddc <Endpoint_Write_Stream_LE+0xa0>
    1dc0:	f8 01       	movw	r30, r16
    1dc2:	81 91       	ld	r24, Z+
    1dc4:	8f 01       	movw	r16, r30
    1dc6:	f6 01       	movw	r30, r12
    1dc8:	80 83       	st	Z, r24
    1dca:	21 97       	sbiw	r28, 0x01	; 1
    1dcc:	ff ef       	ldi	r31, 0xFF	; 255
    1dce:	ef 1a       	sub	r14, r31
    1dd0:	ff 0a       	sbc	r15, r31
    1dd2:	20 97       	sbiw	r28, 0x00	; 0
    1dd4:	e9 f6       	brne	.-70     	; 0x1d90 <Endpoint_Write_Stream_LE+0x54>
    1dd6:	80 e0       	ldi	r24, 0x00	; 0
    1dd8:	01 c0       	rjmp	.+2      	; 0x1ddc <Endpoint_Write_Stream_LE+0xa0>
    1dda:	80 e0       	ldi	r24, 0x00	; 0
    1ddc:	df 91       	pop	r29
    1dde:	cf 91       	pop	r28
    1de0:	1f 91       	pop	r17
    1de2:	0f 91       	pop	r16
    1de4:	ff 90       	pop	r15
    1de6:	ef 90       	pop	r14
    1de8:	df 90       	pop	r13
    1dea:	cf 90       	pop	r12
    1dec:	bf 90       	pop	r11
    1dee:	af 90       	pop	r10
    1df0:	9f 90       	pop	r9
    1df2:	8f 90       	pop	r8
    1df4:	08 95       	ret

00001df6 <Endpoint_Write_Control_Stream_LE>:
    1df6:	cf 92       	push	r12
    1df8:	df 92       	push	r13
    1dfa:	ff 92       	push	r15
    1dfc:	0f 93       	push	r16
    1dfe:	1f 93       	push	r17
    1e00:	cf 93       	push	r28
    1e02:	df 93       	push	r29
    1e04:	20 91 69 0a 	lds	r18, 0x0A69	; 0x800a69 <USB_ControlRequest+0x6>
    1e08:	30 91 6a 0a 	lds	r19, 0x0A6A	; 0x800a6a <USB_ControlRequest+0x7>
    1e0c:	26 17       	cp	r18, r22
    1e0e:	37 07       	cpc	r19, r23
    1e10:	58 f0       	brcs	.+22     	; 0x1e28 <Endpoint_Write_Control_Stream_LE+0x32>
    1e12:	61 15       	cp	r22, r1
    1e14:	71 05       	cpc	r23, r1
    1e16:	39 f4       	brne	.+14     	; 0x1e26 <Endpoint_Write_Control_Stream_LE+0x30>
    1e18:	e8 ee       	ldi	r30, 0xE8	; 232
    1e1a:	f0 e0       	ldi	r31, 0x00	; 0
    1e1c:	20 81       	ld	r18, Z
    1e1e:	2e 77       	andi	r18, 0x7E	; 126
    1e20:	20 83       	st	Z, r18
    1e22:	9b 01       	movw	r18, r22
    1e24:	01 c0       	rjmp	.+2      	; 0x1e28 <Endpoint_Write_Control_Stream_LE+0x32>
    1e26:	9b 01       	movw	r18, r22
    1e28:	a8 2f       	mov	r26, r24
    1e2a:	b9 2f       	mov	r27, r25
    1e2c:	10 e0       	ldi	r17, 0x00	; 0
    1e2e:	e8 ee       	ldi	r30, 0xE8	; 232
    1e30:	f0 e0       	ldi	r31, 0x00	; 0
    1e32:	63 ef       	ldi	r22, 0xF3	; 243
    1e34:	70 e0       	ldi	r23, 0x00	; 0
    1e36:	42 ef       	ldi	r20, 0xF2	; 242
    1e38:	50 e0       	ldi	r21, 0x00	; 0
    1e3a:	0f 2e       	mov	r0, r31
    1e3c:	f1 ef       	ldi	r31, 0xF1	; 241
    1e3e:	cf 2e       	mov	r12, r31
    1e40:	d1 2c       	mov	r13, r1
    1e42:	f0 2d       	mov	r31, r0
    1e44:	01 e0       	ldi	r16, 0x01	; 1
    1e46:	f1 2c       	mov	r15, r1
    1e48:	30 c0       	rjmp	.+96     	; 0x1eaa <Endpoint_Write_Control_Stream_LE+0xb4>
    1e4a:	80 91 62 0a 	lds	r24, 0x0A62	; 0x800a62 <USB_DeviceState>
    1e4e:	88 23       	and	r24, r24
    1e50:	09 f4       	brne	.+2      	; 0x1e54 <Endpoint_Write_Control_Stream_LE+0x5e>
    1e52:	42 c0       	rjmp	.+132    	; 0x1ed8 <Endpoint_Write_Control_Stream_LE+0xe2>
    1e54:	85 30       	cpi	r24, 0x05	; 5
    1e56:	09 f4       	brne	.+2      	; 0x1e5a <Endpoint_Write_Control_Stream_LE+0x64>
    1e58:	41 c0       	rjmp	.+130    	; 0x1edc <Endpoint_Write_Control_Stream_LE+0xe6>
    1e5a:	80 81       	ld	r24, Z
    1e5c:	83 fd       	sbrc	r24, 3
    1e5e:	40 c0       	rjmp	.+128    	; 0x1ee0 <Endpoint_Write_Control_Stream_LE+0xea>
    1e60:	80 81       	ld	r24, Z
    1e62:	82 fd       	sbrc	r24, 2
    1e64:	32 c0       	rjmp	.+100    	; 0x1eca <Endpoint_Write_Control_Stream_LE+0xd4>
    1e66:	80 81       	ld	r24, Z
    1e68:	80 ff       	sbrs	r24, 0
    1e6a:	1f c0       	rjmp	.+62     	; 0x1eaa <Endpoint_Write_Control_Stream_LE+0xb4>
    1e6c:	eb 01       	movw	r28, r22
    1e6e:	18 81       	ld	r17, Y
    1e70:	ea 01       	movw	r28, r20
    1e72:	88 81       	ld	r24, Y
    1e74:	90 e0       	ldi	r25, 0x00	; 0
    1e76:	91 2b       	or	r25, r17
    1e78:	21 15       	cp	r18, r1
    1e7a:	31 05       	cpc	r19, r1
    1e7c:	79 f0       	breq	.+30     	; 0x1e9c <Endpoint_Write_Control_Stream_LE+0xa6>
    1e7e:	88 30       	cpi	r24, 0x08	; 8
    1e80:	91 05       	cpc	r25, r1
    1e82:	60 f4       	brcc	.+24     	; 0x1e9c <Endpoint_Write_Control_Stream_LE+0xa6>
    1e84:	1d 91       	ld	r17, X+
    1e86:	e6 01       	movw	r28, r12
    1e88:	18 83       	st	Y, r17
    1e8a:	21 50       	subi	r18, 0x01	; 1
    1e8c:	31 09       	sbc	r19, r1
    1e8e:	01 96       	adiw	r24, 0x01	; 1
    1e90:	21 15       	cp	r18, r1
    1e92:	31 05       	cpc	r19, r1
    1e94:	19 f0       	breq	.+6      	; 0x1e9c <Endpoint_Write_Control_Stream_LE+0xa6>
    1e96:	88 30       	cpi	r24, 0x08	; 8
    1e98:	91 05       	cpc	r25, r1
    1e9a:	a1 f7       	brne	.-24     	; 0x1e84 <Endpoint_Write_Control_Stream_LE+0x8e>
    1e9c:	10 2f       	mov	r17, r16
    1e9e:	08 97       	sbiw	r24, 0x08	; 8
    1ea0:	09 f0       	breq	.+2      	; 0x1ea4 <Endpoint_Write_Control_Stream_LE+0xae>
    1ea2:	1f 2d       	mov	r17, r15
    1ea4:	80 81       	ld	r24, Z
    1ea6:	8e 77       	andi	r24, 0x7E	; 126
    1ea8:	80 83       	st	Z, r24
    1eaa:	21 15       	cp	r18, r1
    1eac:	31 05       	cpc	r19, r1
    1eae:	69 f6       	brne	.-102    	; 0x1e4a <Endpoint_Write_Control_Stream_LE+0x54>
    1eb0:	11 11       	cpse	r17, r1
    1eb2:	cb cf       	rjmp	.-106    	; 0x1e4a <Endpoint_Write_Control_Stream_LE+0x54>
    1eb4:	0a c0       	rjmp	.+20     	; 0x1eca <Endpoint_Write_Control_Stream_LE+0xd4>
    1eb6:	80 91 62 0a 	lds	r24, 0x0A62	; 0x800a62 <USB_DeviceState>
    1eba:	88 23       	and	r24, r24
    1ebc:	99 f0       	breq	.+38     	; 0x1ee4 <Endpoint_Write_Control_Stream_LE+0xee>
    1ebe:	85 30       	cpi	r24, 0x05	; 5
    1ec0:	99 f0       	breq	.+38     	; 0x1ee8 <Endpoint_Write_Control_Stream_LE+0xf2>
    1ec2:	80 81       	ld	r24, Z
    1ec4:	83 ff       	sbrs	r24, 3
    1ec6:	03 c0       	rjmp	.+6      	; 0x1ece <Endpoint_Write_Control_Stream_LE+0xd8>
    1ec8:	11 c0       	rjmp	.+34     	; 0x1eec <Endpoint_Write_Control_Stream_LE+0xf6>
    1eca:	e8 ee       	ldi	r30, 0xE8	; 232
    1ecc:	f0 e0       	ldi	r31, 0x00	; 0
    1ece:	80 81       	ld	r24, Z
    1ed0:	82 ff       	sbrs	r24, 2
    1ed2:	f1 cf       	rjmp	.-30     	; 0x1eb6 <Endpoint_Write_Control_Stream_LE+0xc0>
    1ed4:	80 e0       	ldi	r24, 0x00	; 0
    1ed6:	0b c0       	rjmp	.+22     	; 0x1eee <Endpoint_Write_Control_Stream_LE+0xf8>
    1ed8:	82 e0       	ldi	r24, 0x02	; 2
    1eda:	09 c0       	rjmp	.+18     	; 0x1eee <Endpoint_Write_Control_Stream_LE+0xf8>
    1edc:	83 e0       	ldi	r24, 0x03	; 3
    1ede:	07 c0       	rjmp	.+14     	; 0x1eee <Endpoint_Write_Control_Stream_LE+0xf8>
    1ee0:	81 e0       	ldi	r24, 0x01	; 1
    1ee2:	05 c0       	rjmp	.+10     	; 0x1eee <Endpoint_Write_Control_Stream_LE+0xf8>
    1ee4:	82 e0       	ldi	r24, 0x02	; 2
    1ee6:	03 c0       	rjmp	.+6      	; 0x1eee <Endpoint_Write_Control_Stream_LE+0xf8>
    1ee8:	83 e0       	ldi	r24, 0x03	; 3
    1eea:	01 c0       	rjmp	.+2      	; 0x1eee <Endpoint_Write_Control_Stream_LE+0xf8>
    1eec:	81 e0       	ldi	r24, 0x01	; 1
    1eee:	df 91       	pop	r29
    1ef0:	cf 91       	pop	r28
    1ef2:	1f 91       	pop	r17
    1ef4:	0f 91       	pop	r16
    1ef6:	ff 90       	pop	r15
    1ef8:	df 90       	pop	r13
    1efa:	cf 90       	pop	r12
    1efc:	08 95       	ret

00001efe <Endpoint_Write_Control_PStream_LE>:

#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (const void* const Buffer,
                            uint16_t Length)
{
    1efe:	cf 92       	push	r12
    1f00:	df 92       	push	r13
    1f02:	ff 92       	push	r15
    1f04:	0f 93       	push	r16
    1f06:	1f 93       	push	r17
    1f08:	cf 93       	push	r28
    1f0a:	df 93       	push	r29
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	bool     LastPacketFull = false;

	if (Length > USB_ControlRequest.wLength)
    1f0c:	20 91 69 0a 	lds	r18, 0x0A69	; 0x800a69 <USB_ControlRequest+0x6>
    1f10:	30 91 6a 0a 	lds	r19, 0x0A6A	; 0x800a6a <USB_ControlRequest+0x7>
    1f14:	26 17       	cp	r18, r22
    1f16:	37 07       	cpc	r19, r23
    1f18:	58 f0       	brcs	.+22     	; 0x1f30 <Endpoint_Write_Control_PStream_LE+0x32>
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
    1f1a:	61 15       	cp	r22, r1
    1f1c:	71 05       	cpc	r23, r1
    1f1e:	39 f4       	brne	.+14     	; 0x1f2e <Endpoint_Write_Control_PStream_LE+0x30>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    1f20:	e8 ee       	ldi	r30, 0xE8	; 232
    1f22:	f0 e0       	ldi	r31, 0x00	; 0
    1f24:	20 81       	ld	r18, Z
    1f26:	2e 77       	andi	r18, 0x7E	; 126
    1f28:	20 83       	st	Z, r18
    1f2a:	9b 01       	movw	r18, r22
    1f2c:	01 c0       	rjmp	.+2      	; 0x1f30 <Endpoint_Write_Control_PStream_LE+0x32>
    1f2e:	9b 01       	movw	r18, r22
    1f30:	e8 2f       	mov	r30, r24
    1f32:	f9 2f       	mov	r31, r25
    1f34:	10 e0       	ldi	r17, 0x00	; 0
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    1f36:	a8 ee       	ldi	r26, 0xE8	; 232
    1f38:	b0 e0       	ldi	r27, 0x00	; 0
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if (defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					return UEBCX;
				#elif defined(USB_SERIES_4_AVR)
					return (((uint16_t)UEBCHX << 8) | UEBCLX);
    1f3a:	63 ef       	ldi	r22, 0xF3	; 243
    1f3c:	70 e0       	ldi	r23, 0x00	; 0
    1f3e:	42 ef       	ldi	r20, 0xF2	; 242
    1f40:	50 e0       	ldi	r21, 0x00	; 0
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    1f42:	0f 2e       	mov	r0, r31
    1f44:	f1 ef       	ldi	r31, 0xF1	; 241
    1f46:	cf 2e       	mov	r12, r31
    1f48:	d1 2c       	mov	r13, r1
    1f4a:	f0 2d       	mov	r31, r0
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
				BytesInEndpoint++;
			}

			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
    1f4c:	01 e0       	ldi	r16, 0x01	; 1
    1f4e:	f1 2c       	mov	r15, r1
    1f50:	31 c0       	rjmp	.+98     	; 0x1fb4 <Endpoint_Write_Control_PStream_LE+0xb6>
	else if (!(Length))
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    1f52:	80 91 62 0a 	lds	r24, 0x0A62	; 0x800a62 <USB_DeviceState>

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    1f56:	88 23       	and	r24, r24
    1f58:	09 f4       	brne	.+2      	; 0x1f5c <Endpoint_Write_Control_PStream_LE+0x5e>
    1f5a:	43 c0       	rjmp	.+134    	; 0x1fe2 <Endpoint_Write_Control_PStream_LE+0xe4>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    1f5c:	85 30       	cpi	r24, 0x05	; 5
    1f5e:	09 f4       	brne	.+2      	; 0x1f62 <Endpoint_Write_Control_PStream_LE+0x64>
    1f60:	42 c0       	rjmp	.+132    	; 0x1fe6 <Endpoint_Write_Control_PStream_LE+0xe8>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    1f62:	8c 91       	ld	r24, X
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    1f64:	83 fd       	sbrc	r24, 3
    1f66:	41 c0       	rjmp	.+130    	; 0x1fea <Endpoint_Write_Control_PStream_LE+0xec>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    1f68:	8c 91       	ld	r24, X
		  return ENDPOINT_RWCSTREAM_HostAborted;
		else if (Endpoint_IsOUTReceived())
    1f6a:	82 fd       	sbrc	r24, 2
    1f6c:	33 c0       	rjmp	.+102    	; 0x1fd4 <Endpoint_Write_Control_PStream_LE+0xd6>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    1f6e:	8c 91       	ld	r24, X
		  break;

		if (Endpoint_IsINReady())
    1f70:	80 ff       	sbrs	r24, 0
    1f72:	20 c0       	rjmp	.+64     	; 0x1fb4 <Endpoint_Write_Control_PStream_LE+0xb6>
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if (defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					return UEBCX;
				#elif defined(USB_SERIES_4_AVR)
					return (((uint16_t)UEBCHX << 8) | UEBCLX);
    1f74:	eb 01       	movw	r28, r22
    1f76:	18 81       	ld	r17, Y
    1f78:	ea 01       	movw	r28, r20
    1f7a:	88 81       	ld	r24, Y
    1f7c:	90 e0       	ldi	r25, 0x00	; 0
    1f7e:	91 2b       	or	r25, r17
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
    1f80:	21 15       	cp	r18, r1
    1f82:	31 05       	cpc	r19, r1
    1f84:	81 f0       	breq	.+32     	; 0x1fa6 <Endpoint_Write_Control_PStream_LE+0xa8>
    1f86:	88 30       	cpi	r24, 0x08	; 8
    1f88:	91 05       	cpc	r25, r1
    1f8a:	68 f4       	brcc	.+26     	; 0x1fa6 <Endpoint_Write_Control_PStream_LE+0xa8>
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
    1f8c:	14 91       	lpm	r17, Z
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    1f8e:	e6 01       	movw	r28, r12
    1f90:	18 83       	st	Y, r17
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
    1f92:	31 96       	adiw	r30, 0x01	; 1
				Length--;
    1f94:	21 50       	subi	r18, 0x01	; 1
    1f96:	31 09       	sbc	r19, r1
				BytesInEndpoint++;
    1f98:	01 96       	adiw	r24, 0x01	; 1

		if (Endpoint_IsINReady())
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
    1f9a:	21 15       	cp	r18, r1
    1f9c:	31 05       	cpc	r19, r1
    1f9e:	19 f0       	breq	.+6      	; 0x1fa6 <Endpoint_Write_Control_PStream_LE+0xa8>
    1fa0:	88 30       	cpi	r24, 0x08	; 8
    1fa2:	91 05       	cpc	r25, r1
    1fa4:	99 f7       	brne	.-26     	; 0x1f8c <Endpoint_Write_Control_PStream_LE+0x8e>
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
				BytesInEndpoint++;
			}

			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
    1fa6:	10 2f       	mov	r17, r16
    1fa8:	08 97       	sbiw	r24, 0x08	; 8
    1faa:	09 f0       	breq	.+2      	; 0x1fae <Endpoint_Write_Control_PStream_LE+0xb0>
    1fac:	1f 2d       	mov	r17, r15
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    1fae:	8c 91       	ld	r24, X
    1fb0:	8e 77       	andi	r24, 0x7E	; 126
    1fb2:	8c 93       	st	X, r24
	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
    1fb4:	21 15       	cp	r18, r1
    1fb6:	31 05       	cpc	r19, r1
    1fb8:	61 f6       	brne	.-104    	; 0x1f52 <Endpoint_Write_Control_PStream_LE+0x54>
    1fba:	11 11       	cpse	r17, r1
    1fbc:	ca cf       	rjmp	.-108    	; 0x1f52 <Endpoint_Write_Control_PStream_LE+0x54>
    1fbe:	0a c0       	rjmp	.+20     	; 0x1fd4 <Endpoint_Write_Control_PStream_LE+0xd6>
		}
	}

	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    1fc0:	80 91 62 0a 	lds	r24, 0x0A62	; 0x800a62 <USB_DeviceState>

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    1fc4:	88 23       	and	r24, r24
    1fc6:	99 f0       	breq	.+38     	; 0x1fee <Endpoint_Write_Control_PStream_LE+0xf0>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    1fc8:	85 30       	cpi	r24, 0x05	; 5
    1fca:	99 f0       	breq	.+38     	; 0x1ff2 <Endpoint_Write_Control_PStream_LE+0xf4>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    1fcc:	80 81       	ld	r24, Z
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    1fce:	83 ff       	sbrs	r24, 3
    1fd0:	03 c0       	rjmp	.+6      	; 0x1fd8 <Endpoint_Write_Control_PStream_LE+0xda>
    1fd2:	11 c0       	rjmp	.+34     	; 0x1ff6 <Endpoint_Write_Control_PStream_LE+0xf8>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    1fd4:	e8 ee       	ldi	r30, 0xE8	; 232
    1fd6:	f0 e0       	ldi	r31, 0x00	; 0
    1fd8:	80 81       	ld	r24, Z
			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
			Endpoint_ClearIN();
		}
	}

	while (!(Endpoint_IsOUTReceived()))
    1fda:	82 ff       	sbrs	r24, 2
    1fdc:	f1 cf       	rjmp	.-30     	; 0x1fc0 <Endpoint_Write_Control_PStream_LE+0xc2>
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
	}

	return ENDPOINT_RWCSTREAM_NoError;
    1fde:	80 e0       	ldi	r24, 0x00	; 0
    1fe0:	0b c0       	rjmp	.+22     	; 0x1ff8 <Endpoint_Write_Control_PStream_LE+0xfa>
	while (Length || LastPacketFull)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
    1fe2:	82 e0       	ldi	r24, 0x02	; 2
    1fe4:	09 c0       	rjmp	.+18     	; 0x1ff8 <Endpoint_Write_Control_PStream_LE+0xfa>
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
    1fe6:	83 e0       	ldi	r24, 0x03	; 3
    1fe8:	07 c0       	rjmp	.+14     	; 0x1ff8 <Endpoint_Write_Control_PStream_LE+0xfa>
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
    1fea:	81 e0       	ldi	r24, 0x01	; 1
    1fec:	05 c0       	rjmp	.+10     	; 0x1ff8 <Endpoint_Write_Control_PStream_LE+0xfa>
	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
    1fee:	82 e0       	ldi	r24, 0x02	; 2
    1ff0:	03 c0       	rjmp	.+6      	; 0x1ff8 <Endpoint_Write_Control_PStream_LE+0xfa>
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
    1ff2:	83 e0       	ldi	r24, 0x03	; 3
    1ff4:	01 c0       	rjmp	.+2      	; 0x1ff8 <Endpoint_Write_Control_PStream_LE+0xfa>
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
    1ff6:	81 e0       	ldi	r24, 0x01	; 1
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    1ff8:	df 91       	pop	r29
    1ffa:	cf 91       	pop	r28
    1ffc:	1f 91       	pop	r17
    1ffe:	0f 91       	pop	r16
    2000:	ff 90       	pop	r15
    2002:	df 90       	pop	r13
    2004:	cf 90       	pop	r12
    2006:	08 95       	ret

00002008 <Endpoint_ConfigureEndpoint_Prv>:
		UEIENX  = 0;
		UEINTX  = 0;
		UECFG1X = 0;
		Endpoint_DisableEndpoint();
	}
}
    2008:	8f 92       	push	r8
    200a:	9f 92       	push	r9
    200c:	bf 92       	push	r11
    200e:	cf 92       	push	r12
    2010:	df 92       	push	r13
    2012:	ef 92       	push	r14
    2014:	ff 92       	push	r15
    2016:	0f 93       	push	r16
    2018:	1f 93       	push	r17
    201a:	cf 93       	push	r28
    201c:	df 93       	push	r29
    201e:	87 30       	cpi	r24, 0x07	; 7
    2020:	70 f1       	brcs	.+92     	; 0x207e <Endpoint_ConfigureEndpoint_Prv+0x76>
    2022:	26 c0       	rjmp	.+76     	; 0x2070 <Endpoint_ConfigureEndpoint_Prv+0x68>
    2024:	29 2f       	mov	r18, r25
    2026:	2f 70       	andi	r18, 0x0F	; 15
    2028:	e7 01       	movw	r28, r14
    202a:	28 83       	st	Y, r18
    202c:	89 17       	cp	r24, r25
    202e:	31 f0       	breq	.+12     	; 0x203c <Endpoint_ConfigureEndpoint_Prv+0x34>
    2030:	e8 01       	movw	r28, r16
    2032:	78 81       	ld	r23, Y
    2034:	20 81       	ld	r18, Z
    2036:	e4 01       	movw	r28, r8
    2038:	58 81       	ld	r21, Y
    203a:	03 c0       	rjmp	.+6      	; 0x2042 <Endpoint_ConfigureEndpoint_Prv+0x3a>
    203c:	24 2f       	mov	r18, r20
    203e:	76 2f       	mov	r23, r22
    2040:	5b 2d       	mov	r21, r11
    2042:	21 ff       	sbrs	r18, 1
    2044:	12 c0       	rjmp	.+36     	; 0x206a <Endpoint_ConfigureEndpoint_Prv+0x62>
    2046:	3c 91       	ld	r19, X
    2048:	3e 7f       	andi	r19, 0xFE	; 254
    204a:	3c 93       	st	X, r19
    204c:	30 81       	ld	r19, Z
    204e:	3d 7f       	andi	r19, 0xFD	; 253
    2050:	30 83       	st	Z, r19
    2052:	3c 91       	ld	r19, X
    2054:	31 60       	ori	r19, 0x01	; 1
    2056:	3c 93       	st	X, r19
    2058:	e8 01       	movw	r28, r16
    205a:	78 83       	st	Y, r23
    205c:	20 83       	st	Z, r18
    205e:	e4 01       	movw	r28, r8
    2060:	58 83       	st	Y, r21
    2062:	e6 01       	movw	r28, r12
    2064:	28 81       	ld	r18, Y
    2066:	22 23       	and	r18, r18
    2068:	44 f4       	brge	.+16     	; 0x207a <Endpoint_ConfigureEndpoint_Prv+0x72>
    206a:	9f 5f       	subi	r25, 0xFF	; 255
    206c:	97 30       	cpi	r25, 0x07	; 7
    206e:	d1 f6       	brne	.-76     	; 0x2024 <Endpoint_ConfigureEndpoint_Prv+0x1c>
    2070:	8f 70       	andi	r24, 0x0F	; 15
    2072:	80 93 e9 00 	sts	0x00E9, r24	; 0x8000e9 <__TEXT_REGION_LENGTH__+0x7e00e9>
    2076:	81 e0       	ldi	r24, 0x01	; 1
    2078:	21 c0       	rjmp	.+66     	; 0x20bc <Endpoint_ConfigureEndpoint_Prv+0xb4>
    207a:	80 e0       	ldi	r24, 0x00	; 0
    207c:	1f c0       	rjmp	.+62     	; 0x20bc <Endpoint_ConfigureEndpoint_Prv+0xb4>
    207e:	98 2f       	mov	r25, r24
    2080:	9f 70       	andi	r25, 0x0F	; 15
    2082:	90 93 e9 00 	sts	0x00E9, r25	; 0x8000e9 <__TEXT_REGION_LENGTH__+0x7e00e9>
    2086:	98 2f       	mov	r25, r24
    2088:	24 2f       	mov	r18, r20
    208a:	76 2f       	mov	r23, r22
    208c:	50 e0       	ldi	r21, 0x00	; 0
    208e:	ab ee       	ldi	r26, 0xEB	; 235
    2090:	b0 e0       	ldi	r27, 0x00	; 0
    2092:	ed ee       	ldi	r30, 0xED	; 237
    2094:	f0 e0       	ldi	r31, 0x00	; 0
    2096:	0c ee       	ldi	r16, 0xEC	; 236
    2098:	10 e0       	ldi	r17, 0x00	; 0
    209a:	0f 2e       	mov	r0, r31
    209c:	f0 ef       	ldi	r31, 0xF0	; 240
    209e:	8f 2e       	mov	r8, r31
    20a0:	91 2c       	mov	r9, r1
    20a2:	f0 2d       	mov	r31, r0
    20a4:	0f 2e       	mov	r0, r31
    20a6:	fe ee       	ldi	r31, 0xEE	; 238
    20a8:	cf 2e       	mov	r12, r31
    20aa:	d1 2c       	mov	r13, r1
    20ac:	f0 2d       	mov	r31, r0
    20ae:	0f 2e       	mov	r0, r31
    20b0:	f9 ee       	ldi	r31, 0xE9	; 233
    20b2:	ef 2e       	mov	r14, r31
    20b4:	f1 2c       	mov	r15, r1
    20b6:	f0 2d       	mov	r31, r0
    20b8:	b1 2c       	mov	r11, r1
    20ba:	c3 cf       	rjmp	.-122    	; 0x2042 <Endpoint_ConfigureEndpoint_Prv+0x3a>
    20bc:	df 91       	pop	r29
    20be:	cf 91       	pop	r28
    20c0:	1f 91       	pop	r17
    20c2:	0f 91       	pop	r16
    20c4:	ff 90       	pop	r15
    20c6:	ef 90       	pop	r14
    20c8:	df 90       	pop	r13
    20ca:	cf 90       	pop	r12
    20cc:	bf 90       	pop	r11
    20ce:	9f 90       	pop	r9
    20d0:	8f 90       	pop	r8
    20d2:	08 95       	ret

000020d4 <Endpoint_ClearStatusStage>:

void Endpoint_ClearStatusStage(void)
{
	if (USB_ControlRequest.bmRequestType & REQDIR_DEVICETOHOST)
    20d4:	80 91 63 0a 	lds	r24, 0x0A63	; 0x800a63 <USB_ControlRequest>
    20d8:	88 23       	and	r24, r24
    20da:	44 f0       	brlt	.+16     	; 0x20ec <Endpoint_ClearStatusStage+0x18>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    20dc:	e8 ee       	ldi	r30, 0xE8	; 232
    20de:	f0 e0       	ldi	r31, 0x00	; 0
    20e0:	14 c0       	rjmp	.+40     	; 0x210a <Endpoint_ClearStatusStage+0x36>
	{
		while (!(Endpoint_IsOUTReceived()))
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    20e2:	80 91 62 0a 	lds	r24, 0x0A62	; 0x800a62 <USB_DeviceState>
    20e6:	81 11       	cpse	r24, r1
    20e8:	03 c0       	rjmp	.+6      	; 0x20f0 <Endpoint_ClearStatusStage+0x1c>
    20ea:	08 95       	ret
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    20ec:	e8 ee       	ldi	r30, 0xE8	; 232
    20ee:	f0 e0       	ldi	r31, 0x00	; 0
    20f0:	80 81       	ld	r24, Z

void Endpoint_ClearStatusStage(void)
{
	if (USB_ControlRequest.bmRequestType & REQDIR_DEVICETOHOST)
	{
		while (!(Endpoint_IsOUTReceived()))
    20f2:	82 ff       	sbrs	r24, 2
    20f4:	f6 cf       	rjmp	.-20     	; 0x20e2 <Endpoint_ClearStatusStage+0xe>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    20f6:	e8 ee       	ldi	r30, 0xE8	; 232
    20f8:	f0 e0       	ldi	r31, 0x00	; 0
    20fa:	80 81       	ld	r24, Z
    20fc:	8b 77       	andi	r24, 0x7B	; 123
    20fe:	80 83       	st	Z, r24
    2100:	08 95       	ret
	}
	else
	{
		while (!(Endpoint_IsINReady()))
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    2102:	80 91 62 0a 	lds	r24, 0x0A62	; 0x800a62 <USB_DeviceState>
    2106:	88 23       	and	r24, r24
    2108:	41 f0       	breq	.+16     	; 0x211a <Endpoint_ClearStatusStage+0x46>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    210a:	80 81       	ld	r24, Z

		Endpoint_ClearOUT();
	}
	else
	{
		while (!(Endpoint_IsINReady()))
    210c:	80 ff       	sbrs	r24, 0
    210e:	f9 cf       	rjmp	.-14     	; 0x2102 <Endpoint_ClearStatusStage+0x2e>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    2110:	e8 ee       	ldi	r30, 0xE8	; 232
    2112:	f0 e0       	ldi	r31, 0x00	; 0
    2114:	80 81       	ld	r24, Z
    2116:	8e 77       	andi	r24, 0x7E	; 126
    2118:	80 83       	st	Z, r24
    211a:	08 95       	ret

0000211c <Endpoint_WaitUntilReady>:
	}
}

#if !defined(CONTROL_ONLY_DEVICE)
uint8_t Endpoint_WaitUntilReady(void)
{
    211c:	0f 93       	push	r16
    211e:	1f 93       	push	r17
    2120:	cf 93       	push	r28
    2122:	df 93       	push	r29
			 *  \return Current USB frame number from the USB controller.
			 */
			static inline uint16_t USB_Device_GetFrameNumber(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint16_t USB_Device_GetFrameNumber(void)
			{
				return UDFNUM;
    2124:	20 91 e4 00 	lds	r18, 0x00E4	; 0x8000e4 <__TEXT_REGION_LENGTH__+0x7e00e4>
    2128:	30 91 e5 00 	lds	r19, 0x00E5	; 0x8000e5 <__TEXT_REGION_LENGTH__+0x7e00e5>
    212c:	65 e6       	ldi	r22, 0x65	; 101
			 *  \return The currently selected endpoint's direction, as a \c ENDPOINT_DIR_* mask.
			 */
			static inline uint8_t Endpoint_GetEndpointDirection(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetEndpointDirection(void)
			{
				return (UECFG0X & (1 << EPDIR)) ? ENDPOINT_DIR_IN : ENDPOINT_DIR_OUT;
    212e:	ac ee       	ldi	r26, 0xEC	; 236
    2130:	b0 e0       	ldi	r27, 0x00	; 0
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    2132:	e8 ee       	ldi	r30, 0xE8	; 232
    2134:	f0 e0       	ldi	r31, 0x00	; 0
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
    2136:	0b ee       	ldi	r16, 0xEB	; 235
    2138:	10 e0       	ldi	r17, 0x00	; 0
    213a:	44 ee       	ldi	r20, 0xE4	; 228
    213c:	50 e0       	ldi	r21, 0x00	; 0
    213e:	01 c0       	rjmp	.+2      	; 0x2142 <Endpoint_WaitUntilReady+0x26>
    2140:	9c 01       	movw	r18, r24
			 *  \return The currently selected endpoint's direction, as a \c ENDPOINT_DIR_* mask.
			 */
			static inline uint8_t Endpoint_GetEndpointDirection(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetEndpointDirection(void)
			{
				return (UECFG0X & (1 << EPDIR)) ? ENDPOINT_DIR_IN : ENDPOINT_DIR_OUT;
    2142:	9c 91       	ld	r25, X
    2144:	89 2f       	mov	r24, r25
    2146:	81 70       	andi	r24, 0x01	; 1
    2148:	90 fd       	sbrc	r25, 0
    214a:	1d c0       	rjmp	.+58     	; 0x2186 <Endpoint_WaitUntilReady+0x6a>
    214c:	20 c0       	rjmp	.+64     	; 0x218e <Endpoint_WaitUntilReady+0x72>
		{
			if (Endpoint_IsOUTReceived())
			  return ENDPOINT_READYWAIT_NoError;
		}

		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    214e:	80 91 62 0a 	lds	r24, 0x0A62	; 0x800a62 <USB_DeviceState>

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    2152:	88 23       	and	r24, r24
    2154:	81 f0       	breq	.+32     	; 0x2176 <Endpoint_WaitUntilReady+0x5a>
		  return ENDPOINT_READYWAIT_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    2156:	85 30       	cpi	r24, 0x05	; 5
    2158:	81 f0       	breq	.+32     	; 0x217a <Endpoint_WaitUntilReady+0x5e>
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
    215a:	e8 01       	movw	r28, r16
    215c:	88 81       	ld	r24, Y
		  return ENDPOINT_READYWAIT_BusSuspended;
		else if (Endpoint_IsStalled())
    215e:	85 fd       	sbrc	r24, 5
    2160:	0e c0       	rjmp	.+28     	; 0x217e <Endpoint_WaitUntilReady+0x62>
    2162:	ea 01       	movw	r28, r20
    2164:	88 81       	ld	r24, Y
    2166:	99 81       	ldd	r25, Y+1	; 0x01
		  return ENDPOINT_READYWAIT_EndpointStalled;

		uint16_t CurrentFrameNumber = USB_Device_GetFrameNumber();

		if (CurrentFrameNumber != PreviousFrameNumber)
    2168:	28 17       	cp	r18, r24
    216a:	39 07       	cpc	r19, r25
    216c:	51 f3       	breq	.-44     	; 0x2142 <Endpoint_WaitUntilReady+0x26>
    216e:	61 50       	subi	r22, 0x01	; 1
		{
			PreviousFrameNumber = CurrentFrameNumber;

			if (!(TimeoutMSRem--))
    2170:	39 f7       	brne	.-50     	; 0x2140 <Endpoint_WaitUntilReady+0x24>
			  return ENDPOINT_READYWAIT_Timeout;
    2172:	84 e0       	ldi	r24, 0x04	; 4
    2174:	0f c0       	rjmp	.+30     	; 0x2194 <Endpoint_WaitUntilReady+0x78>
		}

		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_READYWAIT_DeviceDisconnected;
    2176:	82 e0       	ldi	r24, 0x02	; 2
    2178:	0d c0       	rjmp	.+26     	; 0x2194 <Endpoint_WaitUntilReady+0x78>
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_READYWAIT_BusSuspended;
    217a:	83 e0       	ldi	r24, 0x03	; 3
    217c:	0b c0       	rjmp	.+22     	; 0x2194 <Endpoint_WaitUntilReady+0x78>
		else if (Endpoint_IsStalled())
		  return ENDPOINT_READYWAIT_EndpointStalled;
    217e:	81 e0       	ldi	r24, 0x01	; 1
    2180:	09 c0       	rjmp	.+18     	; 0x2194 <Endpoint_WaitUntilReady+0x78>
	for (;;)
	{
		if (Endpoint_GetEndpointDirection() == ENDPOINT_DIR_IN)
		{
			if (Endpoint_IsINReady())
			  return ENDPOINT_READYWAIT_NoError;
    2182:	80 e0       	ldi	r24, 0x00	; 0
    2184:	07 c0       	rjmp	.+14     	; 0x2194 <Endpoint_WaitUntilReady+0x78>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    2186:	80 81       	ld	r24, Z

	for (;;)
	{
		if (Endpoint_GetEndpointDirection() == ENDPOINT_DIR_IN)
		{
			if (Endpoint_IsINReady())
    2188:	80 ff       	sbrs	r24, 0
    218a:	e1 cf       	rjmp	.-62     	; 0x214e <Endpoint_WaitUntilReady+0x32>
    218c:	fa cf       	rjmp	.-12     	; 0x2182 <Endpoint_WaitUntilReady+0x66>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    218e:	90 81       	ld	r25, Z
			  return ENDPOINT_READYWAIT_NoError;
		}
		else
		{
			if (Endpoint_IsOUTReceived())
    2190:	92 ff       	sbrs	r25, 2
    2192:	dd cf       	rjmp	.-70     	; 0x214e <Endpoint_WaitUntilReady+0x32>

			if (!(TimeoutMSRem--))
			  return ENDPOINT_READYWAIT_Timeout;
		}
	}
}
    2194:	df 91       	pop	r29
    2196:	cf 91       	pop	r28
    2198:	1f 91       	pop	r17
    219a:	0f 91       	pop	r16
    219c:	08 95       	ret

0000219e <USB_ResetInterface>:

	USB_IsInitialized = false;
}

void USB_ResetInterface(void)
{
    219e:	0f 93       	push	r16
    21a0:	1f 93       	push	r17
    21a2:	cf 93       	push	r28
	#if defined(USB_CAN_BE_BOTH)
	bool UIDModeSelectEnabled = ((UHWCON & (1 << UIDE)) != 0);
	#endif

	USB_INT_DisableAllInterrupts();
	USB_INT_ClearAllInterrupts();
    21a4:	df 93       	push	r29
    21a6:	4c d0       	rcall	.+152    	; 0x2240 <USB_INT_DisableAllInterrupts>
			}

			static inline void USB_Controller_Reset(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Controller_Reset(void)
			{
				USBCON &= ~(1 << USBE);
    21a8:	53 d0       	rcall	.+166    	; 0x2250 <USB_INT_ClearAllInterrupts>
    21aa:	c8 ed       	ldi	r28, 0xD8	; 216
    21ac:	d0 e0       	ldi	r29, 0x00	; 0
    21ae:	88 81       	ld	r24, Y
    21b0:	8f 77       	andi	r24, 0x7F	; 127
				USBCON |=  (1 << USBE);
    21b2:	88 83       	st	Y, r24
    21b4:	88 81       	ld	r24, Y
    21b6:	80 68       	ori	r24, 0x80	; 128
			}

			static inline void USB_CLK_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Unfreeze(void)
			{
				USBCON &= ~(1 << FRZCLK);
    21b8:	88 83       	st	Y, r24
    21ba:	88 81       	ld	r24, Y
    21bc:	8f 7d       	andi	r24, 0xDF	; 223
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
    21be:	88 83       	st	Y, r24
}

#if defined(USB_CAN_BE_DEVICE)
static void USB_Init_Device(void)
{
	USB_DeviceState                 = DEVICE_STATE_Unattached;
    21c0:	19 bc       	out	0x29, r1	; 41
    21c2:	10 92 62 0a 	sts	0x0A62, r1	; 0x800a62 <USB_DeviceState>
	USB_Device_ConfigurationNumber  = 0;
    21c6:	10 92 5e 0a 	sts	0x0A5E, r1	; 0x800a5e <USB_Device_ConfigurationNumber>

	#if !defined(NO_DEVICE_REMOTE_WAKEUP)
	USB_Device_RemoteWakeupEnabled  = false;
    21ca:	10 92 60 0a 	sts	0x0A60, r1	; 0x800a60 <USB_Device_RemoteWakeupEnabled>
	#endif

	#if !defined(NO_DEVICE_SELF_POWER)
	USB_Device_CurrentlySelfPowered = false;
    21ce:	10 92 5f 0a 	sts	0x0A5F, r1	; 0x800a5f <USB_Device_CurrentlySelfPowered>
			}

			static inline void USB_Device_SetFullSpeed(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_SetFullSpeed(void)
			{
				UDCON &= ~(1 << LSM);
    21d2:	00 ee       	ldi	r16, 0xE0	; 224
    21d4:	10 e0       	ldi	r17, 0x00	; 0
    21d6:	f8 01       	movw	r30, r16
    21d8:	80 81       	ld	r24, Z
    21da:	8b 7f       	andi	r24, 0xFB	; 251
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						USBCON |= (1 << VBUSTE);
    21dc:	80 83       	st	Z, r24
    21de:	88 81       	ld	r24, Y
    21e0:	81 60       	ori	r24, 0x01	; 1
				uint8_t Number = (Address & ENDPOINT_EPNUM_MASK);

				if (Number >= ENDPOINT_TOTAL_ENDPOINTS)
				  return false;

				return Endpoint_ConfigureEndpoint_Prv(Number,
    21e2:	88 83       	st	Y, r24
    21e4:	42 e0       	ldi	r20, 0x02	; 2
    21e6:	60 e0       	ldi	r22, 0x00	; 0
    21e8:	80 e0       	ldi	r24, 0x00	; 0
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
    21ea:	0e df       	rcall	.-484    	; 0x2008 <Endpoint_ConfigureEndpoint_Prv>
    21ec:	e1 ee       	ldi	r30, 0xE1	; 225
    21ee:	f0 e0       	ldi	r31, 0x00	; 0
    21f0:	80 81       	ld	r24, Z
    21f2:	8e 7f       	andi	r24, 0xFE	; 254
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  |= (1 << SUSPE);
    21f4:	80 83       	st	Z, r24
    21f6:	e2 ee       	ldi	r30, 0xE2	; 226
    21f8:	f0 e0       	ldi	r31, 0x00	; 0
    21fa:	80 81       	ld	r24, Z
    21fc:	81 60       	ori	r24, 0x01	; 1
						break;
					case USB_INT_EORSTI:
						UDIEN  |= (1 << EORSTE);
    21fe:	80 83       	st	Z, r24
    2200:	80 81       	ld	r24, Z
    2202:	88 60       	ori	r24, 0x08	; 8
			 *  register and despite the datasheet making no mention of its requirement in host mode.
			 */
			static inline void USB_Attach(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Attach(void)
			{
				UDCON  &= ~(1 << DETACH);
    2204:	80 83       	st	Z, r24
    2206:	f8 01       	movw	r30, r16
    2208:	80 81       	ld	r24, Z
    220a:	8e 7f       	andi	r24, 0xFE	; 254

			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
			static inline void USB_OTGPAD_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_OTGPAD_On(void)
			{
				USBCON |=  (1 << OTGPADE);
    220c:	80 83       	st	Z, r24
    220e:	88 81       	ld	r24, Y
    2210:	80 61       	ori	r24, 0x10	; 16
	}

	#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
	USB_OTGPAD_On();
	#endif
}
    2212:	88 83       	st	Y, r24
    2214:	df 91       	pop	r29
    2216:	cf 91       	pop	r28
    2218:	1f 91       	pop	r17
    221a:	0f 91       	pop	r16
    221c:	08 95       	ret

0000221e <USB_Init>:
			}

			static inline void USB_OTGPAD_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_OTGPAD_Off(void)
			{
				USBCON &= ~(1 << OTGPADE);
    221e:	e8 ed       	ldi	r30, 0xD8	; 216
    2220:	f0 e0       	ldi	r31, 0x00	; 0
    2222:	80 81       	ld	r24, Z
    2224:	8f 7e       	andi	r24, 0xEF	; 239
    2226:	80 83       	st	Z, r24

			static inline void USB_REG_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_REG_On(void)
			{
			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
				UHWCON |=  (1 << UVREGE);
    2228:	e7 ed       	ldi	r30, 0xD7	; 215
    222a:	f0 e0       	ldi	r31, 0x00	; 0
    222c:	80 81       	ld	r24, Z
    222e:	81 60       	ori	r24, 0x01	; 1
    2230:	80 83       	st	Z, r24
	  USB_REG_Off();

	if (!(USB_Options & USB_OPT_MANUAL_PLL))
	{
		#if defined(USB_SERIES_4_AVR)
		PLLFRQ = (1 << PDIV2);
    2232:	84 e0       	ldi	r24, 0x04	; 4
    2234:	82 bf       	out	0x32, r24	; 50
		UHWCON &= ~(1 << UIDE);
		USB_CurrentMode = Mode;
	}
	#endif

	USB_IsInitialized = true;
    2236:	81 e0       	ldi	r24, 0x01	; 1
    2238:	80 93 61 0a 	sts	0x0A61, r24	; 0x800a61 <USB_IsInitialized>

	USB_ResetInterface();
    223c:	b0 cf       	rjmp	.-160    	; 0x219e <USB_ResetInterface>
    223e:	08 95       	ret

00002240 <USB_INT_DisableAllInterrupts>:
void USB_INT_DisableAllInterrupts(void)
{
	#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	USBCON &= ~((1 << VBUSTE) | (1 << IDTE));
	#elif defined(USB_SERIES_4_AVR)
	USBCON &= ~(1 << VBUSTE);
    2240:	e8 ed       	ldi	r30, 0xD8	; 216
    2242:	f0 e0       	ldi	r31, 0x00	; 0
    2244:	80 81       	ld	r24, Z
    2246:	8e 7f       	andi	r24, 0xFE	; 254
    2248:	80 83       	st	Z, r24
	#if defined(USB_CAN_BE_HOST)
	UHIEN   = 0;
	#endif

	#if defined(USB_CAN_BE_DEVICE)
	UDIEN   = 0;
    224a:	10 92 e2 00 	sts	0x00E2, r1	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7e00e2>
    224e:	08 95       	ret

00002250 <USB_INT_ClearAllInterrupts>:
}

void USB_INT_ClearAllInterrupts(void)
{
	#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	USBINT = 0;
    2250:	10 92 da 00 	sts	0x00DA, r1	; 0x8000da <__TEXT_REGION_LENGTH__+0x7e00da>
	#if defined(USB_CAN_BE_HOST)
	UHINT  = 0;
	#endif

	#if defined(USB_CAN_BE_DEVICE)
	UDINT  = 0;
    2254:	10 92 e1 00 	sts	0x00E1, r1	; 0x8000e1 <__TEXT_REGION_LENGTH__+0x7e00e1>
    2258:	08 95       	ret

0000225a <__vector_10>:
	#endif
}

ISR(USB_GEN_vect, ISR_BLOCK)
{
    225a:	1f 92       	push	r1
    225c:	0f 92       	push	r0
    225e:	0f b6       	in	r0, 0x3f	; 63
    2260:	0f 92       	push	r0
    2262:	11 24       	eor	r1, r1
    2264:	2f 93       	push	r18
    2266:	3f 93       	push	r19
    2268:	4f 93       	push	r20
    226a:	5f 93       	push	r21
    226c:	6f 93       	push	r22
    226e:	7f 93       	push	r23
    2270:	8f 93       	push	r24
    2272:	9f 93       	push	r25
    2274:	af 93       	push	r26
    2276:	bf 93       	push	r27
    2278:	ef 93       	push	r30
    227a:	ff 93       	push	r31
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
					case USB_INT_EORSTI:
						return (UDINT  & (1 << EORSTI));
					case USB_INT_SOFI:
						return (UDINT  & (1 << SOFI));
    227c:	80 91 e1 00 	lds	r24, 0x00E1	; 0x8000e1 <__TEXT_REGION_LENGTH__+0x7e00e1>
	#if defined(USB_CAN_BE_DEVICE)
	#if !defined(NO_SOF_EVENTS)
	if (USB_INT_HasOccurred(USB_INT_SOFI) && USB_INT_IsEnabled(USB_INT_SOFI))
    2280:	82 ff       	sbrs	r24, 2
    2282:	0a c0       	rjmp	.+20     	; 0x2298 <__vector_10+0x3e>
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
					case USB_INT_EORSTI:
						return (UDIEN  & (1 << EORSTE));
					case USB_INT_SOFI:
						return (UDIEN  & (1 << SOFE));
    2284:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7e00e2>
    2288:	82 ff       	sbrs	r24, 2
    228a:	06 c0       	rjmp	.+12     	; 0x2298 <__vector_10+0x3e>
						break;
					case USB_INT_EORSTI:
						UDINT  &= ~(1 << EORSTI);
						break;
					case USB_INT_SOFI:
						UDINT  &= ~(1 << SOFI);
    228c:	e1 ee       	ldi	r30, 0xE1	; 225
    228e:	f0 e0       	ldi	r31, 0x00	; 0
    2290:	80 81       	ld	r24, Z
    2292:	8b 7f       	andi	r24, 0xFB	; 251
	{
		USB_INT_Clear(USB_INT_SOFI);

		EVENT_USB_Device_StartOfFrame();
    2294:	80 83       	st	Z, r24
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						return (USBINT & (1 << VBUSTI));
    2296:	1a d2       	rcall	.+1076   	; 0x26cc <USB_Event_Stub>
    2298:	80 91 da 00 	lds	r24, 0x00DA	; 0x8000da <__TEXT_REGION_LENGTH__+0x7e00da>
	}
	#endif

	#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	if (USB_INT_HasOccurred(USB_INT_VBUSTI) && USB_INT_IsEnabled(USB_INT_VBUSTI))
    229c:	80 ff       	sbrs	r24, 0
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						return (USBCON & (1 << VBUSTE));
    229e:	1d c0       	rjmp	.+58     	; 0x22da <__vector_10+0x80>
    22a0:	80 91 d8 00 	lds	r24, 0x00D8	; 0x8000d8 <__TEXT_REGION_LENGTH__+0x7e00d8>
    22a4:	80 ff       	sbrs	r24, 0
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						USBINT &= ~(1 << VBUSTI);
    22a6:	19 c0       	rjmp	.+50     	; 0x22da <__vector_10+0x80>
    22a8:	ea ed       	ldi	r30, 0xDA	; 218
    22aa:	f0 e0       	ldi	r31, 0x00	; 0
    22ac:	80 81       	ld	r24, Z
    22ae:	8e 7f       	andi	r24, 0xFE	; 254
				 *  \return Boolean \c true if the VBUS line is currently detecting power from a host, \c false otherwise.
				 */
				static inline bool USB_VBUS_GetStatus(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
				static inline bool USB_VBUS_GetStatus(void)
				{
					return ((USBSTA & (1 << VBUS)) ? true : false);
    22b0:	80 83       	st	Z, r24
    22b2:	80 91 d9 00 	lds	r24, 0x00D9	; 0x8000d9 <__TEXT_REGION_LENGTH__+0x7e00d9>
	{
		USB_INT_Clear(USB_INT_VBUSTI);

		if (USB_VBUS_GetStatus())
    22b6:	80 ff       	sbrs	r24, 0

		/* Inline Functions: */
			static inline void USB_PLL_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_On(void)
			{
				PLLCSR = USB_PLL_PSC;
    22b8:	0c c0       	rjmp	.+24     	; 0x22d2 <__vector_10+0x78>
    22ba:	80 e1       	ldi	r24, 0x10	; 16
				PLLCSR = (USB_PLL_PSC | (1 << PLLE));
    22bc:	89 bd       	out	0x29, r24	; 41
    22be:	82 e1       	ldi	r24, 0x12	; 18
		{
			if (!(USB_Options & USB_OPT_MANUAL_PLL))
			{
				USB_PLL_On();
				while (!(USB_PLL_IsReady()));
    22c0:	89 bd       	out	0x29, r24	; 41
    22c2:	09 b4       	in	r0, 0x29	; 41
    22c4:	00 fe       	sbrs	r0, 0
			}

			USB_DeviceState = DEVICE_STATE_Powered;
    22c6:	fd cf       	rjmp	.-6      	; 0x22c2 <__vector_10+0x68>
    22c8:	81 e0       	ldi	r24, 0x01	; 1
			EVENT_USB_Device_Connect();
    22ca:	80 93 62 0a 	sts	0x0A62, r24	; 0x800a62 <USB_DeviceState>
    22ce:	aa db       	rcall	.-2220   	; 0x1a24 <EVENT_USB_Device_Connect>
		else
		{
			if (!(USB_Options & USB_OPT_MANUAL_PLL))
			  USB_PLL_Off();

			USB_DeviceState = DEVICE_STATE_Unattached;
    22d0:	04 c0       	rjmp	.+8      	; 0x22da <__vector_10+0x80>
			EVENT_USB_Device_Disconnect();
    22d2:	19 bc       	out	0x29, r1	; 41
    22d4:	10 92 62 0a 	sts	0x0A62, r1	; 0x800a62 <USB_DeviceState>
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
    22d8:	a9 db       	rcall	.-2222   	; 0x1a2c <EVENT_USB_Device_Disconnect>
		}
	}
	#endif

	if (USB_INT_HasOccurred(USB_INT_SUSPI) && USB_INT_IsEnabled(USB_INT_SUSPI))
    22da:	80 91 e1 00 	lds	r24, 0x00E1	; 0x8000e1 <__TEXT_REGION_LENGTH__+0x7e00e1>
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
    22de:	80 ff       	sbrs	r24, 0
    22e0:	16 c0       	rjmp	.+44     	; 0x230e <__vector_10+0xb4>
    22e2:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7e00e2>
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  &= ~(1 << SUSPE);
    22e6:	80 ff       	sbrs	r24, 0
    22e8:	12 c0       	rjmp	.+36     	; 0x230e <__vector_10+0xb4>
    22ea:	e2 ee       	ldi	r30, 0xE2	; 226
    22ec:	f0 e0       	ldi	r31, 0x00	; 0
    22ee:	80 81       	ld	r24, Z
						USBCON |= (1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
    22f0:	8e 7f       	andi	r24, 0xFE	; 254
    22f2:	80 83       	st	Z, r24
    22f4:	80 81       	ld	r24, Z
			#endif

			static inline void USB_CLK_Freeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Freeze(void)
			{
				USBCON |=  (1 << FRZCLK);
    22f6:	80 61       	ori	r24, 0x10	; 16
    22f8:	80 83       	st	Z, r24
    22fa:	e8 ed       	ldi	r30, 0xD8	; 216
    22fc:	f0 e0       	ldi	r31, 0x00	; 0
    22fe:	80 81       	ld	r24, Z

		#if defined(USB_SERIES_2_AVR) && !defined(NO_LIMITED_CONTROLLER_CONNECT)
		USB_DeviceState = DEVICE_STATE_Unattached;
		EVENT_USB_Device_Disconnect();
		#else
		USB_DeviceState = DEVICE_STATE_Suspended;
    2300:	80 62       	ori	r24, 0x20	; 32
    2302:	80 83       	st	Z, r24
		EVENT_USB_Device_Suspend();
    2304:	19 bc       	out	0x29, r1	; 41
    2306:	85 e0       	ldi	r24, 0x05	; 5
					case USB_INT_IDTI:
						return (USBINT & (1 << IDTI));
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
    2308:	80 93 62 0a 	sts	0x0A62, r24	; 0x800a62 <USB_DeviceState>
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_WAKEUPI) && USB_INT_IsEnabled(USB_INT_WAKEUPI))
    230c:	df d1       	rcall	.+958    	; 0x26cc <USB_Event_Stub>
    230e:	80 91 e1 00 	lds	r24, 0x00E1	; 0x8000e1 <__TEXT_REGION_LENGTH__+0x7e00e1>
					case USB_INT_IDTI:
						return (USBCON & (1 << IDTE));
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
    2312:	84 ff       	sbrs	r24, 4
    2314:	2f c0       	rjmp	.+94     	; 0x2374 <__vector_10+0x11a>
    2316:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7e00e2>

		/* Inline Functions: */
			static inline void USB_PLL_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_On(void)
			{
				PLLCSR = USB_PLL_PSC;
    231a:	84 ff       	sbrs	r24, 4
				PLLCSR = (USB_PLL_PSC | (1 << PLLE));
    231c:	2b c0       	rjmp	.+86     	; 0x2374 <__vector_10+0x11a>
    231e:	80 e1       	ldi	r24, 0x10	; 16
	{
		if (!(USB_Options & USB_OPT_MANUAL_PLL))
		{
			USB_PLL_On();
			while (!(USB_PLL_IsReady()));
    2320:	89 bd       	out	0x29, r24	; 41
    2322:	82 e1       	ldi	r24, 0x12	; 18
    2324:	89 bd       	out	0x29, r24	; 41
			}

			static inline void USB_CLK_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Unfreeze(void)
			{
				USBCON &= ~(1 << FRZCLK);
    2326:	09 b4       	in	r0, 0x29	; 41
    2328:	00 fe       	sbrs	r0, 0
    232a:	fd cf       	rjmp	.-6      	; 0x2326 <__vector_10+0xcc>
    232c:	e8 ed       	ldi	r30, 0xD8	; 216
    232e:	f0 e0       	ldi	r31, 0x00	; 0
						USBINT &= ~(1 << IDTI);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
    2330:	80 81       	ld	r24, Z
    2332:	8f 7d       	andi	r24, 0xDF	; 223
    2334:	80 83       	st	Z, r24
    2336:	e1 ee       	ldi	r30, 0xE1	; 225
    2338:	f0 e0       	ldi	r31, 0x00	; 0
						USBCON &= ~(1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
    233a:	80 81       	ld	r24, Z
    233c:	8f 7e       	andi	r24, 0xEF	; 239
    233e:	80 83       	st	Z, r24
    2340:	e2 ee       	ldi	r30, 0xE2	; 226
    2342:	f0 e0       	ldi	r31, 0x00	; 0
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  |= (1 << SUSPE);
    2344:	80 81       	ld	r24, Z
    2346:	8f 7e       	andi	r24, 0xEF	; 239
    2348:	80 83       	st	Z, r24
		USB_INT_Clear(USB_INT_WAKEUPI);

		USB_INT_Disable(USB_INT_WAKEUPI);
		USB_INT_Enable(USB_INT_SUSPI);

		if (USB_Device_ConfigurationNumber)
    234a:	80 81       	ld	r24, Z
    234c:	81 60       	ori	r24, 0x01	; 1
    234e:	80 83       	st	Z, r24
    2350:	80 91 5e 0a 	lds	r24, 0x0A5E	; 0x800a5e <USB_Device_ConfigurationNumber>
		  USB_DeviceState = DEVICE_STATE_Configured;
    2354:	88 23       	and	r24, r24
    2356:	21 f0       	breq	.+8      	; 0x2360 <__vector_10+0x106>
    2358:	84 e0       	ldi	r24, 0x04	; 4
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return (UDADDR & (1 << ADDEN));
    235a:	80 93 62 0a 	sts	0x0A62, r24	; 0x800a62 <USB_DeviceState>
		else
		  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Addressed : DEVICE_STATE_Powered;
    235e:	09 c0       	rjmp	.+18     	; 0x2372 <__vector_10+0x118>
    2360:	80 91 e3 00 	lds	r24, 0x00E3	; 0x8000e3 <__TEXT_REGION_LENGTH__+0x7e00e3>
    2364:	88 23       	and	r24, r24
    2366:	14 f0       	brlt	.+4      	; 0x236c <__vector_10+0x112>
    2368:	81 e0       	ldi	r24, 0x01	; 1

		#if defined(USB_SERIES_2_AVR) && !defined(NO_LIMITED_CONTROLLER_CONNECT)
		EVENT_USB_Device_Connect();
		#else
		EVENT_USB_Device_WakeUp();
    236a:	01 c0       	rjmp	.+2      	; 0x236e <__vector_10+0x114>
    236c:	83 e0       	ldi	r24, 0x03	; 3
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
					case USB_INT_EORSTI:
						return (UDINT  & (1 << EORSTI));
    236e:	80 93 62 0a 	sts	0x0A62, r24	; 0x800a62 <USB_DeviceState>
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_EORSTI) && USB_INT_IsEnabled(USB_INT_EORSTI))
    2372:	ac d1       	rcall	.+856    	; 0x26cc <USB_Event_Stub>
    2374:	80 91 e1 00 	lds	r24, 0x00E1	; 0x8000e1 <__TEXT_REGION_LENGTH__+0x7e00e1>
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
					case USB_INT_EORSTI:
						return (UDIEN  & (1 << EORSTE));
    2378:	83 ff       	sbrs	r24, 3
    237a:	1e c0       	rjmp	.+60     	; 0x23b8 <__vector_10+0x15e>
    237c:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7e00e2>
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
						break;
					case USB_INT_EORSTI:
						UDINT  &= ~(1 << EORSTI);
    2380:	83 ff       	sbrs	r24, 3
    2382:	1a c0       	rjmp	.+52     	; 0x23b8 <__vector_10+0x15e>
    2384:	e1 ee       	ldi	r30, 0xE1	; 225
    2386:	f0 e0       	ldi	r31, 0x00	; 0
	{
		USB_INT_Clear(USB_INT_EORSTI);

		USB_DeviceState                = DEVICE_STATE_Default;
    2388:	80 81       	ld	r24, Z
    238a:	87 7f       	andi	r24, 0xF7	; 247
    238c:	80 83       	st	Z, r24
		USB_Device_ConfigurationNumber = 0;
    238e:	82 e0       	ldi	r24, 0x02	; 2
    2390:	80 93 62 0a 	sts	0x0A62, r24	; 0x800a62 <USB_DeviceState>
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
    2394:	10 92 5e 0a 	sts	0x0A5E, r1	; 0x800a5e <USB_Device_ConfigurationNumber>
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  &= ~(1 << SUSPE);
    2398:	80 81       	ld	r24, Z
    239a:	8e 7f       	andi	r24, 0xFE	; 254
    239c:	80 83       	st	Z, r24
    239e:	e2 ee       	ldi	r30, 0xE2	; 226
    23a0:	f0 e0       	ldi	r31, 0x00	; 0
						USBCON |= (1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
    23a2:	80 81       	ld	r24, Z
				uint8_t Number = (Address & ENDPOINT_EPNUM_MASK);

				if (Number >= ENDPOINT_TOTAL_ENDPOINTS)
				  return false;

				return Endpoint_ConfigureEndpoint_Prv(Number,
    23a4:	8e 7f       	andi	r24, 0xFE	; 254
    23a6:	80 83       	st	Z, r24
    23a8:	80 81       	ld	r24, Z
    23aa:	80 61       	ori	r24, 0x10	; 16
    23ac:	80 83       	st	Z, r24

		#if defined(INTERRUPT_CONTROL_ENDPOINT)
		USB_INT_Enable(USB_INT_RXSTPI);
		#endif

		EVENT_USB_Device_Reset();
    23ae:	42 e0       	ldi	r20, 0x02	; 2
    23b0:	60 e0       	ldi	r22, 0x00	; 0
		USB_ResetInterface();

		EVENT_USB_UIDChange();
	}
	#endif
}
    23b2:	80 e0       	ldi	r24, 0x00	; 0
    23b4:	29 de       	rcall	.-942    	; 0x2008 <Endpoint_ConfigureEndpoint_Prv>
    23b6:	8a d1       	rcall	.+788    	; 0x26cc <USB_Event_Stub>
    23b8:	ff 91       	pop	r31
    23ba:	ef 91       	pop	r30
    23bc:	bf 91       	pop	r27
    23be:	af 91       	pop	r26
    23c0:	9f 91       	pop	r25
    23c2:	8f 91       	pop	r24
    23c4:	7f 91       	pop	r23
    23c6:	6f 91       	pop	r22
    23c8:	5f 91       	pop	r21
    23ca:	4f 91       	pop	r20
    23cc:	3f 91       	pop	r19
    23ce:	2f 91       	pop	r18
    23d0:	0f 90       	pop	r0
    23d2:	0f be       	out	0x3f, r0	; 63
    23d4:	0f 90       	pop	r0
    23d6:	1f 90       	pop	r1
    23d8:	18 95       	reti

000023da <USB_Device_ProcessControlRequest>:
#if !defined(NO_DEVICE_REMOTE_WAKEUP)
bool    USB_Device_RemoteWakeupEnabled;
#endif

void USB_Device_ProcessControlRequest(void)
{
    23da:	0f 93       	push	r16
    23dc:	1f 93       	push	r17
    23de:	cf 93       	push	r28
    23e0:	df 93       	push	r29
    23e2:	cd b7       	in	r28, 0x3d	; 61
    23e4:	de b7       	in	r29, 0x3e	; 62
    23e6:	aa 97       	sbiw	r28, 0x2a	; 42
    23e8:	0f b6       	in	r0, 0x3f	; 63
    23ea:	f8 94       	cli
    23ec:	de bf       	out	0x3e, r29	; 62
    23ee:	0f be       	out	0x3f, r0	; 63
    23f0:	cd bf       	out	0x3d, r28	; 61
    23f2:	e3 e6       	ldi	r30, 0x63	; 99
    23f4:	fa e0       	ldi	r31, 0x0A	; 10
    23f6:	2b e6       	ldi	r18, 0x6B	; 107
    23f8:	3a e0       	ldi	r19, 0x0A	; 10
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_8(void)
			{
				return UEDATX;
    23fa:	a1 ef       	ldi	r26, 0xF1	; 241
    23fc:	b0 e0       	ldi	r27, 0x00	; 0
    23fe:	8c 91       	ld	r24, X
	USB_ControlRequest.wLength       = Endpoint_Read_16_LE();
	#else
	uint8_t* RequestHeader = (uint8_t*)&USB_ControlRequest;

	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
	  *(RequestHeader++) = Endpoint_Read_8();
    2400:	81 93       	st	Z+, r24
	USB_ControlRequest.wIndex        = Endpoint_Read_16_LE();
	USB_ControlRequest.wLength       = Endpoint_Read_16_LE();
	#else
	uint8_t* RequestHeader = (uint8_t*)&USB_ControlRequest;

	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
    2402:	2e 17       	cp	r18, r30
    2404:	3f 07       	cpc	r19, r31
	  *(RequestHeader++) = Endpoint_Read_8();
	#endif

	EVENT_USB_Device_ControlRequest();
    2406:	d9 f7       	brne	.-10     	; 0x23fe <USB_Device_ProcessControlRequest+0x24>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    2408:	16 dc       	rcall	.-2004   	; 0x1c36 <EVENT_USB_Device_ControlRequest>
    240a:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>

	if (Endpoint_IsSETUPReceived())
    240e:	83 ff       	sbrs	r24, 3
	{
		uint8_t bmRequestType = USB_ControlRequest.bmRequestType;
    2410:	38 c1       	rjmp	.+624    	; 0x2682 <USB_Device_ProcessControlRequest+0x2a8>
    2412:	e3 e6       	ldi	r30, 0x63	; 99
    2414:	fa e0       	ldi	r31, 0x0A	; 10

		switch (USB_ControlRequest.bRequest)
    2416:	90 81       	ld	r25, Z
    2418:	81 81       	ldd	r24, Z+1	; 0x01
    241a:	85 30       	cpi	r24, 0x05	; 5
    241c:	09 f4       	brne	.+2      	; 0x2420 <USB_Device_ProcessControlRequest+0x46>
    241e:	7f c0       	rjmp	.+254    	; 0x251e <USB_Device_ProcessControlRequest+0x144>
    2420:	30 f4       	brcc	.+12     	; 0x242e <USB_Device_ProcessControlRequest+0x54>
    2422:	81 30       	cpi	r24, 0x01	; 1
    2424:	c9 f1       	breq	.+114    	; 0x2498 <USB_Device_ProcessControlRequest+0xbe>
    2426:	68 f0       	brcs	.+26     	; 0x2442 <USB_Device_ProcessControlRequest+0x68>
    2428:	83 30       	cpi	r24, 0x03	; 3
    242a:	b1 f1       	breq	.+108    	; 0x2498 <USB_Device_ProcessControlRequest+0xbe>
    242c:	2a c1       	rjmp	.+596    	; 0x2682 <USB_Device_ProcessControlRequest+0x2a8>
    242e:	88 30       	cpi	r24, 0x08	; 8
    2430:	09 f4       	brne	.+2      	; 0x2434 <USB_Device_ProcessControlRequest+0x5a>
    2432:	f2 c0       	rjmp	.+484    	; 0x2618 <USB_Device_ProcessControlRequest+0x23e>
    2434:	89 30       	cpi	r24, 0x09	; 9
    2436:	09 f4       	brne	.+2      	; 0x243a <USB_Device_ProcessControlRequest+0x60>
    2438:	ff c0       	rjmp	.+510    	; 0x2638 <USB_Device_ProcessControlRequest+0x25e>
    243a:	86 30       	cpi	r24, 0x06	; 6
    243c:	09 f0       	breq	.+2      	; 0x2440 <USB_Device_ProcessControlRequest+0x66>
    243e:	21 c1       	rjmp	.+578    	; 0x2682 <USB_Device_ProcessControlRequest+0x2a8>
		{
			case REQ_GetStatus:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    2440:	91 c0       	rjmp	.+290    	; 0x2564 <USB_Device_ProcessControlRequest+0x18a>
    2442:	90 38       	cpi	r25, 0x80	; 128
    2444:	21 f0       	breq	.+8      	; 0x244e <USB_Device_ProcessControlRequest+0x74>
    2446:	92 38       	cpi	r25, 0x82	; 130
    2448:	09 f0       	breq	.+2      	; 0x244c <USB_Device_ProcessControlRequest+0x72>
    244a:	1b c1       	rjmp	.+566    	; 0x2682 <USB_Device_ProcessControlRequest+0x2a8>
	Endpoint_ClearOUT();
}

static void USB_Device_GetStatus(void)
{
	uint8_t CurrentStatus = 0;
    244c:	08 c0       	rjmp	.+16     	; 0x245e <USB_Device_ProcessControlRequest+0x84>
    244e:	80 91 5f 0a 	lds	r24, 0x0A5F	; 0x800a5f <USB_Device_CurrentlySelfPowered>
			if (USB_Device_CurrentlySelfPowered)
			  CurrentStatus |= FEATURE_SELFPOWERED_ENABLED;
			#endif

			#if !defined(NO_DEVICE_REMOTE_WAKEUP)
			if (USB_Device_RemoteWakeupEnabled)
    2452:	90 91 60 0a 	lds	r25, 0x0A60	; 0x800a60 <USB_Device_RemoteWakeupEnabled>
    2456:	99 23       	and	r25, r25
			  CurrentStatus |= FEATURE_REMOTE_WAKEUP_ENABLED;
    2458:	89 f0       	breq	.+34     	; 0x247c <USB_Device_ProcessControlRequest+0xa2>
    245a:	82 60       	ori	r24, 0x02	; 2
			break;
		}
		case (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_ENDPOINT):
		{
			#if !defined(CONTROL_ONLY_DEVICE)
			uint8_t EndpointIndex = ((uint8_t)USB_ControlRequest.wIndex & ENDPOINT_EPNUM_MASK);
    245c:	0f c0       	rjmp	.+30     	; 0x247c <USB_Device_ProcessControlRequest+0xa2>
    245e:	80 91 67 0a 	lds	r24, 0x0A67	; 0x800a67 <USB_ControlRequest+0x4>

			if (EndpointIndex >= ENDPOINT_TOTAL_ENDPOINTS)
    2462:	8f 70       	andi	r24, 0x0F	; 15
    2464:	87 30       	cpi	r24, 0x07	; 7
    2466:	08 f0       	brcs	.+2      	; 0x246a <USB_Device_ProcessControlRequest+0x90>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    2468:	0c c1       	rjmp	.+536    	; 0x2682 <USB_Device_ProcessControlRequest+0x2a8>
    246a:	e9 ee       	ldi	r30, 0xE9	; 233
    246c:	f0 e0       	ldi	r31, 0x00	; 0
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
    246e:	80 83       	st	Z, r24
    2470:	80 91 eb 00 	lds	r24, 0x00EB	; 0x8000eb <__TEXT_REGION_LENGTH__+0x7e00eb>
				return;

			Endpoint_SelectEndpoint(EndpointIndex);

			CurrentStatus = Endpoint_IsStalled();
    2474:	85 fb       	bst	r24, 5
    2476:	88 27       	eor	r24, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    2478:	80 f9       	bld	r24, 0
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    247a:	10 82       	st	Z, r1
    247c:	e8 ee       	ldi	r30, 0xE8	; 232
    247e:	f0 e0       	ldi	r31, 0x00	; 0
    2480:	90 81       	ld	r25, Z
    2482:	97 7f       	andi	r25, 0xF7	; 247
			 *  \param[in] Data  Data to write to the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_16_LE(const uint16_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_16_LE(const uint16_t Data)
			{
				UEDATX = (Data & 0xFF);
    2484:	90 83       	st	Z, r25
    2486:	a1 ef       	ldi	r26, 0xF1	; 241
    2488:	b0 e0       	ldi	r27, 0x00	; 0
				UEDATX = (Data >> 8);
    248a:	8c 93       	st	X, r24
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    248c:	1c 92       	st	X, r1
    248e:	80 81       	ld	r24, Z
	Endpoint_ClearSETUP();

	Endpoint_Write_16_LE(CurrentStatus);
	Endpoint_ClearIN();

	Endpoint_ClearStatusStage();
    2490:	8e 77       	andi	r24, 0x7E	; 126
    2492:	80 83       	st	Z, r24
    2494:	1f de       	rcall	.-962    	; 0x20d4 <Endpoint_ClearStatusStage>
				}

				break;
			case REQ_ClearFeature:
			case REQ_SetFeature:
				if ((bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    2496:	f5 c0       	rjmp	.+490    	; 0x2682 <USB_Device_ProcessControlRequest+0x2a8>
    2498:	99 23       	and	r25, r25
    249a:	09 f4       	brne	.+2      	; 0x249e <USB_Device_ProcessControlRequest+0xc4>
    249c:	01 c1       	rjmp	.+514    	; 0x26a0 <USB_Device_ProcessControlRequest+0x2c6>
    249e:	92 30       	cpi	r25, 0x02	; 2
    24a0:	09 f0       	breq	.+2      	; 0x24a4 <USB_Device_ProcessControlRequest+0xca>
    24a2:	ef c0       	rjmp	.+478    	; 0x2682 <USB_Device_ProcessControlRequest+0x2a8>
	{
		#if !defined(NO_DEVICE_REMOTE_WAKEUP)
		case REQREC_DEVICE:
		{
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_DeviceRemoteWakeup)
			  USB_Device_RemoteWakeupEnabled = (USB_ControlRequest.bRequest == REQ_SetFeature);
    24a4:	02 c1       	rjmp	.+516    	; 0x26aa <USB_Device_ProcessControlRequest+0x2d0>
    24a6:	91 e0       	ldi	r25, 0x01	; 1
    24a8:	83 30       	cpi	r24, 0x03	; 3
    24aa:	09 f0       	breq	.+2      	; 0x24ae <USB_Device_ProcessControlRequest+0xd4>
    24ac:	90 e0       	ldi	r25, 0x00	; 0
    24ae:	90 93 60 0a 	sts	0x0A60, r25	; 0x800a60 <USB_Device_RemoteWakeupEnabled>
		#if !defined(CONTROL_ONLY_DEVICE)
		case REQREC_ENDPOINT:
		{
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_EndpointHalt)
			{
				uint8_t EndpointIndex = ((uint8_t)USB_ControlRequest.wIndex & ENDPOINT_EPNUM_MASK);
    24b2:	2c c0       	rjmp	.+88     	; 0x250c <USB_Device_ProcessControlRequest+0x132>
    24b4:	80 91 67 0a 	lds	r24, 0x0A67	; 0x800a67 <USB_ControlRequest+0x4>

				if (EndpointIndex == ENDPOINT_CONTROLEP || EndpointIndex >= ENDPOINT_TOTAL_ENDPOINTS)
    24b8:	8f 70       	andi	r24, 0x0F	; 15
    24ba:	9f ef       	ldi	r25, 0xFF	; 255
    24bc:	98 0f       	add	r25, r24
    24be:	96 30       	cpi	r25, 0x06	; 6
    24c0:	08 f0       	brcs	.+2      	; 0x24c4 <USB_Device_ProcessControlRequest+0xea>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    24c2:	df c0       	rjmp	.+446    	; 0x2682 <USB_Device_ProcessControlRequest+0x2a8>
    24c4:	80 93 e9 00 	sts	0x00E9, r24	; 0x8000e9 <__TEXT_REGION_LENGTH__+0x7e00e9>
			 * \return Boolean \c true if the currently selected endpoint is enabled, \c false otherwise.
			 */
			static inline bool Endpoint_IsEnabled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsEnabled(void)
			{
				return ((UECONX & (1 << EPEN)) ? true : false);
    24c8:	90 91 eb 00 	lds	r25, 0x00EB	; 0x8000eb <__TEXT_REGION_LENGTH__+0x7e00eb>
				  return;

				Endpoint_SelectEndpoint(EndpointIndex);

				if (Endpoint_IsEnabled())
    24cc:	90 ff       	sbrs	r25, 0
				{
					if (USB_ControlRequest.bRequest == REQ_SetFeature)
    24ce:	1e c0       	rjmp	.+60     	; 0x250c <USB_Device_ProcessControlRequest+0x132>
    24d0:	90 91 64 0a 	lds	r25, 0x0A64	; 0x800a64 <USB_ControlRequest+0x1>
    24d4:	93 30       	cpi	r25, 0x03	; 3
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    24d6:	31 f4       	brne	.+12     	; 0x24e4 <USB_Device_ProcessControlRequest+0x10a>
    24d8:	eb ee       	ldi	r30, 0xEB	; 235
    24da:	f0 e0       	ldi	r31, 0x00	; 0
    24dc:	80 81       	ld	r24, Z
    24de:	80 62       	ori	r24, 0x20	; 32
    24e0:	80 83       	st	Z, r24
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_ClearStall(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearStall(void)
			{
				UECONX |= (1 << STALLRQC);
    24e2:	14 c0       	rjmp	.+40     	; 0x250c <USB_Device_ProcessControlRequest+0x132>
    24e4:	eb ee       	ldi	r30, 0xEB	; 235
    24e6:	f0 e0       	ldi	r31, 0x00	; 0
    24e8:	90 81       	ld	r25, Z
    24ea:	90 61       	ori	r25, 0x10	; 16
			 *  \param[in] Address  Endpoint address whose FIFO buffers are to be reset.
			 */
			static inline void Endpoint_ResetEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetEndpoint(const uint8_t Address)
			{
				UERST = (1 << (Address & ENDPOINT_EPNUM_MASK));
    24ec:	90 83       	st	Z, r25
    24ee:	21 e0       	ldi	r18, 0x01	; 1
    24f0:	30 e0       	ldi	r19, 0x00	; 0
    24f2:	a9 01       	movw	r20, r18
    24f4:	02 c0       	rjmp	.+4      	; 0x24fa <USB_Device_ProcessControlRequest+0x120>
    24f6:	44 0f       	add	r20, r20
    24f8:	55 1f       	adc	r21, r21
    24fa:	8a 95       	dec	r24
    24fc:	e2 f7       	brpl	.-8      	; 0x24f6 <USB_Device_ProcessControlRequest+0x11c>
    24fe:	aa ee       	ldi	r26, 0xEA	; 234
    2500:	b0 e0       	ldi	r27, 0x00	; 0
				UERST = 0;
    2502:	4c 93       	st	X, r20

			/** Resets the data toggle of the currently selected endpoint. */
			static inline void Endpoint_ResetDataToggle(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetDataToggle(void)
			{
				UECONX |= (1 << RSTDT);
    2504:	1c 92       	st	X, r1
    2506:	80 81       	ld	r24, Z
    2508:	88 60       	ori	r24, 0x08	; 8
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    250a:	80 83       	st	Z, r24
    250c:	10 92 e9 00 	sts	0x00E9, r1	; 0x8000e9 <__TEXT_REGION_LENGTH__+0x7e00e9>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    2510:	e8 ee       	ldi	r30, 0xE8	; 232
    2512:	f0 e0       	ldi	r31, 0x00	; 0
    2514:	80 81       	ld	r24, Z

	Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);

	Endpoint_ClearSETUP();

	Endpoint_ClearStatusStage();
    2516:	87 7f       	andi	r24, 0xF7	; 247
    2518:	80 83       	st	Z, r24
    251a:	dc dd       	rcall	.-1096   	; 0x20d4 <Endpoint_ClearStatusStage>
					USB_Device_ClearSetFeature();
				}

				break;
			case REQ_SetAddress:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
    251c:	b2 c0       	rjmp	.+356    	; 0x2682 <USB_Device_ProcessControlRequest+0x2a8>
    251e:	91 11       	cpse	r25, r1
	}
}

static void USB_Device_SetAddress(void)
{
	uint8_t DeviceAddress = (USB_ControlRequest.wValue & 0x7F);
    2520:	b0 c0       	rjmp	.+352    	; 0x2682 <USB_Device_ProcessControlRequest+0x2a8>
    2522:	10 91 65 0a 	lds	r17, 0x0A65	; 0x800a65 <USB_ControlRequest+0x2>
			#endif

			static inline void USB_Device_SetDeviceAddress(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_SetDeviceAddress(const uint8_t Address)
			{
				UDADDR = (UDADDR & (1 << ADDEN)) | (Address & 0x7F);
    2526:	1f 77       	andi	r17, 0x7F	; 127
    2528:	e3 ee       	ldi	r30, 0xE3	; 227
    252a:	f0 e0       	ldi	r31, 0x00	; 0
    252c:	80 81       	ld	r24, Z
    252e:	80 78       	andi	r24, 0x80	; 128
    2530:	81 2b       	or	r24, r17
    2532:	80 83       	st	Z, r24
    2534:	e8 ee       	ldi	r30, 0xE8	; 232
    2536:	f0 e0       	ldi	r31, 0x00	; 0
    2538:	80 81       	ld	r24, Z

	USB_Device_SetDeviceAddress(DeviceAddress);

	Endpoint_ClearSETUP();

	Endpoint_ClearStatusStage();
    253a:	87 7f       	andi	r24, 0xF7	; 247
    253c:	80 83       	st	Z, r24
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    253e:	ca dd       	rcall	.-1132   	; 0x20d4 <Endpoint_ClearStatusStage>
    2540:	e8 ee       	ldi	r30, 0xE8	; 232
    2542:	f0 e0       	ldi	r31, 0x00	; 0

	while (!(Endpoint_IsINReady()));
    2544:	80 81       	ld	r24, Z
    2546:	80 ff       	sbrs	r24, 0
			static inline void USB_Device_EnableDeviceAddress(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_EnableDeviceAddress(const uint8_t Address)
			{
				(void)Address;

				UDADDR |= (1 << ADDEN);
    2548:	fd cf       	rjmp	.-6      	; 0x2544 <USB_Device_ProcessControlRequest+0x16a>
    254a:	e3 ee       	ldi	r30, 0xE3	; 227
    254c:	f0 e0       	ldi	r31, 0x00	; 0
    254e:	80 81       	ld	r24, Z
    2550:	80 68       	ori	r24, 0x80	; 128

	USB_Device_EnableDeviceAddress(DeviceAddress);

	USB_DeviceState = (DeviceAddress) ? DEVICE_STATE_Addressed : DEVICE_STATE_Default;
    2552:	80 83       	st	Z, r24
    2554:	11 11       	cpse	r17, r1
    2556:	02 c0       	rjmp	.+4      	; 0x255c <USB_Device_ProcessControlRequest+0x182>
    2558:	82 e0       	ldi	r24, 0x02	; 2
    255a:	01 c0       	rjmp	.+2      	; 0x255e <USB_Device_ProcessControlRequest+0x184>
    255c:	83 e0       	ldi	r24, 0x03	; 3
    255e:	80 93 62 0a 	sts	0x0A62, r24	; 0x800a62 <USB_DeviceState>
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_SetAddress();

				break;
			case REQ_GetDescriptor:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    2562:	8f c0       	rjmp	.+286    	; 0x2682 <USB_Device_ProcessControlRequest+0x2a8>
    2564:	90 58       	subi	r25, 0x80	; 128
    2566:	92 30       	cpi	r25, 0x02	; 2
    2568:	08 f0       	brcs	.+2      	; 0x256c <USB_Device_ProcessControlRequest+0x192>
	    !(defined(USE_FLASH_DESCRIPTORS) || defined(USE_EEPROM_DESCRIPTORS) || defined(USE_RAM_DESCRIPTORS))
	uint8_t DescriptorAddressSpace;
	#endif

	#if !defined(NO_INTERNAL_SERIAL) && (USE_INTERNAL_SERIAL != NO_DESCRIPTOR)
	if (USB_ControlRequest.wValue == ((DTYPE_String << 8) | USE_INTERNAL_SERIAL))
    256a:	8b c0       	rjmp	.+278    	; 0x2682 <USB_Device_ProcessControlRequest+0x2a8>
    256c:	80 91 65 0a 	lds	r24, 0x0A65	; 0x800a65 <USB_ControlRequest+0x2>
    2570:	90 91 66 0a 	lds	r25, 0x0A66	; 0x800a66 <USB_ControlRequest+0x3>
    2574:	8c 3d       	cpi	r24, 0xDC	; 220
    2576:	53 e0       	ldi	r21, 0x03	; 3
    2578:	95 07       	cpc	r25, r21
	{
		USB_Descriptor_Header_t Header;
		uint16_t                UnicodeString[INTERNAL_SERIAL_LENGTH_BITS / 4];
	} SignatureDescriptor;

	SignatureDescriptor.Header.Type = DTYPE_String;
    257a:	99 f5       	brne	.+102    	; 0x25e2 <USB_Device_ProcessControlRequest+0x208>
    257c:	83 e0       	ldi	r24, 0x03	; 3
	SignatureDescriptor.Header.Size = USB_STRING_LEN(INTERNAL_SERIAL_LENGTH_BITS / 4);
    257e:	8a 83       	std	Y+2, r24	; 0x02
    2580:	8a e2       	ldi	r24, 0x2A	; 42
			static inline uint_reg_t GetGlobalInterruptMask(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				return SREG;
    2582:	89 83       	std	Y+1, r24	; 0x01
			static inline void GlobalInterruptDisable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				cli();
    2584:	5f b7       	in	r21, 0x3f	; 63
				__builtin_ssrf(AVR32_SR_GM_OFFSET);
				#elif (ARCH == ARCH_XMEGA)
				cli();
				#endif

				GCC_MEMORY_BARRIER();
    2586:	f8 94       	cli
    2588:	de 01       	movw	r26, r28
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();

				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
    258a:	13 96       	adiw	r26, 0x03	; 3
			static inline void USB_Device_GetSerialString(uint16_t* const UnicodeString)
			{
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();

				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;
    258c:	20 e0       	ldi	r18, 0x00	; 0

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
				{
					uint8_t SerialByte = boot_signature_byte_get(SigReadAddress);
    258e:	3e e0       	ldi	r19, 0x0E	; 14
    2590:	41 e2       	ldi	r20, 0x21	; 33
    2592:	e3 2f       	mov	r30, r19
    2594:	f0 e0       	ldi	r31, 0x00	; 0
    2596:	40 93 57 00 	sts	0x0057, r20	; 0x800057 <__TEXT_REGION_LENGTH__+0x7e0057>

					if (SerialCharNum & 0x01)
    259a:	84 91       	lpm	r24, Z
    259c:	20 ff       	sbrs	r18, 0
					{
						SerialByte >>= 4;
    259e:	03 c0       	rjmp	.+6      	; 0x25a6 <USB_Device_ProcessControlRequest+0x1cc>
    25a0:	82 95       	swap	r24
						SigReadAddress++;
    25a2:	8f 70       	andi	r24, 0x0F	; 15
					}

					SerialByte &= 0x0F;
    25a4:	3f 5f       	subi	r19, 0xFF	; 255

					UnicodeString[SerialCharNum] = cpu_to_le16((SerialByte >= 10) ?
    25a6:	8f 70       	andi	r24, 0x0F	; 15
    25a8:	8a 30       	cpi	r24, 0x0A	; 10
    25aa:	18 f0       	brcs	.+6      	; 0x25b2 <USB_Device_ProcessControlRequest+0x1d8>
    25ac:	90 e0       	ldi	r25, 0x00	; 0
    25ae:	c7 96       	adiw	r24, 0x37	; 55
    25b0:	02 c0       	rjmp	.+4      	; 0x25b6 <USB_Device_ProcessControlRequest+0x1dc>
    25b2:	90 e0       	ldi	r25, 0x00	; 0
    25b4:	c0 96       	adiw	r24, 0x30	; 48
    25b6:	8d 93       	st	X+, r24
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();

				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
    25b8:	9d 93       	st	X+, r25
    25ba:	2f 5f       	subi	r18, 0xFF	; 255
    25bc:	24 31       	cpi	r18, 0x14	; 20
			static inline void SetGlobalInterruptMask(const uint_reg_t GlobalIntState)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				SREG = GlobalIntState;
    25be:	49 f7       	brne	.-46     	; 0x2592 <USB_Device_ProcessControlRequest+0x1b8>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    25c0:	5f bf       	out	0x3f, r21	; 63
    25c2:	08 ee       	ldi	r16, 0xE8	; 232
    25c4:	10 e0       	ldi	r17, 0x00	; 0
    25c6:	f8 01       	movw	r30, r16
    25c8:	80 81       	ld	r24, Z

	USB_Device_GetSerialString(SignatureDescriptor.UnicodeString);

	Endpoint_ClearSETUP();

	Endpoint_Write_Control_Stream_LE(&SignatureDescriptor, sizeof(SignatureDescriptor));
    25ca:	87 7f       	andi	r24, 0xF7	; 247
    25cc:	80 83       	st	Z, r24
    25ce:	6a e2       	ldi	r22, 0x2A	; 42
    25d0:	70 e0       	ldi	r23, 0x00	; 0
    25d2:	ce 01       	movw	r24, r28
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    25d4:	01 96       	adiw	r24, 0x01	; 1
    25d6:	0f dc       	rcall	.-2018   	; 0x1df6 <Endpoint_Write_Control_Stream_LE>
    25d8:	f8 01       	movw	r30, r16
    25da:	80 81       	ld	r24, Z
    25dc:	8b 77       	andi	r24, 0x7B	; 123
		USB_Device_GetInternalSerialDescriptor();
		return;
	}
	#endif

	if ((DescriptorSize = CALLBACK_USB_GetDescriptor(USB_ControlRequest.wValue, USB_ControlRequest.wIndex,
    25de:	80 83       	st	Z, r24
    25e0:	50 c0       	rjmp	.+160    	; 0x2682 <USB_Device_ProcessControlRequest+0x2a8>
    25e2:	60 91 67 0a 	lds	r22, 0x0A67	; 0x800a67 <USB_ControlRequest+0x4>
    25e6:	70 91 68 0a 	lds	r23, 0x0A68	; 0x800a68 <USB_ControlRequest+0x5>
    25ea:	ae 01       	movw	r20, r28
    25ec:	4f 5f       	subi	r20, 0xFF	; 255
    25ee:	5f 4f       	sbci	r21, 0xFF	; 255
    25f0:	0e 94 1f 03 	call	0x63e	; 0x63e <CALLBACK_USB_GetDescriptor>
    25f4:	bc 01       	movw	r22, r24
    25f6:	89 2b       	or	r24, r25
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    25f8:	09 f4       	brne	.+2      	; 0x25fc <USB_Device_ProcessControlRequest+0x222>
    25fa:	43 c0       	rjmp	.+134    	; 0x2682 <USB_Device_ProcessControlRequest+0x2a8>
    25fc:	08 ee       	ldi	r16, 0xE8	; 232
    25fe:	10 e0       	ldi	r17, 0x00	; 0
    2600:	f8 01       	movw	r30, r16
	#if defined(USE_RAM_DESCRIPTORS) || !defined(ARCH_HAS_MULTI_ADDRESS_SPACE)
	Endpoint_Write_Control_Stream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_EEPROM_DESCRIPTORS)
	Endpoint_Write_Control_EStream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_FLASH_DESCRIPTORS)
	Endpoint_Write_Control_PStream_LE(DescriptorPointer, DescriptorSize);
    2602:	90 81       	ld	r25, Z
    2604:	97 7f       	andi	r25, 0xF7	; 247
    2606:	90 83       	st	Z, r25
    2608:	89 81       	ldd	r24, Y+1	; 0x01
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    260a:	9a 81       	ldd	r25, Y+2	; 0x02
    260c:	78 dc       	rcall	.-1808   	; 0x1efe <Endpoint_Write_Control_PStream_LE>
    260e:	f8 01       	movw	r30, r16
    2610:	80 81       	ld	r24, Z
    2612:	8b 77       	andi	r24, 0x7B	; 123
					USB_Device_GetDescriptor();
				}

				break;
			case REQ_GetConfiguration:
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
    2614:	80 83       	st	Z, r24
    2616:	35 c0       	rjmp	.+106    	; 0x2682 <USB_Device_ProcessControlRequest+0x2a8>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    2618:	90 38       	cpi	r25, 0x80	; 128
    261a:	99 f5       	brne	.+102    	; 0x2682 <USB_Device_ProcessControlRequest+0x2a8>
    261c:	e8 ee       	ldi	r30, 0xE8	; 232
    261e:	f0 e0       	ldi	r31, 0x00	; 0
    2620:	80 81       	ld	r24, Z

static void USB_Device_GetConfiguration(void)
{
	Endpoint_ClearSETUP();

	Endpoint_Write_8(USB_Device_ConfigurationNumber);
    2622:	87 7f       	andi	r24, 0xF7	; 247
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    2624:	80 83       	st	Z, r24
    2626:	80 91 5e 0a 	lds	r24, 0x0A5E	; 0x800a5e <USB_Device_ConfigurationNumber>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    262a:	80 93 f1 00 	sts	0x00F1, r24	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7e00f1>
	Endpoint_ClearIN();

	Endpoint_ClearStatusStage();
    262e:	80 81       	ld	r24, Z
    2630:	8e 77       	andi	r24, 0x7E	; 126
    2632:	80 83       	st	Z, r24
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_GetConfiguration();

				break;
			case REQ_SetConfiguration:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
    2634:	4f dd       	rcall	.-1378   	; 0x20d4 <Endpoint_ClearStatusStage>
    2636:	25 c0       	rjmp	.+74     	; 0x2682 <USB_Device_ProcessControlRequest+0x2a8>
}

static void USB_Device_SetConfiguration(void)
{
	#if defined(FIXED_NUM_CONFIGURATIONS)
	if ((uint8_t)USB_ControlRequest.wValue > FIXED_NUM_CONFIGURATIONS)
    2638:	91 11       	cpse	r25, r1
    263a:	23 c0       	rjmp	.+70     	; 0x2682 <USB_Device_ProcessControlRequest+0x2a8>
    263c:	80 91 65 0a 	lds	r24, 0x0A65	; 0x800a65 <USB_ControlRequest+0x2>
    2640:	90 91 66 0a 	lds	r25, 0x0A66	; 0x800a66 <USB_ControlRequest+0x3>
    2644:	99 27       	eor	r25, r25
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    2646:	02 97       	sbiw	r24, 0x02	; 2
    2648:	e4 f4       	brge	.+56     	; 0x2682 <USB_Device_ProcessControlRequest+0x2a8>
    264a:	e8 ee       	ldi	r30, 0xE8	; 232
    264c:	f0 e0       	ldi	r31, 0x00	; 0
	#endif
	#endif

	Endpoint_ClearSETUP();

	USB_Device_ConfigurationNumber = (uint8_t)USB_ControlRequest.wValue;
    264e:	80 81       	ld	r24, Z
    2650:	87 7f       	andi	r24, 0xF7	; 247
    2652:	80 83       	st	Z, r24
    2654:	80 91 65 0a 	lds	r24, 0x0A65	; 0x800a65 <USB_ControlRequest+0x2>

	Endpoint_ClearStatusStage();
    2658:	80 93 5e 0a 	sts	0x0A5E, r24	; 0x800a5e <USB_Device_ConfigurationNumber>

	if (USB_Device_ConfigurationNumber)
    265c:	3b dd       	rcall	.-1418   	; 0x20d4 <Endpoint_ClearStatusStage>
    265e:	80 91 5e 0a 	lds	r24, 0x0A5E	; 0x800a5e <USB_Device_ConfigurationNumber>
	  USB_DeviceState = DEVICE_STATE_Configured;
    2662:	88 23       	and	r24, r24
    2664:	21 f0       	breq	.+8      	; 0x266e <USB_Device_ProcessControlRequest+0x294>
    2666:	84 e0       	ldi	r24, 0x04	; 4
    2668:	80 93 62 0a 	sts	0x0A62, r24	; 0x800a62 <USB_DeviceState>
	else
	  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Configured : DEVICE_STATE_Powered;
    266c:	09 c0       	rjmp	.+18     	; 0x2680 <USB_Device_ProcessControlRequest+0x2a6>
    266e:	80 91 e3 00 	lds	r24, 0x00E3	; 0x8000e3 <__TEXT_REGION_LENGTH__+0x7e00e3>
    2672:	88 23       	and	r24, r24
    2674:	14 f0       	brlt	.+4      	; 0x267a <USB_Device_ProcessControlRequest+0x2a0>
    2676:	81 e0       	ldi	r24, 0x01	; 1
    2678:	01 c0       	rjmp	.+2      	; 0x267c <USB_Device_ProcessControlRequest+0x2a2>

	EVENT_USB_Device_ConfigurationChanged();
    267a:	84 e0       	ldi	r24, 0x04	; 4
    267c:	80 93 62 0a 	sts	0x0A62, r24	; 0x800a62 <USB_DeviceState>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    2680:	d9 d9       	rcall	.-3150   	; 0x1a34 <EVENT_USB_Device_ConfigurationChanged>
			default:
				break;
		}
	}

	if (Endpoint_IsSETUPReceived())
    2682:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    2686:	83 ff       	sbrs	r24, 3
    2688:	16 c0       	rjmp	.+44     	; 0x26b6 <USB_Device_ProcessControlRequest+0x2dc>
    268a:	e8 ee       	ldi	r30, 0xE8	; 232
    268c:	f0 e0       	ldi	r31, 0x00	; 0
    268e:	80 81       	ld	r24, Z
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    2690:	87 7f       	andi	r24, 0xF7	; 247
    2692:	80 83       	st	Z, r24
    2694:	eb ee       	ldi	r30, 0xEB	; 235
    2696:	f0 e0       	ldi	r31, 0x00	; 0
    2698:	80 81       	ld	r24, Z
	{
		Endpoint_ClearSETUP();
		Endpoint_StallTransaction();
	}
}
    269a:	80 62       	ori	r24, 0x20	; 32
	switch (USB_ControlRequest.bmRequestType & CONTROL_REQTYPE_RECIPIENT)
	{
		#if !defined(NO_DEVICE_REMOTE_WAKEUP)
		case REQREC_DEVICE:
		{
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_DeviceRemoteWakeup)
    269c:	80 83       	st	Z, r24
    269e:	0b c0       	rjmp	.+22     	; 0x26b6 <USB_Device_ProcessControlRequest+0x2dc>
    26a0:	90 91 65 0a 	lds	r25, 0x0A65	; 0x800a65 <USB_ControlRequest+0x2>
    26a4:	91 30       	cpi	r25, 0x01	; 1
		}
		#endif
		#if !defined(CONTROL_ONLY_DEVICE)
		case REQREC_ENDPOINT:
		{
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_EndpointHalt)
    26a6:	69 f7       	brne	.-38     	; 0x2682 <USB_Device_ProcessControlRequest+0x2a8>
    26a8:	fe ce       	rjmp	.-516    	; 0x24a6 <USB_Device_ProcessControlRequest+0xcc>
    26aa:	80 91 65 0a 	lds	r24, 0x0A65	; 0x800a65 <USB_ControlRequest+0x2>
    26ae:	88 23       	and	r24, r24
    26b0:	09 f4       	brne	.+2      	; 0x26b4 <USB_Device_ProcessControlRequest+0x2da>
	if (Endpoint_IsSETUPReceived())
	{
		Endpoint_ClearSETUP();
		Endpoint_StallTransaction();
	}
}
    26b2:	00 cf       	rjmp	.-512    	; 0x24b4 <USB_Device_ProcessControlRequest+0xda>
    26b4:	2b cf       	rjmp	.-426    	; 0x250c <USB_Device_ProcessControlRequest+0x132>
    26b6:	aa 96       	adiw	r28, 0x2a	; 42
    26b8:	0f b6       	in	r0, 0x3f	; 63
    26ba:	f8 94       	cli
    26bc:	de bf       	out	0x3e, r29	; 62
    26be:	0f be       	out	0x3f, r0	; 63
    26c0:	cd bf       	out	0x3d, r28	; 61
    26c2:	df 91       	pop	r29
    26c4:	cf 91       	pop	r28
    26c6:	1f 91       	pop	r17
    26c8:	0f 91       	pop	r16
    26ca:	08 95       	ret

000026cc <USB_Event_Stub>:
#define  __INCLUDE_FROM_EVENTS_C
#define  __INCLUDE_FROM_USB_DRIVER
#include "Events.h"

void USB_Event_Stub(void)
{
    26cc:	08 95       	ret

000026ce <USB_USBTask>:
#if defined(USB_CAN_BE_DEVICE) && !defined(DEVICE_STATE_AS_GPIOR)
volatile uint8_t     USB_DeviceState;
#endif

void USB_USBTask(void)
{
    26ce:	cf 93       	push	r28
}

#if defined(USB_CAN_BE_DEVICE)
static void USB_DeviceTask(void)
{
	if (USB_DeviceState == DEVICE_STATE_Unattached)
    26d0:	80 91 62 0a 	lds	r24, 0x0A62	; 0x800a62 <USB_DeviceState>
    26d4:	88 23       	and	r24, r24
    26d6:	99 f0       	breq	.+38     	; 0x26fe <USB_USBTask+0x30>
			 */
			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					return ((UENUM & ENDPOINT_EPNUM_MASK) | Endpoint_GetEndpointDirection());
    26d8:	c0 91 e9 00 	lds	r28, 0x00E9	; 0x8000e9 <__TEXT_REGION_LENGTH__+0x7e00e9>
    26dc:	cf 70       	andi	r28, 0x0F	; 15
			 *  \return The currently selected endpoint's direction, as a \c ENDPOINT_DIR_* mask.
			 */
			static inline uint8_t Endpoint_GetEndpointDirection(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetEndpointDirection(void)
			{
				return (UECFG0X & (1 << EPDIR)) ? ENDPOINT_DIR_IN : ENDPOINT_DIR_OUT;
    26de:	80 91 ec 00 	lds	r24, 0x00EC	; 0x8000ec <__TEXT_REGION_LENGTH__+0x7e00ec>
    26e2:	98 2f       	mov	r25, r24
    26e4:	91 70       	andi	r25, 0x01	; 1
    26e6:	80 fd       	sbrc	r24, 0
    26e8:	90 e8       	ldi	r25, 0x80	; 128
			 */
			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					return ((UENUM & ENDPOINT_EPNUM_MASK) | Endpoint_GetEndpointDirection());
    26ea:	c9 2b       	or	r28, r25
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    26ec:	10 92 e9 00 	sts	0x00E9, r1	; 0x8000e9 <__TEXT_REGION_LENGTH__+0x7e00e9>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    26f0:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
	uint8_t PrevEndpoint = Endpoint_GetCurrentEndpoint();

	Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);

	if (Endpoint_IsSETUPReceived())
	  USB_Device_ProcessControlRequest();
    26f4:	83 fd       	sbrc	r24, 3
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    26f6:	71 de       	rcall	.-798    	; 0x23da <USB_Device_ProcessControlRequest>
    26f8:	cf 70       	andi	r28, 0x0F	; 15
    26fa:	c0 93 e9 00 	sts	0x00E9, r28	; 0x8000e9 <__TEXT_REGION_LENGTH__+0x7e00e9>
	#elif defined(USB_CAN_BE_HOST)
		USB_HostTask();
	#elif defined(USB_CAN_BE_DEVICE)
		USB_DeviceTask();
	#endif
}
    26fe:	cf 91       	pop	r28
    2700:	08 95       	ret

00002702 <memcpy_P>:
    2702:	fb 01       	movw	r30, r22
    2704:	dc 01       	movw	r26, r24
    2706:	02 c0       	rjmp	.+4      	; 0x270c <memcpy_P+0xa>
    2708:	05 90       	lpm	r0, Z+
    270a:	0d 92       	st	X+, r0
    270c:	41 50       	subi	r20, 0x01	; 1
    270e:	50 40       	sbci	r21, 0x00	; 0
    2710:	d8 f7       	brcc	.-10     	; 0x2708 <memcpy_P+0x6>
    2712:	08 95       	ret

00002714 <memcpy>:
    2714:	fb 01       	movw	r30, r22
    2716:	dc 01       	movw	r26, r24
    2718:	02 c0       	rjmp	.+4      	; 0x271e <memcpy+0xa>
    271a:	01 90       	ld	r0, Z+
    271c:	0d 92       	st	X+, r0
    271e:	41 50       	subi	r20, 0x01	; 1
    2720:	50 40       	sbci	r21, 0x00	; 0
    2722:	d8 f7       	brcc	.-10     	; 0x271a <memcpy+0x6>
    2724:	08 95       	ret

00002726 <eeprom_read_byte>:
    2726:	f9 99       	sbic	0x1f, 1	; 31
    2728:	fe cf       	rjmp	.-4      	; 0x2726 <eeprom_read_byte>
    272a:	92 bd       	out	0x22, r25	; 34
    272c:	81 bd       	out	0x21, r24	; 33
    272e:	f8 9a       	sbi	0x1f, 0	; 31
    2730:	99 27       	eor	r25, r25
    2732:	80 b5       	in	r24, 0x20	; 32
    2734:	08 95       	ret

00002736 <eeprom_update_byte>:
    2736:	26 2f       	mov	r18, r22

00002738 <eeprom_update_r18>:
    2738:	f9 99       	sbic	0x1f, 1	; 31
    273a:	fe cf       	rjmp	.-4      	; 0x2738 <eeprom_update_r18>
    273c:	92 bd       	out	0x22, r25	; 34
    273e:	81 bd       	out	0x21, r24	; 33
    2740:	f8 9a       	sbi	0x1f, 0	; 31
    2742:	01 97       	sbiw	r24, 0x01	; 1
    2744:	00 b4       	in	r0, 0x20	; 32
    2746:	02 16       	cp	r0, r18
    2748:	39 f0       	breq	.+14     	; 0x2758 <eeprom_update_r18+0x20>
    274a:	1f ba       	out	0x1f, r1	; 31
    274c:	20 bd       	out	0x20, r18	; 32
    274e:	0f b6       	in	r0, 0x3f	; 63
    2750:	f8 94       	cli
    2752:	fa 9a       	sbi	0x1f, 2	; 31
    2754:	f9 9a       	sbi	0x1f, 1	; 31
    2756:	0f be       	out	0x3f, r0	; 63
    2758:	08 95       	ret

0000275a <_exit>:
    275a:	f8 94       	cli

0000275c <__stop_program>:
    275c:	ff cf       	rjmp	.-2      	; 0x275c <__stop_program>
